// Be aware — Google Chrome has serious issue — you can rewrite READ-ONLY property (if it is defined in prototype). Firefox and Safari work correct.
// Always test property access issues in Firefox, but not in Chrome.
var Kotlin = Object.create(null);

(function () {
    

    Kotlin.keys = Object.keys;

    Kotlin.isType = function (object, type) {
        if (object === null || object === undefined) {
            return false;
        }

        var proto = Object.getPrototypeOf(object);
        // todo test nested class
        //noinspection RedundantIfStatementJS
        if (proto == type.proto) {
            return true;
        }

        return false;
    };

    // as separated function to reduce scope
    function createConstructor() {
        return function $fun() {
            var o = Object.create($fun.proto);
            var initializer = $fun.initializer;
            if (initializer != null) {
                if (initializer.length == 0) {
                    initializer.call(o);
                }
                else {
                    initializer.apply(o, arguments);
                }
            }

            Object.seal(o);
            return o;
        };
    }

    function computeProto(bases, properties) {
        var proto = null;
        for (var i = 0, n = bases.length; i < n; i++) {
            var base = bases[i];
            var baseProto = base.proto;
            if (baseProto === null || base.properties === null) {
                continue;
            }

            if (proto === null) {
                proto = Object.create(baseProto, properties || undefined);
                continue;
            }
            Object.defineProperties(proto, base.properties);
            // todo test A -> B, C(->D) *properties from D is not yet added to proto*
        }

        return proto;
    }

    Kotlin.createTrait = function (bases, properties, staticProperties) {
        return createClass(bases, null, properties, staticProperties, false);
    };

    Kotlin.createClass = function (bases, initializer, properties, staticProperties) {
        // proto must be created for class even if it is not needed (requires for is operator)
        return createClass(bases, initializer === null ? function () {} : initializer, properties, staticProperties, true);
    };

    function computeProto2(bases, properties) {
        if (bases === null) {
            return Object.prototype;
        }
        return Array.isArray(bases) ? computeProto(bases, properties) : bases.proto;
    }

    Kotlin.createObject = function (bases, initializer, properties) {
        var o = Object.create(computeProto2(bases, properties), properties || undefined);
        if (initializer !== null) {
            if (bases !== null) {
                Object.defineProperty(initializer, "baseInitializer", {value: Array.isArray(bases) ? bases[0].initializer : bases.initializer});
            }
            initializer.call(o);
        }
        Object.seal(o);
        return o;
    };

    function class_object$() {
        if (typeof this.$object$ === "undefined") {
            this.$object$ = this.object_initializer$();
        }

        return this.$object$;
    }

    function createClass(bases, initializer, properties, staticProperties, isClass) {
        var proto;
        var baseInitializer;
        if (bases === null) {
            baseInitializer = null;
            proto = !isClass && properties === null ? null : Object.create(null, properties || undefined);
        }
        else if (!Array.isArray(bases)) {
            baseInitializer = bases.initializer;
            proto = !isClass && properties === null ? bases.proto : Object.create(bases.proto, properties || undefined);
        }
        else {
            // first is superclass, other are traits
            baseInitializer = bases[0].initializer;
            proto = computeProto(bases, properties);
            // all bases are traits without properties
            if (proto === null && isClass) {
                proto = Object.create(null, properties || undefined);
            }
        }

        var constructor = createConstructor();
        Object.defineProperty(constructor, "object$", {value: class_object$});
        Object.defineProperty(constructor, "$object$", {value: undefined, writable: true});

        Object.defineProperty(constructor, "proto", {value: proto});
        Object.defineProperty(constructor, "properties", {value: properties || null});
        if (isClass) {
            Object.defineProperty(constructor, "initializer", {value: initializer});

            Object.defineProperty(initializer, "baseInitializer", {value: baseInitializer});
            Object.freeze(initializer);
        }

        if (staticProperties !== null && staticProperties !== undefined) {
            Object.defineProperties(constructor, staticProperties);
        }

        Object.seal(constructor);
        return constructor;
    }

    Kotlin.definePackage = function (initializer, members) {
        var definition = Object.create(null, members === null ? undefined : members);
        if (initializer === null) {
            return {value: definition};
        }
        else {
            var getter = createPackageGetter(definition, initializer);
            Object.freeze(getter);
            return {get: getter};
        }
    };

    function createPackageGetter(instance, initializer) {
        return function () {
            if (initializer !== null) {
                var tmp = initializer;
                initializer = null;
                tmp.call(instance);
                Object.seal(instance);
            }

            return instance;
        };
    }

    Kotlin.$new = function (f) {
        return f;
    };

    Kotlin.$createClass = function (parent, properties) {
        if (parent !== null && typeof (parent) != "function") {
            properties = parent;
            parent = null;
        }

        var initializer = null;
        var descriptors = properties ? {} : null;
        if (descriptors != null) {
            var ownPropertyNames = Object.getOwnPropertyNames(properties);
            for (var i = 0, n = ownPropertyNames.length; i < n; i++) {
                var name = ownPropertyNames[i];
                var value = properties[name];
                if (name == "initialize") {
                    initializer = value;
                }
                else if (name.indexOf("get_") === 0) {
                    descriptors[name.substring(4)] = {get: value};
                    // std lib code can refers to
                    descriptors[name] = {value: value};
                }
                else if (name.indexOf("set_") === 0) {
                    descriptors[name.substring(4)] = {set: value};
                    // std lib code can refers to
                    descriptors[name] = {value: value};
                }
                else {
                    // we assume all our std lib functions are open
                    descriptors[name] = {value: value, writable: true};
                }
            }
        }

        return Kotlin.createClass(parent || null, initializer, descriptors);
    };

    Kotlin.defineModule = function (id, module) {
        if (id in Kotlin.modules) {
            throw Kotlin.$new(Kotlin.IllegalArgumentException)();
        }

        Object.freeze(module);
        Object.defineProperty(Kotlin.modules, id, {value: module});
    };
})();
/**
 * Copyright 2010 Tim Down.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



// todo inlined
String.prototype.startsWith = function (s) {
  return this.indexOf(s) === 0;
};

String.prototype.endsWith = function (s) {
  return this.indexOf(s, this.length - s.length) !== -1;
};

String.prototype.contains = function (s) {
  return this.indexOf(s) !== -1;
};

(function () {
    Kotlin.equals = function (obj1, obj2) {
        if (obj1 == null) {
            return obj2 == null;
        }

        if (Array.isArray(obj1)) {
            return Kotlin.arrayEquals(obj1, obj2);
        }

        if (typeof obj1 == "object" && obj1.equals !== undefined) {
            return obj1.equals(obj2);
        }

        return obj1 === obj2;
    };

    Kotlin.toString = function (o) {
        if (o == null) {
            return "null";
        }
        else if (Array.isArray(o)) {
            return Kotlin.arrayToString(o);
        }
        else {
            return o.toString();
        }
    };
    
    Kotlin.arrayToString = function(a) {
        return "[" + a.join(", ") + "]";
    };

    Kotlin.intUpto = function (from, to) {
        return Kotlin.$new(Kotlin.NumberRange)(from, to);
    };

    Kotlin.intDownto = function (from, to) {
        return Kotlin.$new(Kotlin.Progression)(from, to, -1);
    };

    Kotlin.modules = {};

    Kotlin.RuntimeException = Kotlin.$createClass();
    Kotlin.NullPointerException = Kotlin.$createClass();
    Kotlin.NoSuchElementException = Kotlin.$createClass();
    Kotlin.IllegalArgumentException = Kotlin.$createClass();
    Kotlin.IllegalStateException = Kotlin.$createClass();
    Kotlin.UnsupportedOperationException = Kotlin.$createClass();
    Kotlin.IOException = Kotlin.$createClass();

    Kotlin.throwNPE = function () {
        throw Kotlin.$new(Kotlin.NullPointerException)();
    };

    function throwAbstractFunctionInvocationError(funName) {
        return function() {
            var message;
            if (funName !== undefined) {
                message = "Function " + funName + " is abstract";
            } else {
                message = "Function is abstract";
            }
            throw new TypeError(message);
        };
    }

    Kotlin.Iterator = Kotlin.$createClass({
        initialize: function () {
        },
        next: throwAbstractFunctionInvocationError("Iterator#next"),
        hasNext: throwAbstractFunctionInvocationError("Iterator#hasNext")
    });

    var ArrayIterator = Kotlin.$createClass(Kotlin.Iterator, {
        initialize: function (array) {
            this.array = array;
            this.size = array.length;
            this.index = 0;
        },
        next: function () {
            return this.array[this.index++];
        },
        hasNext: function () {
            return this.index < this.size;
        }
    });

    var ListIterator = Kotlin.$createClass(ArrayIterator, {
        initialize: function (list) {
            this.list = list;
            this.size = list.size();
            this.index = 0;
        },
        next: function () {
            return this.list.get(this.index++);
        }
    });

    Kotlin.Collection = Kotlin.$createClass();

    Kotlin.Enum = Kotlin.$createClass(null, {
        initialize: function () {
            this.name$ = undefined;
            this.ordinal$ = undefined;
        },
        name: function () {
            return this.name$;
        },
        ordinal: function () {
            return this.ordinal$;
        },
        toString: function () {
            return this.name();
        }
    });
    (function (){
        function valueOf(name) {
            return this[name];
        }
        function getValues() {
            return this.values$;
        }

        Kotlin.createEnumEntries = function(enumEntryList) {
            var i = 0;
            var values = [];
            for (var entryName in enumEntryList) {
                if (enumEntryList.hasOwnProperty(entryName)) {
                    var entryObject = enumEntryList[entryName];
                    values[i] = entryObject;
                    entryObject.ordinal$ = i;
                    entryObject.name$ = entryName;
                    i++;
                }
            }
            enumEntryList.values$ = values;
            enumEntryList.valueOf = valueOf;
            enumEntryList.values = getValues;
            return enumEntryList;
        };
    })();

    Kotlin.PropertyMetadata = Kotlin.$createClass(null, {
        initialize: function(name) {
            this.$name = name;
        },
        get_name: function () {
            return this.$name;
        }
    });

    Kotlin.AbstractCollection = Kotlin.$createClass(Kotlin.Collection, {
        size: function () {
            return this.$size;
        },
        addAll: function (collection) {
            var it = collection.iterator();
            var i = this.size();
            while (i-- > 0) {
                this.add(it.next());
            }
        },
        isEmpty: function () {
            return this.size() === 0;
        },
        iterator: function () {
            return Kotlin.$new(ArrayIterator)(this.toArray());
        },
        equals: function (o) {
            if (this.size() !== o.size()) return false;

            var iterator1 = this.iterator();
            var iterator2 = o.iterator();
            var i = this.size();
            while (i-- > 0) {
                if (!Kotlin.equals(iterator1.next(), iterator2.next())) {
                    return false;
                }
            }

            return true;
        },
        toString: function () {
            var builder = "[";
            var iterator = this.iterator();
            var first = true;
            var i = this.$size;
            while (i-- > 0) {
                if (first) {
                    first = false;
                }
                else {
                    builder += ", ";
                }
                builder += iterator.next();
            }
            builder += "]";
            return builder;
        },
        toJSON: function () {
            return this.toArray();
        }
    });

    Kotlin.AbstractList = Kotlin.$createClass(Kotlin.AbstractCollection, {
        iterator: function () {
            return Kotlin.$new(ListIterator)(this);
        },
        remove: function (o) {
            var index = this.indexOf(o);
            if (index !== -1) {
                this.removeAt(index);
            }
        },
        contains: function (o) {
            return this.indexOf(o) !== -1;
        }
    });

    //TODO: should be JS Array-like (https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Predefined_Core_Objects#Working_with_Array-like_objects)
    Kotlin.ArrayList = Kotlin.$createClass(Kotlin.AbstractList, {
        initialize: function () {
            this.array = [];
            this.$size = 0;
        },
        get: function (index) {
            this.checkRange(index);
            return this.array[index];
        },
        set: function (index, value) {
            this.checkRange(index);
            this.array[index] = value;
        },
        size: function () {
            return this.$size;
        },
        iterator: function () {
            return Kotlin.arrayIterator(this.array);
        },
        add: function (element) {
            this.array[this.$size++] = element;
        },
        addAt: function (index, element) {
            this.array.splice(index, 0, element);
            this.$size++;
        },
        addAll: function (collection) {
            var it = collection.iterator();
            for (var i = this.$size, n = collection.size(); n-- > 0;) {
                this.array[i++] = it.next();
            }

            this.$size += collection.size();
        },
        removeAt: function (index) {
            this.checkRange(index);
            this.$size--;
            return this.array.splice(index, 1)[0];
        },
        clear: function () {
            this.array.length = 0;
            this.$size = 0;
        },
        indexOf: function (o) {
            for (var i = 0, n = this.$size; i < n; ++i) {
                if (Kotlin.equals(this.array[i], o)) {
                    return i;
                }
            }
            return -1;
        },
        toArray: function () {
            return this.array.slice(0, this.$size);
        },
        toString: function () {
            return "[" + this.array.join(", ") + "]";
        },
        toJSON: function () {
            return this.array;
        },
        checkRange: function(index) {
            if (index < 0 || index >= this.$size) {
                throw new RangeError();
            }
        }
    });

    Kotlin.Runnable = Kotlin.$createClass({
        initialize: function () {
        },
        run: throwAbstractFunctionInvocationError("Runnable#run")
    });

    Kotlin.Comparable = Kotlin.$createClass({
        initialize: function () {
        },
        compareTo: throwAbstractFunctionInvocationError("Comparable#compareTo")
    });

    Kotlin.Appendable = Kotlin.$createClass({
        initialize: function () {
        },
        append: throwAbstractFunctionInvocationError("Appendable#append")
    });

    Kotlin.Closeable = Kotlin.$createClass({
        initialize: function () {
        },
        close: throwAbstractFunctionInvocationError("Closeable#close")
    });

    Kotlin.safeParseInt = function(str) {
        var r = parseInt(str, 10);
        return isNaN(r) ? null : r;
    };

    Kotlin.safeParseDouble = function(str) {
        var r = parseFloat(str);
        return isNaN(r) ? null : r;
    };

    Kotlin.arrayEquals = function (a, b) {
        if (a === b) {
            return true;
        }
        if (!Array.isArray(b) || a.length !== b.length) {
            return false;
        }

        for (var i = 0, n = a.length; i < n; i++) {
            if (!Kotlin.equals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    };

    Kotlin.System = function () {
        var output = "";

        var print = function (obj) {
            if (obj !== undefined) {
                if (obj === null || typeof obj !== "object") {
                    output += obj;
                }
                else {
                    output += obj.toString();
                }
            }
        };
        var println = function (obj) {
            this.print(obj);
            output += "\n";
        };

        return {
            out: function () {
                return {
                    print: print,
                    println: println
                };
            },
            output: function () {
                return output;
            },
            flush: function () {
                output = "";
            }
        };
    }();

    Kotlin.println = function (s) {
        Kotlin.System.out().println(s);
    };

    Kotlin.print = function (s) {
        Kotlin.System.out().print(s);
    };

    Kotlin.RangeIterator = Kotlin.$createClass(Kotlin.Iterator, {
        initialize: function (start, end, increment) {
            this.$start = start;
            this.$end = end;
            this.$increment = increment;
            this.$i = start;
        },
        get_start: function () {
            return this.$start;
        },
        get_end: function () {
            return this.$end;
        },
        get_i: function () {
            return this.$i;
        },
        set_i: function (tmp$0) {
            this.$i = tmp$0;
        },
        next: function () {
            var value = this.$i;
            this.set_i(this.$i + this.$increment);
            return value;
        },
        hasNext: function () {
            return this.get_count() > 0;
        }
    });

    Kotlin.NumberRange = Kotlin.$createClass({
        initialize: function (start, end) {
            this.$start = start;
            this.$end = end;
        },
        get_start: function () {
            return this.$start;
        },
        get_end: function () {
            return this.$end;
        },
        get_increment: function () {
            return 1;
        },
        contains: function (number) {
            return this.$start <= number && number <= this.$end;
        },
        iterator: function () {
            return Kotlin.$new(Kotlin.RangeIterator)(this.get_start(), this.get_end());
        }
    });

    Kotlin.Progression = Kotlin.$createClass({
        initialize: function (start, end, increment) {
            this.$start = start;
            this.$end = end;
            this.$increment = increment;
        },
        get_start: function () {
            return this.$start;
        },
        get_end: function () {
            return this.$end;
        },
        get_increment: function () {
            return this.$increment;
        },
        iterator: function () {
            return Kotlin.$new(Kotlin.RangeIterator)(this.get_start(), this.get_end(), this.get_increment());
        }
    });

    Kotlin.Comparator = Kotlin.$createClass({
        initialize: function () {
        },
        compare: throwAbstractFunctionInvocationError("Comparator#compare")
    });

    var ComparatorImpl = Kotlin.$createClass(Kotlin.Comparator, {
        initialize: function (comparator) {
            this.compare = comparator;
        }
    });

    Kotlin.comparator = function (f) {
        return Kotlin.$new(ComparatorImpl)(f);
    };

    Kotlin.collectionsMax = function (c, comp) {
        if (c.isEmpty()) {
            //TODO: which exception?
            throw new Error();
        }
        var it = c.iterator();
        var max = it.next();
        while (it.hasNext()) {
            var el = it.next();
            if (comp.compare(max, el) < 0) {
                max = el;
            }
        }
        return max;
    };

    Kotlin.collectionsSort = function (mutableList, comparator) {
        var boundComparator = undefined;
        if (comparator !== undefined) {
            boundComparator = comparator.compare.bind(comparator);
        }

        if (mutableList instanceof Array) {
            mutableList.sort(boundComparator);
        }

        //TODO: should be deleted when List will be JS Array-like (https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Predefined_Core_Objects#Working_with_Array-like_objects)
        var array = [];
        var it = mutableList.iterator();
        while (it.hasNext()) {
            array.push(it.next());
        }

        array.sort(boundComparator);

        for (var i = 0, n = array.length; i < n; i++) {
            mutableList.set(i, array[i]);
        }
    };


    Kotlin.StringBuilder = Kotlin.$createClass(
            {
                initialize:function () {
                    this.string = "";
                },
                append:function (obj) {
                    this.string = this.string + obj.toString();
                },
                toString:function () {
                    return this.string;
                }
            }
    );

    Kotlin.splitString = function (str, regex, limit) {
        return str.split(new RegExp(regex), limit);
    };

    Kotlin.nullArray = function (size) {
        var res = [];
        var i = size;
        while (i > 0) {
            res[--i] = null;
        }
        return res;
    };

    Kotlin.numberArrayOfSize = function (size) {
        return Kotlin.arrayFromFun(size, function(){ return 0; });
    };

    Kotlin.charArrayOfSize = function (size) {
        return Kotlin.arrayFromFun(size, function(){ return '\0'; });
    };

    Kotlin.booleanArrayOfSize = function (size) {
        return Kotlin.arrayFromFun(size, function(){ return false; });
    };

    Kotlin.arrayFromFun = function (size, initFun) {
        var result = new Array(size);
        for (var i = 0; i < size; i++) {
            result[i] = initFun(i);
        }
        return result;
    };

    Kotlin.arrayIndices = function (arr) {
        return Kotlin.$new(Kotlin.NumberRange)(0, arr.length - 1);
    };

    Kotlin.arrayIterator = function (array) {
        return Kotlin.$new(ArrayIterator)(array);
    };

    Kotlin.jsonFromTuples = function (pairArr) {
        var i = pairArr.length;
        var res = {};
        while (i > 0) {
            --i;
            res[pairArr[i][0]] = pairArr[i][1];
        }
        return res;
    };

    Kotlin.jsonAddProperties = function (obj1, obj2) {
        for (var p in obj2) {
            if (obj2.hasOwnProperty(p)) {
                obj1[p] = obj2[p];
            }
        }
        return obj1;
    };
})();

Kotlin.assignOwner = function(f, o) {
  f.o = o;
  return f;
};
/*
 * Copyright 2010-2013 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


(function () {
    var FUNCTION = "function";
    var arrayRemoveAt = (typeof Array.prototype.splice == FUNCTION) ?
                        function (arr, idx) {
                            arr.splice(idx, 1);
                        } :

                        function (arr, idx) {
                            var itemsAfterDeleted, i, len;
                            if (idx === arr.length - 1) {
                                arr.length = idx;
                            }
                            else {
                                itemsAfterDeleted = arr.slice(idx + 1);
                                arr.length = idx;
                                for (i = 0, len = itemsAfterDeleted.length; i < len; ++i) {
                                    arr[idx + i] = itemsAfterDeleted[i];
                                }
                            }
                        };

    function hashObject(obj) {
        var hashCode;
        if (typeof obj == "string") {
            return obj;
        }
        else if (typeof obj.hashCode == FUNCTION) {
            // Check the hashCode method really has returned a string
            hashCode = obj.hashCode();
            return (typeof hashCode == "string") ? hashCode : hashObject(hashCode);
        }
        else if (typeof obj.toString == FUNCTION) {
            return obj.toString();
        }
        else {
            try {
                return String(obj);
            }
            catch (ex) {
                // For host objects (such as ActiveObjects in IE) that have no toString() method and throw an error when
                // passed to String()
                return Object.prototype.toString.call(obj);
            }
        }
    }

    function equals_fixedValueHasEquals(fixedValue, variableValue) {
        return fixedValue.equals(variableValue);
    }

    function equals_fixedValueNoEquals(fixedValue, variableValue) {
        return (typeof variableValue.equals == FUNCTION) ?
               variableValue.equals(fixedValue) : (fixedValue === variableValue);
    }

    function createKeyValCheck(kvStr) {
        return function (kv) {
            if (kv === null) {
                throw new Error("null is not a valid " + kvStr);
            }
            else if (typeof kv == "undefined") {
                throw new Error(kvStr + " must not be undefined");
            }
        };
    }

    var checkKey = createKeyValCheck("key"), checkValue = createKeyValCheck("value");

    function Bucket(hash, firstKey, firstValue, equalityFunction) {
        this[0] = hash;
        this.entries = [];
        this.addEntry(firstKey, firstValue);

        if (equalityFunction !== null) {
            this.getEqualityFunction = function () {
                return equalityFunction;
            };
        }
    }

    var EXISTENCE = 0, ENTRY = 1, ENTRY_INDEX_AND_VALUE = 2;

    function createBucketSearcher(mode) {
        return function (key) {
            var i = this.entries.length, entry, equals = this.getEqualityFunction(key);
            while (i--) {
                entry = this.entries[i];
                if (equals(key, entry[0])) {
                    switch (mode) {
                        case EXISTENCE:
                            return true;
                        case ENTRY:
                            return entry;
                        case ENTRY_INDEX_AND_VALUE:
                            return [ i, entry[1] ];
                    }
                }
            }
            return false;
        };
    }

    function createBucketLister(entryProperty) {
        return function (aggregatedArr) {
            var startIndex = aggregatedArr.length;
            for (var i = 0, len = this.entries.length; i < len; ++i) {
                aggregatedArr[startIndex + i] = this.entries[i][entryProperty];
            }
        };
    }

    Bucket.prototype = {
        getEqualityFunction: function (searchValue) {
            return (typeof searchValue.equals == FUNCTION) ? equals_fixedValueHasEquals : equals_fixedValueNoEquals;
        },

        getEntryForKey: createBucketSearcher(ENTRY),

        getEntryAndIndexForKey: createBucketSearcher(ENTRY_INDEX_AND_VALUE),

        removeEntryForKey: function (key) {
            var result = this.getEntryAndIndexForKey(key);
            if (result) {
                arrayRemoveAt(this.entries, result[0]);
                return result[1];
            }
            return null;
        },

        addEntry: function (key, value) {
            this.entries[this.entries.length] = [key, value];
        },

        keys: createBucketLister(0),

        values: createBucketLister(1),

        getEntries: function (entries) {
            var startIndex = entries.length;
            for (var i = 0, len = this.entries.length; i < len; ++i) {
                // Clone the entry stored in the bucket before adding to array
                entries[startIndex + i] = this.entries[i].slice(0);
            }
        },

        containsKey: createBucketSearcher(EXISTENCE),

        containsValue: function (value) {
            var i = this.entries.length;
            while (i--) {
                if (value === this.entries[i][1]) {
                    return true;
                }
            }
            return false;
        }
    };

    /*----------------------------------------------------------------------------------------------------------------*/

    // Supporting functions for searching hashtable buckets

    function searchBuckets(buckets, hash) {
        var i = buckets.length, bucket;
        while (i--) {
            bucket = buckets[i];
            if (hash === bucket[0]) {
                return i;
            }
        }
        return null;
    }

    function getBucketForHash(bucketsByHash, hash) {
        var bucket = bucketsByHash[hash];

        // Check that this is a genuine bucket and not something inherited from the bucketsByHash's prototype
        return ( bucket && (bucket instanceof Bucket) ) ? bucket : null;
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    var Hashtable = function (hashingFunctionParam, equalityFunctionParam) {
        var that = this;
        var buckets = [];
        var bucketsByHash = {};

        var hashingFunction = (typeof hashingFunctionParam == FUNCTION) ? hashingFunctionParam : hashObject;
        var equalityFunction = (typeof equalityFunctionParam == FUNCTION) ? equalityFunctionParam : null;

        this.put = function (key, value) {
            checkKey(key);
            checkValue(value);
            var hash = hashingFunction(key), bucket, bucketEntry, oldValue = null;

            // Check if a bucket exists for the bucket key
            bucket = getBucketForHash(bucketsByHash, hash);
            if (bucket) {
                // Check this bucket to see if it already contains this key
                bucketEntry = bucket.getEntryForKey(key);
                if (bucketEntry) {
                    // This bucket entry is the current mapping of key to value, so replace old value and we're done.
                    oldValue = bucketEntry[1];
                    bucketEntry[1] = value;
                }
                else {
                    // The bucket does not contain an entry for this key, so add one
                    bucket.addEntry(key, value);
                }
            }
            else {
                // No bucket exists for the key, so create one and put our key/value mapping in
                bucket = new Bucket(hash, key, value, equalityFunction);
                buckets[buckets.length] = bucket;
                bucketsByHash[hash] = bucket;
            }
            return oldValue;
        };

        this.get = function (key) {
            checkKey(key);

            var hash = hashingFunction(key);

            // Check if a bucket exists for the bucket key
            var bucket = getBucketForHash(bucketsByHash, hash);
            if (bucket) {
                // Check this bucket to see if it contains this key
                var bucketEntry = bucket.getEntryForKey(key);
                if (bucketEntry) {
                    // This bucket entry is the current mapping of key to value, so return the value.
                    return bucketEntry[1];
                }
            }
            return null;
        };

        this.containsKey = function (key) {
            checkKey(key);
            var bucketKey = hashingFunction(key);

            // Check if a bucket exists for the bucket key
            var bucket = getBucketForHash(bucketsByHash, bucketKey);

            return bucket ? bucket.containsKey(key) : false;
        };

        this.containsValue = function (value) {
            checkValue(value);
            var i = buckets.length;
            while (i--) {
                if (buckets[i].containsValue(value)) {
                    return true;
                }
            }
            return false;
        };

        this.clear = function () {
            buckets.length = 0;
            bucketsByHash = {};
        };

        this.isEmpty = function () {
            return !buckets.length;
        };

        var createBucketAggregator = function (bucketFuncName) {
            return function () {
                var aggregated = [], i = buckets.length;
                while (i--) {
                    buckets[i][bucketFuncName](aggregated);
                }
                return aggregated;
            };
        };

        this._keys = createBucketAggregator("keys");
        this._values = createBucketAggregator("values");
        this._entries = createBucketAggregator("getEntries");

        this.values = function () {
            var values = this._values();
            var i = values.length;
            var result = Kotlin.$new(Kotlin.ArrayList)();
            while (i--) {
                result.add(values[i]);
            }
            return result;
        };

        this.remove = function (key) {
            checkKey(key);

            var hash = hashingFunction(key), bucketIndex, oldValue = null;

            // Check if a bucket exists for the bucket key
            var bucket = getBucketForHash(bucketsByHash, hash);

            if (bucket) {
                // Remove entry from this bucket for this key
                oldValue = bucket.removeEntryForKey(key);
                if (oldValue !== null) {
                    // Entry was removed, so check if bucket is empty
                    if (!bucket.entries.length) {
                        // Bucket is empty, so remove it from the bucket collections
                        bucketIndex = searchBuckets(buckets, hash);
                        arrayRemoveAt(buckets, bucketIndex);
                        delete bucketsByHash[hash];
                    }
                }
            }
            return oldValue;
        };

        this.size = function () {
            var total = 0, i = buckets.length;
            while (i--) {
                total += buckets[i].entries.length;
            }
            return total;
        };

        this.each = function (callback) {
            var entries = that._entries(), i = entries.length, entry;
            while (i--) {
                entry = entries[i];
                callback(entry[0], entry[1]);
            }
        };


        this.putAll = function (hashtable, conflictCallback) {
            var entries = hashtable._entries();
            var entry, key, value, thisValue, i = entries.length;
            var hasConflictCallback = (typeof conflictCallback == FUNCTION);
            while (i--) {
                entry = entries[i];
                key = entry[0];
                value = entry[1];

                // Check for a conflict. The default behaviour is to overwrite the value for an existing key
                if (hasConflictCallback && (thisValue = that.get(key))) {
                    value = conflictCallback(key, thisValue, value);
                }
                that.put(key, value);
            }
        };

        this.clone = function () {
            var clone = new Hashtable(hashingFunctionParam, equalityFunctionParam);
            clone.putAll(that);
            return clone;
        };

        this.keySet = function () {
            var res = Kotlin.$new(Kotlin.ComplexHashSet)();
            var keys = this._keys();
            var i = keys.length;
            while (i--) {
                res.add(keys[i]);
            }
            return res;
        };
    };


    Kotlin.HashTable = Hashtable;
})();

Kotlin.Map = Kotlin.$createClass();

Kotlin.HashMap = Kotlin.$createClass(Kotlin.Map, {initialize: function () {
    Kotlin.HashTable.call(this);
}});

Kotlin.ComplexHashMap = Kotlin.HashMap;

(function () {
    var PrimitiveHashMapValuesIterator = Kotlin.$createClass(Kotlin.Iterator, {
        initialize: function (map, keys) {
            this.map = map;
            this.keys = keys;
            this.size = keys.length;
            this.index = 0;
        },
        next: function () {
            return this.map[this.keys[this.index++]];
        },
        hasNext: function () {
            return this.index < this.size;
        }
    });

    var PrimitiveHashMapValues = Kotlin.$createClass(Kotlin.Collection, {
        initialize: function (map) {
            this.map = map;
        },
        iterator: function () {
            return Kotlin.$new(PrimitiveHashMapValuesIterator)(this.map.map, Kotlin.keys(this.map.map));
        },
        isEmpty: function () {
            return this.map.$size === 0;
        },
        contains: function (o) {
            return this.map.containsValue(o);
        }
    });

    Kotlin.PrimitiveHashMap = Kotlin.$createClass(Kotlin.Map, {
        initialize: function () {
            this.$size = 0;
            this.map = {};
        },
        size: function () {
            return this.$size;
        },
        isEmpty: function () {
            return this.$size === 0;
        },
        containsKey: function (key) {
            return this.map[key] !== undefined;
        },
        containsValue: function (value) {
            var map = this.map;
            for (var key in map) {
                if (map.hasOwnProperty(key) && map[key] === value) {
                    return true;
                }
            }

            return false;
        },
        get: function (key) {
            return this.map[key];
        },
        put: function (key, value) {
            var prevValue = this.map[key];
            this.map[key] = value === undefined ? null : value;
            if (prevValue === undefined) {
                this.$size++;
            }
            return prevValue;
        },
        remove: function (key) {
            var prevValue = this.map[key];
            if (prevValue !== undefined) {
                delete this.map[key];
                this.$size--;
            }
            return prevValue;
        },
        clear: function () {
            this.$size = 0;
            this.map = {};
        },
        putAll: function (fromMap) {
            var map = fromMap.map;
            for (var key in map) {
                if (map.hasOwnProperty(key)) {
                    this.map[key] = map[key];
                    this.$size++;
                }
            }
        },
        keySet: function () {
            var result = Kotlin.$new(Kotlin.PrimitiveHashSet)();
            var map = this.map;
            for (var key in map) {
                if (map.hasOwnProperty(key)) {
                    result.add(key);
                }
            }

            return result;
        },
        values: function () {
            return Kotlin.$new(PrimitiveHashMapValues)(this);
        },
        toJSON: function () {
            return this.map;
        }
    });
}());

Kotlin.Set = Kotlin.$createClass(Kotlin.Collection);

Kotlin.PrimitiveHashSet = Kotlin.$createClass(Kotlin.AbstractCollection, {
    initialize: function () {
        this.$size = 0;
        this.map = {};
    },
    contains: function (key) {
        return this.map[key] === true;
    },
    add: function (element) {
        var prevElement = this.map[element];
        this.map[element] = true;
        if (prevElement === true) {
            return false;
        }
        else {
            this.$size++;
            return true;
        }
    },
    remove: function (element) {
        if (this.map[element] === true) {
            delete this.map[element];
            this.$size--;
            return true;
        }
        else {
            return false;
        }
    },
    clear: function () {
        this.$size = 0;
        this.map = {};
    },
    toArray: function () {
        return Kotlin.keys(this.map);
    }
});

(function () {
    function HashSet(hashingFunction, equalityFunction) {
        var hashTable = new Kotlin.HashTable(hashingFunction, equalityFunction);

        this.add = function (o) {
            hashTable.put(o, true);
        };

        this.addAll = function (arr) {
            var i = arr.length;
            while (i--) {
                hashTable.put(arr[i], true);
            }
        };

        this.values = function () {
            return hashTable._keys();
        };

        this.iterator = function () {
            return Kotlin.arrayIterator(this.values());
        };

        this.remove = function (o) {
            return hashTable.remove(o) ? o : null;
        };

        this.contains = function (o) {
            return hashTable.containsKey(o);
        };

        this.clear = function () {
            hashTable.clear();
        };

        this.size = function () {
            return hashTable.size();
        };

        this.isEmpty = function () {
            return hashTable.isEmpty();
        };

        this.clone = function () {
            var h = new HashSet(hashingFunction, equalityFunction);
            h.addAll(hashTable.keys());
            return h;
        };

        this.equals = function (o) {
            if (o === null || o === undefined) return false;
            if (this.size() === o.size()) {
                var iter1 = this.iterator();
                var iter2 = o.iterator();
                while (true) {
                    var hn1 = iter1.hasNext();
                    var hn2 = iter2.hasNext();
                    if (hn1 != hn2) return false;
                    if (!hn2)
                        return true;
                    else {
                        var o1 = iter1.next();
                        var o2 = iter2.next();
                        if (!Kotlin.equals(o1, o2)) return false;
                    }
                }
            }
            return false;
        };

        this.toString = function() {
            var builder = "[";
            var iter = this.iterator();
            var first = true;
            while (iter.hasNext()) {
                if (first)
                    first = false;
                else
                    builder += ", ";
                builder += iter.next();
            }
            builder += "]";
            return builder;
        };

        this.intersection = function (hashSet) {
            var intersection = new HashSet(hashingFunction, equalityFunction);
            var values = hashSet.values(), i = values.length, val;
            while (i--) {
                val = values[i];
                if (hashTable.containsKey(val)) {
                    intersection.add(val);
                }
            }
            return intersection;
        };

        this.union = function (hashSet) {
            var union = this.clone();
            var values = hashSet.values(), i = values.length, val;
            while (i--) {
                val = values[i];
                if (!hashTable.containsKey(val)) {
                    union.add(val);
                }
            }
            return union;
        };

        this.isSubsetOf = function (hashSet) {
            var values = hashTable.keys(), i = values.length;
            while (i--) {
                if (!hashSet.contains(values[i])) {
                    return false;
                }
            }
            return true;
        };
    }

    Kotlin.HashSet = Kotlin.$createClass(Kotlin.Set, {initialize: function () {
        HashSet.call(this);
    }});

    Kotlin.ComplexHashSet = Kotlin.HashSet;
}());
(function () {
  
  var classes = function () {
    var ci = Kotlin.createTrait(null)
    , c0 = Kotlin.createTrait(ci)
    , cl = Kotlin.createTrait(ci)
    , c13 = Kotlin.createTrait([ci, cl])
    , c1 = Kotlin.createTrait([ci, cl, c13])
    , c15 = Kotlin.createTrait([ci, cl])
    , c11 = Kotlin.createTrait([ci, c15])
    , c2 = Kotlin.createTrait([ci, c11])
    , cn = Kotlin.createTrait([ci, c15])
    , c3 = Kotlin.createTrait([ci, cn])
    , c4 = Kotlin.createTrait(null)
    , c5 = Kotlin.createTrait(null)
    , c6 = Kotlin.createClass(c4, function () {
      Object.defineProperty(this, 'LOADER_XMI_LOCAL_NAME', {value: 'type'});
      Object.defineProperty(this, 'LOADER_XMI_XSI', {value: 'xsi'});
      Object.defineProperty(this, 'factory', {value: null, writable: true});
      Object.defineProperty(this, 'attributesHashmap', {value: Kotlin.PrimitiveHashMap(0)});
      Object.defineProperty(this, 'referencesHashmap', {value: Kotlin.PrimitiveHashMap(0)});
      Object.defineProperty(this, 'attributeVisitor', {value: _.org.kevoree.modeling.api.xmi.XMIModelLoader.f1(this)});
      Object.defineProperty(this, 'referencesVisitor', {value: _.org.kevoree.modeling.api.xmi.XMIModelLoader.f3(this)});
    }, /** @lends _.org.kevoree.modeling.api.xmi.XMIModelLoader.prototype */ {
      unescapeXml: {value: function (src) {
        var builder = null;
        var i = 0;
        while (i < src.length) {
          var c = src.charAt(i);
          if (c === '&') {
            if (builder == null) {
              builder = _.java.lang.StringBuilder();
              (builder != null ? builder : Kotlin.throwNPE()).append(src.substring(0, i));
            }
            if (src.charAt(i + 1) === 'a') {
              if (src.charAt(i + 2) === 'm') {
                builder != null ? builder.append('&') : null;
                i = i + 5;
              }
               else if (src.charAt(i + 2) === 'p') {
                builder != null ? builder.append("'") : null;
                i = i + 6;
              }
               else {
                Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1) + src.charAt(i + 2));
              }
            }
             else if (src.charAt(i + 1) === 'q') {
              builder != null ? builder.append('"') : null;
              i = i + 6;
            }
             else if (src.charAt(i + 1) === 'l') {
              builder != null ? builder.append('<') : null;
              i = i + 4;
            }
             else if (src.charAt(i + 1) === 'g') {
              builder != null ? builder.append('>') : null;
              i = i + 4;
            }
             else {
              Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1));
            }
          }
           else {
            if (builder != null) {
              builder != null ? builder.append_0(c) : null;
            }
            i++;
          }
        }
        if (builder != null) {
          return Kotlin.toString(builder);
        }
         else {
          return src;
        }
      }},
      loadModelFromString: {value: function (str) {
        var reader = _.org.kevoree.modeling.api.xmi.XmlParser(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(str));
        if (reader.hasNext()) {
          return this.deserialize(reader);
        }
         else {
          Kotlin.println('Loader::Noting in the String !');
          return null;
        }
      }, writable: true},
      loadModelFromStream: {value: function (inputStream) {
        var reader = _.org.kevoree.modeling.api.xmi.XmlParser(inputStream);
        if (reader.hasNext()) {
          return this.deserialize(reader);
        }
         else {
          Kotlin.println('Loader::Noting in the file !');
          return null;
        }
      }, writable: true},
      loadObject: {value: function (ctx, xmiAddress, objectType) {
        var tmp$0, tmp$12, tmp$13, tmp$14, tmp$15, tmp$16, tmp$17, tmp$18;
        var elementTagName = ((tmp$0 = ctx.xmiReader) != null ? tmp$0 : Kotlin.throwNPE()).getLocalName();
        var modelElem;
        if (objectType != null) {
          var tmp$1;
          modelElem = (tmp$1 = this.factory) != null ? tmp$1.create(objectType) : null;
          if (modelElem == null) {
            var xsiType = null;
            var tmp$2, tmp$3, tmp$4, tmp$5, tmp$6;
            {
              tmp$3 = Kotlin.NumberRange(0, ((tmp$2 = ctx.xmiReader) != null ? tmp$2 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$4 = tmp$3.get_start(), tmp$5 = tmp$3.get_end(), tmp$6 = tmp$3.get_increment();
              for (var i = tmp$4; i <= tmp$5; i += tmp$6) {
                var tmp$7, tmp$8;
                var localName = ((tmp$7 = ctx.xmiReader) != null ? tmp$7 : Kotlin.throwNPE()).getAttributeLocalName(i);
                var xsi = ((tmp$8 = ctx.xmiReader) != null ? tmp$8 : Kotlin.throwNPE()).getAttributePrefix(i);
                if (Kotlin.equals(localName, this.LOADER_XMI_LOCAL_NAME) && Kotlin.equals(xsi, this.LOADER_XMI_XSI)) {
                  var tmp$9;
                  xsiType = ((tmp$9 = ctx.xmiReader) != null ? tmp$9 : Kotlin.throwNPE()).getAttributeValue(i);
                  break;
                }
              }
            }
            if (xsiType != null) {
              var tmp$10;
              modelElem = (tmp$10 = this.factory) != null ? tmp$10.create((xsiType != null ? xsiType : Kotlin.throwNPE()).substring((xsiType != null ? xsiType : Kotlin.throwNPE()).lastIndexOf(':') + 1, (xsiType != null ? xsiType : Kotlin.throwNPE()).length)) : null;
            }
          }
        }
         else {
          var tmp$11;
          modelElem = (tmp$11 = this.factory) != null ? tmp$11.create(elementTagName != null ? elementTagName : Kotlin.throwNPE()) : null;
        }
        if (modelElem == null) {
          Kotlin.println('Could not create an object for local name ' + elementTagName);
        }
        ctx.map.put(xmiAddress, modelElem != null ? modelElem : Kotlin.throwNPE());
        if (!this.attributesHashmap.containsKey((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) {
          modelElem != null ? modelElem.visitAttributes(this.attributeVisitor) : null;
        }
        var elemAttributesMap = (tmp$12 = this.attributesHashmap.get((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) != null ? tmp$12 : Kotlin.throwNPE();
        if (!this.referencesHashmap.containsKey((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) {
          modelElem != null ? modelElem.visit(this.referencesVisitor, false, true, false) : null;
        }
        var elemReferencesMap = (tmp$13 = this.referencesHashmap.get((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) != null ? tmp$13 : Kotlin.throwNPE();
        {
          tmp$15 = Kotlin.NumberRange(0, ((tmp$14 = ctx.xmiReader) != null ? tmp$14 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$16 = tmp$15.get_start(), tmp$17 = tmp$15.get_end(), tmp$18 = tmp$15.get_increment();
          for (var i_0 = tmp$16; i_0 <= tmp$17; i_0 += tmp$18) {
            var tmp$19;
            var prefix = ((tmp$19 = ctx.xmiReader) != null ? tmp$19 : Kotlin.throwNPE()).getAttributePrefix(i_0);
            if (prefix == null || Kotlin.equals(prefix, '')) {
              var tmp$20, tmp$21;
              var attrName = ((tmp$20 = ctx.xmiReader) != null ? tmp$20 : Kotlin.throwNPE()).getAttributeLocalName(i_0);
              var valueAtt = ((tmp$21 = ctx.xmiReader) != null ? tmp$21 : Kotlin.throwNPE()).getAttributeValue(i_0);
              if (valueAtt != null) {
                if (elemAttributesMap.containsKey(attrName)) {
                  modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, attrName != null ? attrName : Kotlin.throwNPE(), this.unescapeXml(valueAtt), false, false) : null;
                }
                 else {
                  var tmp$22, tmp$23, tmp$24;
                  {
                    tmp$22 = Kotlin.splitString(valueAtt, ' '), tmp$23 = tmp$22.length;
                    for (var tmp$24 = 0; tmp$24 !== tmp$23; ++tmp$24) {
                      var xmiRef = tmp$22[tmp$24];
                      {
                        var tmp$25, tmp$26;
                        if (xmiRef.startsWith('#')) {
                          tmp$25 = xmiRef.substring(1);
                        }
                         else {
                          tmp$25 = xmiRef;
                        }
                        var adjustedRef = tmp$25;
                        if (adjustedRef.startsWith('//')) {
                          tmp$26 = '/0' + adjustedRef.substring(1);
                        }
                         else {
                          tmp$26 = adjustedRef;
                        }
                        adjustedRef = tmp$26;
                        adjustedRef = adjustedRef.replace('.0', '');
                        var ref = ctx.map.get(adjustedRef);
                        if (ref != null) {
                          modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, attrName != null ? attrName : Kotlin.throwNPE(), ref, true, false) : null;
                        }
                         else {
                          ctx.resolvers.add(_.org.kevoree.modeling.api.xmi.XMIResolveCommand(ctx, modelElem != null ? modelElem : Kotlin.throwNPE(), _.org.kevoree.modeling.api.util.ActionType.ADD, attrName != null ? attrName : Kotlin.throwNPE(), adjustedRef));
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        var done = false;
        while (!done) {
          var tmp$27;
          var tmp$28 = ((tmp$27 = ctx.xmiReader) != null ? tmp$27 : Kotlin.throwNPE()).next();
          if (tmp$28 === _.org.kevoree.modeling.api.xmi.Token.START_TAG) {
            var tmp$29, tmp$31;
            var subElemName = ((tmp$29 = ctx.xmiReader) != null ? tmp$29 : Kotlin.throwNPE()).getLocalName();
            var i_1 = ctx.elementsCount.get(xmiAddress + '/@' + subElemName) !== null ? ctx.elementsCount.get(xmiAddress + '/@' + subElemName) : 0;
            var tmp$30 = xmiAddress + '/@' + subElemName;
            if (i_1 !== 0) {
              tmp$31 = '.' + i_1;
            }
             else {
              tmp$31 = '';
            }
            var subElementId = tmp$30 + tmp$31;
            var containedElement = this.loadObject(ctx, subElementId, elemReferencesMap.get(subElemName));
            modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, subElemName != null ? subElemName : Kotlin.throwNPE(), containedElement, true, false) : null;
            ctx.elementsCount.put(xmiAddress + '/@' + subElemName, i_1 + 1);
          }
           else if (tmp$28 === _.org.kevoree.modeling.api.xmi.Token.END_TAG) {
            var tmp$32;
            if (Kotlin.equals(((tmp$32 = ctx.xmiReader) != null ? tmp$32 : Kotlin.throwNPE()).getLocalName(), elementTagName)) {
              done = true;
            }
          }
           else {
          }
        }
        return modelElem != null ? modelElem : Kotlin.throwNPE();
      }},
      deserialize: {value: function (reader) {
        var context = _.org.kevoree.modeling.api.xmi.LoadingContext();
        context.xmiReader = reader;
        while (reader.hasNext()) {
          var nextTag = reader.next();
          if (nextTag === _.org.kevoree.modeling.api.xmi.Token.START_TAG) {
            var localName = reader.getLocalName();
            if (localName != null) {
              var loadedRootsSize = context.loadedRoots.size();
              context.loadedRoots.add(this.loadObject(context, '/' + loadedRootsSize, null));
            }
             else {
              Kotlin.println('Tried to read a tag with null tag_name.');
            }
          }
           else if (nextTag === _.org.kevoree.modeling.api.xmi.Token.END_TAG) {
            break;
          }
           else if (nextTag === _.org.kevoree.modeling.api.xmi.Token.END_DOCUMENT) {
            break;
          }
           else {
          }
        }
        {
          var tmp$0 = context.resolvers.iterator();
          while (tmp$0.hasNext()) {
            var res = tmp$0.next();
            res.run();
          }
        }
        return context.loadedRoots;
      }}
    }, /** @lends _.org.kevoree.modeling.api.xmi.XMIModelLoader */ {
      f0: {value: function () {
        return Kotlin.PrimitiveHashMap(0);
      }},
      f1: {value: function ($outer) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelAttributeVisitor, null, {
          visit: {value: function (value, name, parent) {
            _.kotlin.getOrPut($outer.attributesHashmap, parent.metaClassName(), _.org.kevoree.modeling.api.xmi.XMIModelLoader.f0).put(name, true);
          }, writable: true, enumerable: true}
        });
      }},
      f2: {value: function () {
        return Kotlin.PrimitiveHashMap(0);
      }},
      f3: {value: function ($outer) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
          Object.defineProperty(this, 'refMap', {value: null, writable: true, enumerable: true});
        }, {
          beginVisitElem: {value: function (elem) {
            this.refMap = _.kotlin.getOrPut($outer.referencesHashmap, elem.metaClassName(), _.org.kevoree.modeling.api.xmi.XMIModelLoader.f2);
          }, writable: true, enumerable: true},
          endVisitElem: {value: function (elem) {
            this.refMap = null;
          }, writable: true, enumerable: true},
          beginVisitRef: {value: function (refName, refType) {
            var tmp$0;
            ((tmp$0 = this.refMap) != null ? tmp$0 : Kotlin.throwNPE()).put(refName, refType);
          }, writable: true, enumerable: true},
          visit: {value: function (elem, refNameInParent, parent) {
          }, writable: true, enumerable: true}
        });
      }}
    })
    , ca = Kotlin.createTrait(null)
    , c7 = Kotlin.createClass(ca, null, /** @lends _.org.kevoree.modeling.api.xmi.XMIModelSerializer.prototype */ {
      serialize: {value: function (oMS) {
        var oo = _.java.io.ByteArrayOutputStream();
        this.serialize_0(oMS, oo);
        oo.flush();
        return oo.toString();
      }, writable: true},
      serialize_0: {value: function (oMS, ostream) {
        var wt = _.java.io.PrintStream(_.java.io.BufferedOutputStream(ostream), false);
        var addressTable = Kotlin.ComplexHashMap(0);
        var packageList = Kotlin.ArrayList(0);
        addressTable.put(oMS, '/');
        var elementsCount = Kotlin.PrimitiveHashMap(0);
        var addressBuilderVisitor = _.org.kevoree.modeling.api.xmi.ModelAddressVisitor(addressTable, elementsCount, packageList);
        oMS.visit(addressBuilderVisitor, true, true, false);
        var masterVisitor = _.org.kevoree.modeling.api.xmi.ModelSerializationVisitor(wt, addressTable, elementsCount);
        wt.println('<?xml version="1.0" encoding="UTF-8"?>');
        wt.print('<' + this.formatMetaClassName(oMS.metaClassName()).replace('.', '_'));
        wt.print(' xmlns:xsi="http://wwww.w3.org/2001/XMLSchema-instance"');
        wt.print(' xmi:version="2.0"');
        wt.print(' xmlns:xmi="http://www.omg.org/XMI"');
        var index = 0;
        while (index < _.kotlin.get_size(packageList)) {
          wt.print(' xmlns:' + packageList.get(index).replace('.', '_') + '="http://' + packageList.get(index) + '"');
          index++;
        }
        oMS.visitAttributes(_.org.kevoree.modeling.api.xmi.AttributesVisitor(wt));
        oMS.visit(_.org.kevoree.modeling.api.xmi.ReferencesVisitor(wt, addressTable, elementsCount), false, false, true);
        wt.println('>');
        oMS.visit(masterVisitor, false, true, false);
        wt.println('<\/' + this.formatMetaClassName(oMS.metaClassName()).replace('.', '_') + '>');
        wt.flush();
      }, writable: true},
      formatMetaClassName: {value: function (metaClassName) {
        var lastPoint = _.js.lastIndexOf_0(metaClassName, '.');
        var pack = metaClassName.substring(0, lastPoint);
        var cls = metaClassName.substring(lastPoint + 1);
        return pack + ':' + cls;
      }}
    })
    , c8 = Kotlin.createTrait(null, /** @lends _.org.kevoree.modeling.api.ModelCloner.prototype */ {
      clone: {value: function (o) {
        return this.clone_0(o, false);
      }, writable: true},
      clone_0: {value: function (o, readOnly) {
        return this.clone_1(o, readOnly, false);
      }, writable: true},
      cloneMutableOnly: {value: function (o, readOnly) {
        return this.clone_1(o, readOnly, true);
      }, writable: true},
      cloneModelElem: {value: function (src) {
        var tmp$0;
        var clonedSrc = (tmp$0 = this.mainFactory.create(src.metaClassName())) != null ? tmp$0 : Kotlin.throwNPE();
        var attributesCloner = _.org.kevoree.modeling.api.ModelCloner.f0(clonedSrc);
        src.visitAttributes(attributesCloner);
        return clonedSrc;
      }, writable: true},
      resolveModelElem: {value: function (src, target, context, mutableOnly) {
        var refResolver = _.org.kevoree.modeling.api.ModelCloner.f1(mutableOnly, target, context);
        src.visit(refResolver, false, true, true);
      }, writable: true},
      clone_1: {value: function (o, readOnly, mutableOnly) {
        var context = this.createContext();
        var clonedObject = this.cloneModelElem(o);
        context.put(o, clonedObject);
        var cloneGraphVisitor = _.org.kevoree.modeling.api.ModelCloner.f2(this, mutableOnly, context);
        o.visit(cloneGraphVisitor, true, true, false);
        var resolveGraphVisitor = _.org.kevoree.modeling.api.ModelCloner.f3(this, mutableOnly, context, readOnly);
        o.visit(resolveGraphVisitor, true, true, false);
        this.resolveModelElem(o, clonedObject, context, mutableOnly);
        if (readOnly) {
          clonedObject.setInternalReadOnly();
        }
        return clonedObject != null ? clonedObject : Kotlin.throwNPE();
      }, writable: true}
    }, /** @lends _.org.kevoree.modeling.api.ModelCloner */ {
      f0: {value: function (clonedSrc) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelAttributeVisitor, null, {
          visit: {value: function (value, name, parent) {
            if (value != null) {
              clonedSrc.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, name, value, false, false);
            }
          }, writable: true, enumerable: true}
        });
      }},
      f1: {value: function (mutableOnly, target, context) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            if (mutableOnly && elem.isRecursiveReadOnly()) {
              target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, refNameInParent, elem, false, false);
            }
             else {
              target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, refNameInParent, context.get(elem), false, false);
            }
          }, writable: true, enumerable: true}
        });
      }},
      f2: {value: function ($outer, mutableOnly, context) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            if (mutableOnly && elem.isRecursiveReadOnly()) {
              this.noChildrenVisit();
            }
             else {
              context.put(elem, $outer.cloneModelElem(elem));
            }
          }, writable: true, enumerable: true}
        });
      }},
      f3: {value: function ($outer, mutableOnly, context, readOnly) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            if (mutableOnly && elem.isRecursiveReadOnly()) {
            }
             else {
              var tmp$0;
              var clonedObj = (tmp$0 = context.get(elem)) != null ? tmp$0 : Kotlin.throwNPE();
              $outer.resolveModelElem(elem, clonedObj, context, mutableOnly);
              if (readOnly) {
                clonedObj.setInternalReadOnly();
              }
            }
          }, writable: true, enumerable: true}
        });
      }}
    })
    , c9 = Kotlin.createTrait(null, /** @lends _.org.kevoree.modeling.api.compare.ModelCompare.prototype */ {
      diff: {value: function (origin, target) {
        return this.createSequence().populate(this.internal_diff(origin, target, false, false));
      }, writable: true},
      merge: {value: function (origin, target) {
        return this.createSequence().populate(this.internal_diff(origin, target, false, true));
      }, writable: true},
      inter: {value: function (origin, target) {
        return this.createSequence().populate(this.internal_diff(origin, target, true, false));
      }, writable: true},
      internal_diff: {value: function (origin, target, inter, merge) {
        var traces = Kotlin.ArrayList(0);
        var tracesRef = Kotlin.ArrayList(0);
        var objectsMap = Kotlin.PrimitiveHashMap(0);
        traces.addAll(origin.createTraces(target, inter, merge, false, true));
        tracesRef.addAll(origin.createTraces(target, inter, merge, true, false));
        var visitor = _.org.kevoree.modeling.api.compare.ModelCompare.f0(objectsMap);
        origin.visit(visitor, true, true, false);
        var visitor2 = _.org.kevoree.modeling.api.compare.ModelCompare.f1(objectsMap, inter, traces, merge, tracesRef);
        target.visit(visitor2, true, true, false);
        if (!inter) {
          if (!merge) {
            {
              var tmp$0 = objectsMap.values().iterator();
              while (tmp$0.hasNext()) {
                var diffChild = tmp$0.next();
                var tmp$3, tmp$5, tmp$6;
                if (diffChild.eContainer() != null) {
                  var tmp$1, tmp$2;
                  tmp$3 = (tmp$2 = ((tmp$1 = diffChild.eContainer()) != null ? tmp$1 : Kotlin.throwNPE()).path()) != null ? tmp$2 : Kotlin.throwNPE();
                }
                 else {
                  tmp$3 = 'null';
                }
                var src = tmp$3;
                if (diffChild.getRefInParent() != null) {
                  var tmp$4;
                  tmp$5 = (tmp$4 = diffChild.getRefInParent()) != null ? tmp$4 : Kotlin.throwNPE();
                }
                 else {
                  tmp$5 = 'null';
                }
                var refNameInParent = tmp$5;
                traces.add(_.org.kevoree.modeling.api.trace.ModelRemoveTrace(src, refNameInParent, (tmp$6 = (diffChild != null ? diffChild : Kotlin.throwNPE()).path()) != null ? tmp$6 : Kotlin.throwNPE()));
              }
            }
          }
        }
        traces.addAll(tracesRef);
        return traces;
      }, writable: true}
    }, /** @lends _.org.kevoree.modeling.api.compare.ModelCompare */ {
      f0: {value: function (objectsMap) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            var childPath = elem.path();
            if (childPath != null) {
              objectsMap.put(childPath, elem);
            }
             else {
              throw new Error('Null child path ' + elem);
            }
          }, writable: true, enumerable: true}
        });
      }},
      f1: {value: function (objectsMap, inter, traces, merge, tracesRef) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            var childPath = elem.path();
            if (childPath != null) {
              if (objectsMap.containsKey(childPath)) {
                if (inter) {
                  var tmp$0;
                  traces.add(_.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$0 = parent.path()) != null ? tmp$0 : Kotlin.throwNPE(), refNameInParent, elem.path(), elem.metaClassName()));
                }
                var tmp$1, tmp$2;
                traces.addAll(((tmp$1 = objectsMap.get(childPath)) != null ? tmp$1 : Kotlin.throwNPE()).createTraces(elem, inter, merge, false, true));
                tracesRef.addAll(((tmp$2 = objectsMap.get(childPath)) != null ? tmp$2 : Kotlin.throwNPE()).createTraces(elem, inter, merge, true, false));
                objectsMap.remove(childPath);
              }
               else {
                if (!inter) {
                  var tmp$3;
                  traces.add(_.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$3 = parent.path()) != null ? tmp$3 : Kotlin.throwNPE(), refNameInParent, elem.path(), elem.metaClassName()));
                  traces.addAll(elem.createTraces(elem, true, merge, false, true));
                  tracesRef.addAll(elem.createTraces(elem, true, merge, true, false));
                }
              }
            }
             else {
              throw new Error('Null child path ' + elem);
            }
          }, writable: true, enumerable: true}
        });
      }}
    })
    , cb = Kotlin.createClass(c4, function () {
      Object.defineProperty(this, 'factory', {value: null, writable: true});
    }, /** @lends _.org.kevoree.modeling.api.json.JSONModelLoader.prototype */ {
      loadModelFromString: {value: function (str) {
        return this.deserialize(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(str));
      }, writable: true},
      loadModelFromStream: {value: function (inputStream) {
        return this.deserialize(inputStream);
      }, writable: true},
      deserialize: {value: function (instream) {
        var resolverCommands = Kotlin.ArrayList(0);
        var roots = Kotlin.ArrayList(0);
        var lexer = _.org.kevoree.modeling.api.json.Lexer(instream);
        var currentToken = lexer.nextToken();
        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
          this.loadObject(lexer, null, null, roots, resolverCommands);
        }
         else {
          throw new Error('Bad Format / {\xA0expected');
        }
        {
          var tmp$0 = resolverCommands.iterator();
          while (tmp$0.hasNext()) {
            var resol = tmp$0.next();
            resol.run();
          }
        }
        return roots;
      }},
      loadObject: {value: function (lexer, nameInParent, parent, roots, commands) {
        var currentToken = lexer.nextToken();
        var currentObject = null;
        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
          if (Kotlin.equals(currentToken.value, 'eClass')) {
            lexer.nextToken();
            currentToken = lexer.nextToken();
            var tmp$0, tmp$1;
            var name = (tmp$0 = Kotlin.toString(currentToken.value)) != null ? tmp$0 : Kotlin.throwNPE();
            currentObject = (tmp$1 = this.factory) != null ? tmp$1.create(name) : null;
            if (parent == null) {
              roots.add(currentObject != null ? currentObject : Kotlin.throwNPE());
            }
            var currentNameAttOrRef = null;
            var refModel = false;
            currentToken = lexer.nextToken();
            while (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.EOF) {
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                this.loadObject(lexer, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), currentObject, roots, commands);
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.COMMA) {
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                if (currentNameAttOrRef == null) {
                  currentNameAttOrRef = Kotlin.toString(currentToken.value);
                }
                 else {
                  if (refModel) {
                    var tmp$2;
                    commands.add(_.org.kevoree.modeling.api.json.ResolveCommand(roots, Kotlin.toString((tmp$2 = currentToken.value) != null ? tmp$2 : Kotlin.throwNPE()), currentObject != null ? currentObject : Kotlin.throwNPE(), currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE()));
                  }
                   else {
                    (currentObject != null ? currentObject : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), this.unescapeJSON(Kotlin.toString(currentToken.value)), false, false);
                    currentNameAttOrRef = null;
                  }
                }
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET) {
                currentToken = lexer.nextToken();
                if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                  this.loadObject(lexer, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), currentObject, roots, commands);
                }
                 else {
                  refModel = true;
                  if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                    var tmp$3;
                    commands.add(_.org.kevoree.modeling.api.json.ResolveCommand(roots, Kotlin.toString((tmp$3 = currentToken.value) != null ? tmp$3 : Kotlin.throwNPE()), currentObject != null ? currentObject : Kotlin.throwNPE(), currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE()));
                  }
                }
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET) {
                currentNameAttOrRef = null;
                refModel = false;
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE) {
                if (parent != null) {
                  parent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, nameInParent != null ? nameInParent : Kotlin.throwNPE(), currentObject, false, false);
                }
                return;
              }
              currentToken = lexer.nextToken();
            }
          }
           else {
            throw new Error('Bad Format / eClass att must be first');
          }
        }
         else {
          throw new Error('Bad Format');
        }
      }},
      unescapeJSON: {value: function (src) {
        var builder = null;
        var i = 0;
        while (i < src.length) {
          var c = src.charAt(i);
          if (c === '&') {
            if (builder == null) {
              builder = src.substring(0, i);
            }
            if (src.charAt(i + 1) === 'a') {
              builder = (builder != null ? builder : Kotlin.throwNPE()) + "'";
              i = i + 6;
            }
             else if (src.charAt(i + 1) === 'q') {
              builder = (builder != null ? builder : Kotlin.throwNPE()) + '"';
              i = i + 6;
            }
             else {
              Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1));
            }
          }
           else {
            if (builder != null) {
              builder = (builder != null ? builder : Kotlin.throwNPE()) + c;
            }
            i++;
          }
        }
        if (builder != null) {
          return builder != null ? builder : Kotlin.throwNPE();
        }
         else {
          return src;
        }
      }}
    })
    , cc = Kotlin.createClass(ca, null, /** @lends _.org.kevoree.modeling.api.json.JSONModelSerializer.prototype */ {
      serialize: {value: function (model) {
        var outstream = _.java.io.ByteArrayOutputStream();
        this.serialize_0(model, outstream);
        outstream.close();
        return outstream.toString();
      }, writable: true},
      serialize_0: {value: function (model, raw) {
        var out = _.java.io.PrintStream(_.java.io.BufferedOutputStream(raw), false);
        var internalReferenceVisitor = _.org.kevoree.modeling.api.json.ModelReferenceVisitor(out);
        var masterVisitor = _.org.kevoree.modeling.api.json.JSONModelSerializer.f0(this, out, internalReferenceVisitor);
        model.visit(masterVisitor, true, true, false);
        out.flush();
      }, writable: true},
      printAttName: {value: function (elem, out) {
        out.print('\n{"eClass":"' + elem.metaClassName() + '"');
        var attributeVisitor = _.org.kevoree.modeling.api.json.JSONModelSerializer.f1(this, out);
        elem.visitAttributes(attributeVisitor);
      }},
      escapeJson: {value: function (ostream, chain) {
        if (chain == null) {
          return;
        }
        var i = 0;
        while (i < chain.length) {
          var c = chain.charAt(i);
          if (c === '"') {
            ostream.print('&quot;');
          }
           else if (c === "'") {
            ostream.print('&apos;');
          }
           else {
            ostream.print_0(c);
          }
          i = i + 1;
        }
      }}
    }, /** @lends _.org.kevoree.modeling.api.json.JSONModelSerializer */ {
      f0: {value: function ($outer, out, internalReferenceVisitor) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
          Object.defineProperty(this, 'isFirstInRef', {value: true, writable: true, enumerable: true});
        }, {
          beginVisitElem: {value: function (elem) {
            if (!this.isFirstInRef) {
              out.print(',');
              this.isFirstInRef = false;
            }
            $outer.printAttName(elem, out);
            var tmp$0;
            (tmp$0 = internalReferenceVisitor.alreadyVisited) != null ? tmp$0.clear() : null;
            elem.visit(internalReferenceVisitor, false, false, true);
          }, writable: true, enumerable: true},
          endVisitElem: {value: function (elem) {
            out.println('}');
            this.isFirstInRef = false;
          }, writable: true, enumerable: true},
          beginVisitRef: {value: function (refName, refType) {
            out.print(',"' + refName + '":[');
            this.isFirstInRef = true;
          }, writable: true, enumerable: true},
          endVisitRef: {value: function (refName) {
            out.print(']');
            this.isFirstInRef = false;
          }, writable: true, enumerable: true},
          visit: {value: function (elem, refNameInParent, parent) {
          }, writable: true, enumerable: true}
        });
      }},
      f1: {value: function ($outer, out) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelAttributeVisitor, null, {
          visit: {value: function (value, name, parent) {
            if (value != null) {
              out.print(',"' + name + '":"');
              $outer.escapeJson(out, Kotlin.toString(value));
              out.print('"');
            }
          }, writable: true, enumerable: true}
        });
      }}
    })
    , cd = Kotlin.createTrait(null)
    , ce = Kotlin.createTrait(cd)
    , cf = Kotlin.createTrait(null)
    , cg = Kotlin.createTrait(null)
    , ch = Kotlin.createTrait(null, /** @lends _.org.kevoree.modeling.api.trace.TraceSequence.prototype */ {
      populate: {value: function (addtraces) {
        this.traces.addAll(addtraces);
        return this;
      }, writable: true},
      populateFromString: {value: function (addtracesTxt) {
        return this.populateFromStream(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(addtracesTxt));
      }, writable: true},
      populateFromStream: {value: function (inputStream) {
        var lexer = _.org.kevoree.modeling.api.json.Lexer(inputStream);
        var currentToken = lexer.nextToken();
        if (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET) {
          throw new Error('Bad Format : expect [');
        }
        currentToken = lexer.nextToken();
        var keys = Kotlin.PrimitiveHashMap(0);
        var previousName = null;
        while (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.EOF && currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET) {
          if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
            keys.clear();
          }
          if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
            if (previousName != null) {
              keys.put(previousName != null ? previousName : Kotlin.throwNPE(), Kotlin.toString(currentToken.value));
              previousName = null;
            }
             else {
              previousName = Kotlin.toString(currentToken.value);
            }
          }
          if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE) {
            var tmp$0;
            var tmp$1 = (tmp$0 = keys.get('traceType')) != null ? tmp$0 : Kotlin.throwNPE();
            if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.SET)) {
              var tmp$2, tmp$3;
              this.traces.add(_.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$2 = keys.get('src')) != null ? tmp$2 : Kotlin.throwNPE(), (tmp$3 = keys.get('refname')) != null ? tmp$3 : Kotlin.throwNPE(), keys.get('objpath'), keys.get('content'), keys.get('typename')));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.ADD)) {
              var tmp$4, tmp$5, tmp$6;
              this.traces.add(_.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$4 = keys.get('src')) != null ? tmp$4 : Kotlin.throwNPE(), (tmp$5 = keys.get('refname')) != null ? tmp$5 : Kotlin.throwNPE(), (tmp$6 = keys.get('previouspath')) != null ? tmp$6 : Kotlin.throwNPE(), keys.get('typename')));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.ADD_ALL)) {
              var tmp$7, tmp$8, tmp$9, tmp$10, tmp$11, tmp$12;
              this.traces.add(_.org.kevoree.modeling.api.trace.ModelAddAllTrace((tmp$7 = keys.get('src')) != null ? tmp$7 : Kotlin.throwNPE(), (tmp$8 = keys.get('refname')) != null ? tmp$8 : Kotlin.throwNPE(), (tmp$10 = (tmp$9 = keys.get('content')) != null ? Kotlin.splitString(tmp$9, ';') : null) != null ? _.kotlin.toList_2(tmp$10) : null, (tmp$12 = (tmp$11 = keys.get('typename')) != null ? Kotlin.splitString(tmp$11, ';') : null) != null ? _.kotlin.toList_2(tmp$12) : null));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.REMOVE)) {
              var tmp$13, tmp$14, tmp$15;
              this.traces.add(_.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$13 = keys.get('src')) != null ? tmp$13 : Kotlin.throwNPE(), (tmp$14 = keys.get('refname')) != null ? tmp$14 : Kotlin.throwNPE(), (tmp$15 = keys.get('objpath')) != null ? tmp$15 : Kotlin.throwNPE()));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL)) {
              var tmp$16, tmp$17;
              this.traces.add(_.org.kevoree.modeling.api.trace.ModelRemoveAllTrace((tmp$16 = keys.get('src')) != null ? tmp$16 : Kotlin.throwNPE(), (tmp$17 = keys.get('refname')) != null ? tmp$17 : Kotlin.throwNPE()));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX)) {
            }
             else {
              Kotlin.println('Trace lost !!!');
            }
          }
          currentToken = lexer.nextToken();
        }
        return this;
      }, writable: true},
      exportToString: {value: function () {
        var buffer = _.java.lang.StringBuilder();
        buffer.append('[');
        var isFirst = true;
        {
          var tmp$0 = this.traces.iterator();
          while (tmp$0.hasNext()) {
            var trace = tmp$0.next();
            if (!isFirst) {
              buffer.append(',');
            }
            buffer.append(trace.toString());
            isFirst = false;
          }
        }
        buffer.append(']');
        return buffer.toString();
      }, writable: true},
      applyOn: {value: function (target) {
        var tmp$0;
        var traceApplicator = _.org.kevoree.modeling.api.trace.ModelTraceApplicator(target, (tmp$0 = this.factory) != null ? tmp$0 : Kotlin.throwNPE());
        traceApplicator.applyTraceOnModel(this);
        return true;
      }, writable: true}
    })
    , cj = Kotlin.createClass(null, function () {
      Object.defineProperty(this, 'visitStopped', {value: false, writable: true});
      Object.defineProperty(this, 'visitChildren', {value: true, writable: true});
      Object.defineProperty(this, 'alreadyVisited', {value: null, writable: true});
    }, /** @lends _.org.kevoree.modeling.api.util.ModelVisitor.prototype */ {
      stopVisit: {value: function () {
        this.visitStopped = true;
      }},
      noChildrenVisit: {value: function () {
        this.visitChildren = true;
      }},
      beginVisitElem: {value: function (elem) {
      }, writable: true},
      endVisitElem: {value: function (elem) {
      }, writable: true},
      beginVisitRef: {value: function (refName, refType) {
      }, writable: true},
      endVisitRef: {value: function (refName) {
      }, writable: true}
    })
    , ck = Kotlin.createTrait(null)
    , cm = Kotlin.createTrait(ci)
    , co = Kotlin.createTrait(ci)
    , cp = Kotlin.createTrait([ci, cl])
    , cq = Kotlin.createTrait([ci, c11])
    , cr = Kotlin.createTrait([ci, cn])
    , cs = Kotlin.createTrait(ci)
    , ct = Kotlin.createTrait(ci)
    , cu = Kotlin.createTrait([ci, cl, c13])
    , cv = Kotlin.createTrait(ci, /** @lends _.org.kevoree.container.KMFContainerImpl.prototype */ {
      eContainer: {value: function () {
        return this.internal_eContainer;
      }, writable: true},
      setRecursiveReadOnly: {value: function () {
        if (Kotlin.equals(this.internal_recursive_readOnlyElem, true)) {
          return;
        }
        this.setInternalRecursiveReadOnly();
        var recVisitor = _.org.kevoree.container.KMFContainerImpl.f0();
        this.visit(recVisitor, true, true, true);
        this.setInternalReadOnly();
      }, writable: true},
      setInternalReadOnly: {value: function () {
        this.internal_readOnlyElem = true;
      }, writable: true},
      setInternalRecursiveReadOnly: {value: function () {
        this.internal_recursive_readOnlyElem = true;
      }, writable: true},
      getRefInParent: {value: function () {
        return this.internal_containmentRefName;
      }, writable: true},
      isReadOnly: {value: function () {
        return this.internal_readOnlyElem;
      }, writable: true},
      isRecursiveReadOnly: {value: function () {
        return this.internal_recursive_readOnlyElem;
      }, writable: true},
      setEContainer: {value: function (container, unsetCmd, refNameInParent) {
        this.path_cache = null;
        if (this.internal_readOnlyElem) {
          return;
        }
        var tempUnsetCmd = this.internal_unsetCmd;
        this.internal_unsetCmd = null;
        if (tempUnsetCmd != null) {
          tempUnsetCmd.run();
        }
        this.internal_eContainer = container;
        this.internal_unsetCmd = unsetCmd;
        this.internal_containmentRefName = refNameInParent;
      }, writable: true},
      selectByQuery: {value: function (query) {
        throw new Error('Not activated, please add selector option in KMF generation plugin');
      }, writable: true},
      fireModelEvent: {value: function (evt) {
        if (this.internal_modelElementListeners != null) {
          var tmp$0;
          {
            var tmp$1 = ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).iterator();
            while (tmp$1.hasNext()) {
              var lst = tmp$1.next();
              lst.elementChanged(evt);
            }
          }
        }
        this.fireModelEventOnTree(evt);
      }, writable: true},
      addModelElementListener: {value: function (lst) {
        if (this.internal_modelElementListeners == null) {
          this.internal_modelElementListeners = Kotlin.ArrayList(0);
        }
        var tmp$0;
        ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).add(lst);
      }, writable: true},
      removeModelElementListener: {value: function (lst) {
        if (this.internal_modelElementListeners != null) {
          var tmp$0, tmp$1;
          ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).remove(lst);
          if (((tmp$1 = this.internal_modelElementListeners) != null ? tmp$1 : Kotlin.throwNPE()).isEmpty()) {
            this.internal_modelElementListeners = null;
          }
        }
      }, writable: true},
      removeAllModelElementListeners: {value: function () {
        if (this.internal_modelElementListeners != null) {
          var tmp$0;
          ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).clear();
          this.internal_modelElementListeners = null;
        }
      }, writable: true},
      fireModelEventOnTree: {value: function (evt) {
        if (this.internal_modelTreeListeners != null) {
          var tmp$0;
          {
            var tmp$1 = ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).iterator();
            while (tmp$1.hasNext()) {
              var lst = tmp$1.next();
              lst.elementChanged(evt);
            }
          }
        }
        if (this.eContainer() != null) {
          var tmp$2;
          ((tmp$2 = this.eContainer()) != null ? tmp$2 : Kotlin.throwNPE()).fireModelEventOnTree(evt);
        }
      }, writable: true},
      addModelTreeListener: {value: function (lst) {
        if (this.internal_modelTreeListeners == null) {
          this.internal_modelTreeListeners = Kotlin.ArrayList(0);
        }
        var tmp$0;
        ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).add(lst);
      }, writable: true},
      removeModelTreeListener: {value: function (lst) {
        if (this.internal_modelTreeListeners != null) {
          var tmp$0, tmp$1;
          ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).remove(lst);
          if (((tmp$1 = this.internal_modelTreeListeners) != null ? tmp$1 : Kotlin.throwNPE()).isEmpty()) {
            this.internal_modelTreeListeners = null;
          }
        }
      }, writable: true},
      removeAllModelTreeListeners: {value: function () {
        if (this.internal_modelTreeListeners != null) {
          var tmp$0;
          ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).clear();
          this.internal_modelElementListeners = null;
        }
      }, writable: true},
      visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
      }, writable: true},
      visitAttributes: {value: function (visitor) {
      }, writable: true},
      internal_visit: {value: function (visitor, internalElem, recursive, containedReference, nonContainedReference, refName) {
        if (internalElem != null) {
          if (nonContainedReference && recursive) {
            var tmp$0, tmp$1, tmp$2;
            var elemPath = (tmp$0 = internalElem.path()) != null ? tmp$0 : Kotlin.throwNPE();
            if (visitor.alreadyVisited != null && ((tmp$1 = visitor.alreadyVisited) != null ? tmp$1 : Kotlin.throwNPE()).containsKey(elemPath)) {
              return;
            }
            if (visitor.alreadyVisited == null) {
              visitor.alreadyVisited = Kotlin.PrimitiveHashMap(0);
            }
            ((tmp$2 = visitor.alreadyVisited) != null ? tmp$2 : Kotlin.throwNPE()).put(elemPath, internalElem);
          }
          visitor.visit(internalElem, refName, this);
          if (!visitor.visitStopped) {
            if (recursive && visitor.visitChildren) {
              internalElem.visit(visitor, recursive, containedReference, nonContainedReference);
            }
            visitor.visitChildren = true;
          }
        }
      }, writable: true},
      path: {value: function () {
        if (this.path_cache != null) {
          return this.path_cache;
        }
        var container = this.eContainer();
        if (container != null) {
          var parentPath = container.path();
          if (parentPath == null) {
            return null;
          }
           else {
            var tmp$0;
            if (Kotlin.equals(parentPath, '')) {
              tmp$0 = '';
            }
             else {
              tmp$0 = parentPath + '/';
            }
            this.path_cache = tmp$0 + this.internal_containmentRefName + '[' + this.internalGetKey() + ']';
          }
        }
         else {
          this.path_cache = '';
        }
        return this.path_cache;
      }, writable: true},
      modelEquals: {value: function (similarObj) {
        if (similarObj == null) {
          return false;
        }
        if (Kotlin.equals(this, similarObj)) {
          return true;
        }
        if (!Kotlin.equals(similarObj.metaClassName(), this.metaClassName())) {
          return false;
        }
        var values = Kotlin.PrimitiveHashMap(0);
        var attVisitor = _.org.kevoree.container.KMFContainerImpl.f1(values);
        this.visitAttributes(attVisitor);
        similarObj.visitAttributes(attVisitor);
        if (!values.isEmpty()) {
          return false;
        }
        var payload = '';
        var refVisitor = _.org.kevoree.container.KMFContainerImpl.f2(values, payload);
        this.visit(refVisitor, false, false, true);
        similarObj.visit(refVisitor, false, false, true);
        if (!values.isEmpty()) {
          return false;
        }
        return true;
      }, writable: true},
      deepModelEquals: {value: function (similarObj) {
        if (!this.modelEquals(similarObj)) {
          return false;
        }
        var similarRoot = similarObj != null ? similarObj : Kotlin.throwNPE();
        while (similarRoot.eContainer() != null) {
          var tmp$0;
          similarRoot = (tmp$0 = similarRoot.eContainer()) != null ? tmp$0 : Kotlin.throwNPE();
        }
        var resultTest = {v: true};
        var finalRoot = similarRoot;
        var objVisitor = _.org.kevoree.container.KMFContainerImpl.f3(finalRoot, resultTest);
        this.visit(objVisitor, true, true, false);
        return resultTest.v;
      }, writable: true},
      findByPath: {value: function (query) {
        var firstSepIndex = _.js.indexOf(query, '[');
        var queryID = '';
        var extraReadChar = 2;
        var relationName = query.substring(0, _.js.indexOf(query, '['));
        if (_.js.indexOf(query, '{') === firstSepIndex + 1) {
          queryID = query.substring(_.js.indexOf(query, '{') + 1, _.js.indexOf(query, '}'));
          extraReadChar = extraReadChar + 2;
        }
         else {
          var indexFirstClose = _.js.indexOf(query, ']');
          while (indexFirstClose + 1 < query.length && query.charAt(indexFirstClose + 1) !== '/') {
            indexFirstClose = _.js.indexOf_0(query, ']', indexFirstClose + 1);
          }
          queryID = query.substring(_.js.indexOf(query, '[') + 1, indexFirstClose);
        }
        var subquery = query.substring(relationName.length + queryID.length + extraReadChar, query.length);
        if (_.js.indexOf(subquery, '/') !== -1) {
          subquery = subquery.substring(_.js.indexOf(subquery, '/') + 1, subquery.length);
        }
        var objFound = this.findByID(relationName, queryID);
        if (!Kotlin.equals(subquery, '') && objFound != null) {
          return objFound.findByPath(subquery);
        }
         else {
          return objFound;
        }
      }, writable: true},
      createTraces: {value: function (similarObj, isInter, isMerge, onlyReferences, onlyAttributes) {
        var traces = Kotlin.ArrayList(0);
        var values = Kotlin.PrimitiveHashMap(0);
        if (onlyAttributes) {
          var attVisitorFill = _.org.kevoree.container.KMFContainerImpl.f4(values);
          this.visitAttributes(attVisitorFill);
          var attVisitor = _.org.kevoree.container.KMFContainerImpl.f5(this, values, isInter, traces);
          if (similarObj != null) {
            similarObj.visitAttributes(attVisitor);
          }
          if (!isInter && !isMerge && _.kotlin.get_size(values) !== 0) {
            {
              var tmp$0 = values.keySet().iterator();
              while (tmp$0.hasNext()) {
                var hashLoopRes = tmp$0.next();
                var tmp$1;
                traces.add(_.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$1 = this.path()) != null ? tmp$1 : Kotlin.throwNPE(), hashLoopRes, null, null, null));
              }
            }
          }
        }
        if (onlyReferences) {
          var payload = '';
          var refVisitorFill = _.org.kevoree.container.KMFContainerImpl.f6(values, payload);
          this.visit(refVisitorFill, false, false, true);
          var refVisitor = _.org.kevoree.container.KMFContainerImpl.f7(this, values, isInter, traces);
          if (similarObj != null) {
            similarObj.visit(refVisitor, false, false, true);
          }
          if (!isInter && !isMerge && _.kotlin.get_size(values) !== 0) {
            {
              var tmp$2 = values.keySet().iterator();
              while (tmp$2.hasNext()) {
                var hashLoopRes_0 = tmp$2.next();
                var splittedVal = Kotlin.splitString(hashLoopRes_0, '_');
                var tmp$3;
                traces.add(_.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$3 = this.path()) != null ? tmp$3 : Kotlin.throwNPE(), splittedVal[0], splittedVal[1]));
              }
            }
          }
        }
        return traces;
      }, writable: true}
    }, /** @lends _.org.kevoree.container.KMFContainerImpl */ {
      f0: {value: function () {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            if (elem.isRecursiveReadOnly()) {
              this.noChildrenVisit();
            }
             else {
              (elem != null ? elem : Kotlin.throwNPE()).setInternalRecursiveReadOnly();
              elem.setInternalReadOnly();
            }
          }, writable: true, enumerable: true}
        });
      }},
      f1: {value: function (values) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelAttributeVisitor, null, {
          visit: {value: function (value, name, parent) {
            if (values.containsKey(name)) {
              if (Kotlin.equals(values.get(name), Kotlin.toString(value))) {
                values.remove(name);
              }
            }
             else {
              values.put(name, Kotlin.toString(value));
            }
          }, writable: true, enumerable: true}
        });
      }},
      f2: {value: function (values, payload) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            var concatedKey = refNameInParent + '_' + elem.path();
            if (values.containsKey(concatedKey)) {
              values.remove(concatedKey);
            }
             else {
              values.put(concatedKey, payload);
            }
          }, writable: true, enumerable: true}
        });
      }},
      f3: {value: function (finalRoot, resultTest) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            var tmp$0;
            var similarSubObj = finalRoot.findByPath((tmp$0 = elem.path()) != null ? tmp$0 : Kotlin.throwNPE());
            if (!elem.modelEquals(similarSubObj)) {
              resultTest = false;
              this.stopVisit();
            }
          }, writable: true, enumerable: true}
        });
      }},
      f4: {value: function (values) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelAttributeVisitor, null, {
          visit: {value: function (value, name, parent) {
            values.put(name, Kotlin.toString(value));
          }, writable: true, enumerable: true}
        });
      }},
      f5: {value: function ($outer, values, isInter, traces) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelAttributeVisitor, null, {
          visit: {value: function (value, name, parent) {
            var attVal2;
            if (value != null) {
              attVal2 = Kotlin.toString(value);
            }
             else {
              attVal2 = null;
            }
            if (Kotlin.equals(values.get(name), attVal2)) {
              if (isInter) {
                var tmp$0;
                traces.add(_.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$0 = $outer.path()) != null ? tmp$0 : Kotlin.throwNPE(), name, null, attVal2, null));
              }
            }
             else {
              if (!isInter) {
                var tmp$1;
                traces.add(_.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$1 = $outer.path()) != null ? tmp$1 : Kotlin.throwNPE(), name, null, attVal2, null));
              }
            }
            values.remove(name);
          }, writable: true, enumerable: true}
        });
      }},
      f6: {value: function (values, payload) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            var concatedKey = refNameInParent + '_' + elem.path();
            values.put(concatedKey, payload);
          }, writable: true, enumerable: true}
        });
      }},
      f7: {value: function ($outer, values, isInter, traces) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            var concatedKey = refNameInParent + '_' + elem.path();
            if (values.get(concatedKey) != null) {
              if (isInter) {
                var tmp$0, tmp$1;
                traces.add(_.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$0 = $outer.path()) != null ? tmp$0 : Kotlin.throwNPE(), refNameInParent, (tmp$1 = elem.path()) != null ? tmp$1 : Kotlin.throwNPE(), null));
              }
            }
             else {
              if (!isInter) {
                var tmp$2, tmp$3;
                traces.add(_.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$2 = $outer.path()) != null ? tmp$2 : Kotlin.throwNPE(), refNameInParent, (tmp$3 = elem.path()) != null ? tmp$3 : Kotlin.throwNPE(), null));
              }
            }
            values.remove(concatedKey);
          }, writable: true, enumerable: true}
        });
      }}
    })
    , cw = Kotlin.createTrait([ci, cl])
    , cx = Kotlin.createTrait([ci, cl])
    , cy = Kotlin.createTrait(ci)
    , cz = Kotlin.createTrait(ci)
    , c10 = Kotlin.createTrait(ci)
    , c12 = Kotlin.createTrait([ci, cl])
    , c14 = Kotlin.createTrait([ci, cn])
    , c16 = Kotlin.createTrait([ci, cl])
    , c17 = Kotlin.createTrait([ci, cw])
    , c1g = Kotlin.createTrait([ci, cn])
    , c18 = Kotlin.createTrait([ci, c1g])
    , c19 = Kotlin.createTrait(c5)
    , c1a = Kotlin.createTrait(ci)
    , c1b = Kotlin.createTrait(ci)
    , c1c = Kotlin.createTrait([ci, c13])
    , c1d = Kotlin.createTrait(ci)
    , c1e = Kotlin.createTrait(ci)
    , c1f = Kotlin.createTrait([ci, cl])
    , c1h = Kotlin.createTrait([ci, cl])
    , c1i = Kotlin.createTrait([ci, cl])
    , c1j = Kotlin.createTrait(ci)
    , c1k = Kotlin.createTrait([ci, cl])
    , c1l = Kotlin.createTrait(ci)
    , c1m = Kotlin.createTrait([ci, cl, c13])
    , c1n = Kotlin.createTrait(null)
    , c1o = Kotlin.createTrait(null)
    , c1p = Kotlin.createTrait(null, /** @lends _.org.w3c.dom.events.EventListener.prototype */ {
      handleEvent: {value: function (arg1) {
        noImpl;
      }, writable: true}
    })
    , c1q = Kotlin.createTrait(null)
    , c1r = Kotlin.createClass(Kotlin.Iterator, function () {
      Object.defineProperty(this, 'state', {value: _.kotlin.support.State.NotReady, writable: true});
      Object.defineProperty(this, 'nextValue', {value: null, writable: true});
    }, /** @lends _.kotlin.support.AbstractIterator.prototype */ {
      hasNext: {value: function () {
        _.kotlin.require(this.state !== _.kotlin.support.State.Failed, 'Failed requirement');
        var tmp$0 = this.state, tmp$1;
        if (tmp$0 === _.kotlin.support.State.Done)
          tmp$1 = false;
        else if (tmp$0 === _.kotlin.support.State.Ready)
          tmp$1 = true;
        else
          tmp$1 = this.tryToComputeNext();
        return tmp$1;
      }, writable: true},
      next: {value: function () {
        if (!this.hasNext())
          throw Kotlin.NoSuchElementException();
        this.state = _.kotlin.support.State.NotReady;
        var tmp$0;
        return (tmp$0 = this.nextValue) != null ? tmp$0 : Kotlin.throwNPE();
      }, writable: true},
      peek: {value: function () {
        if (!this.hasNext())
          throw Kotlin.NoSuchElementException();
        var tmp$0;
        return (tmp$0 = this.nextValue) != null ? tmp$0 : Kotlin.throwNPE();
      }},
      tryToComputeNext: {value: function () {
        this.state = _.kotlin.support.State.Failed;
        this.computeNext();
        return this.state === _.kotlin.support.State.Ready;
      }},
      setNext: {value: function (value) {
        this.nextValue = value;
        this.state = _.kotlin.support.State.Ready;
      }},
      done: {value: function () {
        this.state = _.kotlin.support.State.Done;
      }}
    });
    return {ci: ci, c0: c0, cl: cl, c13: c13, c1: c1, c15: c15, c11: c11, c2: c2, cn: cn, c3: c3, c4: c4, c5: c5, c6: c6, ca: ca, c7: c7, c8: c8, c9: c9, cb: cb, cc: cc, cd: cd, ce: ce, cf: cf, cg: cg, ch: ch, cj: cj, ck: ck, cm: cm, co: co, cp: cp, cq: cq, cr: cr, cs: cs, ct: ct, cu: cu, cv: cv, cw: cw, cx: cx, cy: cy, cz: cz, c10: c10, c12: c12, c14: c14, c16: c16, c17: c17, c1g: c1g, c18: c18, c19: c19, c1a: c1a, c1b: c1b, c1c: c1c, c1d: c1d, c1e: c1e, c1f: c1f, c1h: c1h, c1i: c1i, c1j: c1j, c1k: c1k, c1l: c1l, c1m: c1m, c1n: c1n, c1o: c1o, c1p: c1p, c1q: c1q, c1r: c1r};
  }()
  , _ = Object.create(null, {
    kotlin: Kotlin.definePackage(null, {
      Pair: {value: Kotlin.createClass(null, function (first, second) {
        Object.defineProperty(this, 'first', {value: first});
        Object.defineProperty(this, 'second', {value: second});
      }, /** @lends _.kotlin.Pair.prototype */ {
        component1: {value: function () {
          return this.first;
        }},
        component2: {value: function () {
          return this.second;
        }},
        toString: {value: function () {
          return '(' + this.first.toString() + ', ' + this.second.toString() + ')';
        }}
      })},
      Triple: {value: Kotlin.createClass(null, function (first, second, third) {
        Object.defineProperty(this, 'first', {value: first});
        Object.defineProperty(this, 'second', {value: second});
        Object.defineProperty(this, 'third', {value: third});
      }, /** @lends _.kotlin.Triple.prototype */ {
        component1: {value: function () {
          return this.first;
        }},
        component2: {value: function () {
          return this.second;
        }},
        component3: {value: function () {
          return this.third;
        }},
        toString: {value: function () {
          return '(' + this.first.toString() + ', ' + this.second.toString() + ', ' + this.third.toString() + ')';
        }}
      })},
      toString: {value: function ($receiver) {
        return _.kotlin.makeString($receiver, ', ', '[', ']', -1, '...');
      }},
      arrayList: {value: function (values) {
        var list = Kotlin.ArrayList(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var value = tmp$0[tmp$2];
            {
              list.add(value);
            }
          }
        }
        return list;
      }},
      hashSet: {value: function (values) {
        var list = Kotlin.ComplexHashSet();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var value = tmp$0[tmp$2];
            {
              list.add(value);
            }
          }
        }
        return list;
      }},
      map: {value: function ($receiver, transform) {
        return _.kotlin.mapTo($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapValues: {value: function ($receiver, transform) {
        return _.kotlin.mapValuesTo($receiver, Kotlin.ComplexHashMap(0), transform);
      }},
      hashMap: {value: function (values) {
        var answer = Kotlin.ComplexHashMap(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var v = tmp$0[tmp$2];
            {
              answer.put(v.first, v.second);
            }
          }
        }
        return answer;
      }},
      require: {value: function (value, message) {
        if (!value) {
          throw Kotlin.IllegalArgumentException(Kotlin.toString(message));
        }
      }},
      require_0: {value: function (value, lazyMessage) {
        if (!value) {
          var message = lazyMessage();
          throw Kotlin.IllegalArgumentException(message.toString());
        }
      }},
      requireNotNull: {value: function (value, message) {
        if (value == null) {
          throw Kotlin.IllegalArgumentException(Kotlin.toString(message));
        }
         else {
          return value;
        }
      }},
      check: {value: function (value, message) {
        if (!value) {
          throw Kotlin.IllegalStateException(Kotlin.toString(message));
        }
      }},
      check_0: {value: function (value, lazyMessage) {
        if (!value) {
          var message = lazyMessage();
          throw Kotlin.IllegalStateException(message.toString());
        }
      }},
      checkNotNull: {value: function (value, message) {
        if (value == null) {
          throw Kotlin.IllegalStateException(message);
        }
         else {
          return value;
        }
      }},
      all: {value: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any: {value: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find: {value: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filterTo: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNotTo: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNotNullTo: {value: function ($receiver, result) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null)
              result.add(element);
          }
        }
        return result;
      }},
      partition: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      mapTo_0: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMapTo: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach: {value: function ($receiver, operation) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      reduce: {value: function ($receiver, operation) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      groupBy: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      f0: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f0);
            list.add(element);
          }
        }
        return result;
      }},
      drop: {value: function ($receiver, n) {
        return _.kotlin.dropWhile($receiver, _.kotlin.countTo(n));
      }},
      dropWhile: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      takeWhileTo: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection: {value: function ($receiver, result) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse: {value: function ($receiver) {
        var list = _.kotlin.toCollection($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList: {value: function ($receiver) {
        return _.kotlin.toCollection($receiver, Kotlin.LinkedList());
      }},
      toList: {value: function ($receiver) {
        return _.kotlin.toCollection($receiver, Kotlin.ArrayList(0));
      }},
      toSet: {value: function ($receiver) {
        return _.kotlin.toCollection($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet: {value: function ($receiver) {
        return _.kotlin.toCollection($receiver, Kotlin.TreeSet());
      }},
      withIndices: {value: function ($receiver) {
        return _.kotlin.IndexIterator($receiver.iterator());
      }},
      f1: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f1.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      all_0: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_0: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_0: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_0: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_0($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_0: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_0($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_0: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_0: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_0: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_1($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_1: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_0($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_0: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_0: {value: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_0: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_0: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_0: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_0($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      f2: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_0: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f2);
            list.add(element);
          }
        }
        return result;
      }},
      drop_0: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_0($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_0: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_0($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_0: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      take: {value: function ($receiver, n) {
        return _.kotlin.takeWhile($receiver, _.kotlin.countTo(n));
      }},
      takeWhile: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_0($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_0: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_0: {value: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_0: {value: function ($receiver) {
        var list = _.kotlin.toCollection_0($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_0: {value: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, Kotlin.LinkedList());
      }},
      toList_0: {value: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, Kotlin.ArrayList(0));
      }},
      toSet_0: {value: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_0: {value: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, Kotlin.TreeSet());
      }},
      plus: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_0($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_0: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_0($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_1: {value: function ($receiver, collection) {
        return _.kotlin.plus_0($receiver, collection.iterator());
      }},
      withIndices_0: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      f3: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_0: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_0($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f3.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_0: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_0: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_0($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      all_1: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_1: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_1: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_1: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_0: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_1($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_1: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_0: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_1($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_1: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_1: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_1: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_2($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_2: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_0: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_1($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_1: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_1: {value: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_1: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_0: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_1: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_0: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_1: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_1($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      f4: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_1: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f4);
            list.add(element);
          }
        }
        return result;
      }},
      drop_1: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_1($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_1: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_1($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_1: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      take_0: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_0($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_0: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_1($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_1: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_1: {value: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_1: {value: function ($receiver) {
        var list = _.kotlin.toCollection_1($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_1: {value: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, Kotlin.LinkedList());
      }},
      toList_1: {value: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, Kotlin.ArrayList(0));
      }},
      toSet_1: {value: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_1: {value: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, Kotlin.TreeSet());
      }},
      plus_2: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_1($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_3: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_1($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_4: {value: function ($receiver, collection) {
        return _.kotlin.plus_3($receiver, collection.iterator());
      }},
      withIndices_1: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      f5: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_1: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_1($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f5.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_1: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_1: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_1($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      downTo: {value: function ($receiver, to) {
        return _.jet.ByteProgression($receiver, to, -1);
      }},
      downTo_0: {value: function ($receiver, to) {
        return _.jet.CharProgression($receiver.toChar(), to, -1);
      }},
      downTo_1: {value: function ($receiver, to) {
        return _.jet.ShortProgression($receiver, to, -1);
      }},
      downTo_2: {value: function ($receiver, to) {
        return Kotlin.NumberProgression($receiver, to, -1);
      }},
      downTo_3: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      }},
      downTo_4: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to, -1);
      }},
      downTo_5: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_6: {value: function ($receiver, to) {
        return _.jet.CharProgression($receiver, to.toChar(), -1);
      }},
      downTo_7: {value: function ($receiver, to) {
        return _.jet.CharProgression($receiver, to, -1);
      }},
      downTo_8: {value: function ($receiver, to) {
        return _.jet.ShortProgression($receiver.toShort(), to, -1);
      }},
      downTo_9: {value: function ($receiver, to) {
        return Kotlin.NumberProgression($receiver.toInt(), to, -1);
      }},
      downTo_10: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      }},
      downTo_11: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver.toFloat(), to, -1);
      }},
      downTo_12: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver.toDouble(), to, -1.0);
      }},
      downTo_13: {value: function ($receiver, to) {
        return _.jet.ShortProgression($receiver, to, -1);
      }},
      downTo_14: {value: function ($receiver, to) {
        return _.jet.ShortProgression($receiver, to.toShort(), -1);
      }},
      downTo_15: {value: function ($receiver, to) {
        return _.jet.ShortProgression($receiver, to, -1);
      }},
      downTo_16: {value: function ($receiver, to) {
        return Kotlin.NumberProgression($receiver, to, -1);
      }},
      downTo_17: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      }},
      downTo_18: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to, -1);
      }},
      downTo_19: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_20: {value: function ($receiver, to) {
        return Kotlin.NumberProgression($receiver, to, -1);
      }},
      downTo_21: {value: function ($receiver, to) {
        return Kotlin.NumberProgression($receiver, to.toInt(), -1);
      }},
      downTo_22: {value: function ($receiver, to) {
        return Kotlin.NumberProgression($receiver, to, -1);
      }},
      downTo_23: {value: function ($receiver, to) {
        return Kotlin.NumberProgression($receiver, to, -1);
      }},
      downTo_24: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      }},
      downTo_25: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to, -1);
      }},
      downTo_26: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_27: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      }},
      downTo_28: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      }},
      downTo_29: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      }},
      downTo_30: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      }},
      downTo_31: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver, to, -(1).toLong());
      }},
      downTo_32: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver.toFloat(), to, -1);
      }},
      downTo_33: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver.toDouble(), to, -1.0);
      }},
      downTo_34: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to, -1);
      }},
      downTo_35: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to.toFloat(), -1);
      }},
      downTo_36: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to, -1);
      }},
      downTo_37: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to, -1);
      }},
      downTo_38: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to.toFloat(), -1);
      }},
      downTo_39: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to, -1);
      }},
      downTo_40: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_41: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_42: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to.toDouble(), -1.0);
      }},
      downTo_43: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_44: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_45: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to.toDouble(), -1.0);
      }},
      downTo_46: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_47: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      all_2: {value: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_2: {value: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_2: {value: function ($receiver, predicate) {
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_2: {value: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_1: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_2($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_2: {value: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_1: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_2($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_2: {value: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNotNull: {value: function ($receiver) {
        return _.kotlin.filterNotNullTo_0($receiver, Kotlin.ArrayList(0));
      }},
      filterNotNullTo_0: {value: function ($receiver, result) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (element != null)
              result.add(element);
          }
        }
        return result;
      }},
      partition_2: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              if (predicate(element)) {
                first.add(element);
              }
               else {
                second.add(element);
              }
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_2: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_3($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_3: {value: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_1: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_2($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_2: {value: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              var list = transform(element);
              {
                var tmp$3 = list.iterator();
                while (tmp$3.hasNext()) {
                  var r = tmp$3.next();
                  result.add(r);
                }
              }
            }
          }
        }
        return result;
      }},
      forEach_2: {value: function ($receiver, operation) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            operation(element);
          }
        }
      }},
      fold_2: {value: function ($receiver, initial, operation) {
        var answer = initial;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_1: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_2: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_1: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_2: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_2($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      f6: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_2: {value: function ($receiver, result, toKey) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              var key = toKey(element);
              var list = _.kotlin.getOrPut(result, key, _.kotlin.f6);
              list.add(element);
            }
          }
        }
        return result;
      }},
      drop_2: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_2($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_2: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_2($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_2: {value: function ($receiver, result, predicate) {
        var start = true;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              if (start && predicate(element)) {
              }
               else {
                start = false;
                result.add(element);
              }
            }
          }
        }
        return result;
      }},
      take_1: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_1($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_1: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_2($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_2: {value: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_2: {value: function ($receiver, result) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            result.add(element);
          }
        }
        return result;
      }},
      reverse_2: {value: function ($receiver) {
        var list = _.kotlin.toCollection_2($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_2: {value: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, Kotlin.LinkedList());
      }},
      toList_2: {value: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, Kotlin.ArrayList(0));
      }},
      toSet_2: {value: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_2: {value: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, Kotlin.TreeSet());
      }},
      requireNoNulls: {value: function ($receiver) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              if (element == null) {
                throw Kotlin.IllegalArgumentException('null element found in ' + $receiver.toString());
              }
            }
          }
        }
        return $receiver != null ? $receiver : Kotlin.throwNPE();
      }},
      plus_5: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_2($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_6: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_2($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_7: {value: function ($receiver, collection) {
        return _.kotlin.plus_6($receiver, collection.iterator());
      }},
      withIndices_2: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      f7: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_2: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_2($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f7.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_2: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              if (++count > 1)
                buffer.append(separator);
              if (limit < 0 || count <= limit) {
                var text = element == null ? 'null' : Kotlin.toString(element);
                buffer.append(text);
              }
               else
                break;
            }
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_2: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_2($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      all_3: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_3: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_3: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_3: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_2: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_3($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_3: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_2: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_3($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_3: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_3: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_3: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_4($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_4: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_2: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_3($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_3: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_3: {value: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_3: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_2: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_3: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_2: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_3: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_3($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      f8: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_3: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f8);
            list.add(element);
          }
        }
        return result;
      }},
      drop_3: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_3($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_3: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_3($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_3: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      take_2: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_2($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_2: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_3($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_3: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_3: {value: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_3: {value: function ($receiver) {
        var list = _.kotlin.toCollection_3($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_3: {value: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, Kotlin.LinkedList());
      }},
      toList_3: {value: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, Kotlin.ArrayList(0));
      }},
      toSet_3: {value: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_3: {value: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, Kotlin.TreeSet());
      }},
      plus_8: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_3($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_9: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_3($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_10: {value: function ($receiver, collection) {
        return _.kotlin.plus_9($receiver, collection.iterator());
      }},
      withIndices_3: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      f9: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_3: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_3($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f9.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_3: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_3: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_3($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      get_size: {value: function ($receiver) {
        return $receiver.size();
      }},
      get_empty: {value: function ($receiver) {
        return $receiver.isEmpty();
      }},
      get_indices: {value: function ($receiver) {
        return Kotlin.NumberRange(0, _.kotlin.get_size($receiver) - 1);
      }},
      get_indices: {value: function ($receiver) {
        return Kotlin.NumberRange(0, $receiver - 1);
      }},
      isNotEmpty_0: {value: function ($receiver) {
        return !$receiver.isEmpty();
      }},
      get_notEmpty: {value: function ($receiver) {
        return _.kotlin.isNotEmpty_0($receiver);
      }},
      orEmpty: {value: function ($receiver) {
        var tmp$0;
        return $receiver != null ? $receiver : (tmp$0 = Kotlin.emptyList()) != null ? tmp$0 : Kotlin.throwNPE();
      }},
      toSortedList: {value: function ($receiver) {
        return _.kotlin.sort(_.kotlin.toCollection($receiver, Kotlin.ArrayList(0)));
      }},
      toSortedList_0: {value: function ($receiver, comparator) {
        return _.kotlin.sort_0(_.kotlin.toList($receiver), comparator);
      }},
      orEmpty_0: {value: function ($receiver) {
        var tmp$0;
        return $receiver != null ? $receiver : (tmp$0 = Kotlin.emptyList()) != null ? tmp$0 : Kotlin.throwNPE();
      }},
      get_first: {value: function ($receiver) {
        return _.kotlin.get_head($receiver);
      }},
      get_last: {value: function ($receiver) {
        var s = _.kotlin.get_size($receiver);
        return s > 0 ? $receiver.get(s - 1) : null;
      }},
      get_lastIndex: {value: function ($receiver) {
        return _.kotlin.get_size($receiver) - 1;
      }},
      get_head: {value: function ($receiver) {
        return $receiver.get(0);
      }},
      get_tail: {value: function ($receiver) {
        return _.kotlin.drop($receiver, 1);
      }},
      all_4: {value: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_4: {value: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_4: {value: function ($receiver, predicate) {
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_4: {value: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_3: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_4($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_4: {value: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_3: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_4($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_4: {value: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_4: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              if (predicate(element)) {
                first.add(element);
              }
               else {
                second.add(element);
              }
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_4: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_5($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_5: {value: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_3: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_4($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_4: {value: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              var list = transform(element);
              {
                var tmp$3 = list.iterator();
                while (tmp$3.hasNext()) {
                  var r = tmp$3.next();
                  result.add(r);
                }
              }
            }
          }
        }
        return result;
      }},
      forEach_4: {value: function ($receiver, operation) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            operation(element);
          }
        }
      }},
      fold_4: {value: function ($receiver, initial, operation) {
        var answer = initial;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_3: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_4: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_3: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_4: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_4($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      fa: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_4: {value: function ($receiver, result, toKey) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              var key = toKey(element);
              var list = _.kotlin.getOrPut(result, key, _.kotlin.fa);
              list.add(element);
            }
          }
        }
        return result;
      }},
      drop_4: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_4($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_4: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_4($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_4: {value: function ($receiver, result, predicate) {
        var start = true;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              if (start && predicate(element)) {
              }
               else {
                start = false;
                result.add(element);
              }
            }
          }
        }
        return result;
      }},
      take_3: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_3($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_3: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_4($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_4: {value: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_4: {value: function ($receiver, result) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            result.add(element);
          }
        }
        return result;
      }},
      reverse_4: {value: function ($receiver) {
        var list = _.kotlin.toCollection_4($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_4: {value: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, Kotlin.LinkedList());
      }},
      toList_4: {value: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, Kotlin.ArrayList(0));
      }},
      toSet_4: {value: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_4: {value: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, Kotlin.TreeSet());
      }},
      plus_11: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_4($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_12: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_4($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_13: {value: function ($receiver, collection) {
        return _.kotlin.plus_12($receiver, collection.iterator());
      }},
      withIndices_4: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      fb: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_4: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_4($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fb.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_4: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              if (++count > 1)
                buffer.append(separator);
              if (limit < 0 || count <= limit) {
                var text = element == null ? 'null' : Kotlin.toString(element);
                buffer.append(text);
              }
               else
                break;
            }
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_4: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_4($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      test: Kotlin.definePackage(function () {
        Object.defineProperty(this, 'asserter', {value: _.kotlin.test.QUnitAsserter(), writable: true});
      }, {
        todo: {value: function (block) {
          Kotlin.println('TODO at ' + block);
        }},
        QUnitAsserter: {value: Kotlin.createClass(classes.c1q, null, /** @lends _.kotlin.test.QUnitAsserter.prototype */ {
          assertTrue: {value: function (message, actual) {
            ok(actual, message);
          }, writable: true},
          assertEquals: {value: function (message, expected, actual) {
            ok(Kotlin.equals(expected, actual), message + '. Expected <' + expected.toString() + '> actual <' + actual.toString() + '>');
          }, writable: true},
          assertNotNull: {value: function (message, actual) {
            ok(actual != null, message);
          }, writable: true},
          assertNull: {value: function (message, actual) {
            ok(actual == null, message);
          }, writable: true},
          fail: {value: function (message) {
            ok(false, message);
          }, writable: true}
        })},
        assertTrue: {value: function (message, block) {
          var actual = block();
          _.kotlin.test.asserter.assertTrue(message, actual);
        }},
        assertTrue_0: {value: function (block) {
          _.kotlin.test.assertTrue(Kotlin.toString(block), block);
        }},
        f0: {value: function (block) {
          return !block();
        }},
        assertNot: {value: function (message, block) {
          _.kotlin.test.assertTrue(message, _.kotlin.test.f0.bind(null, block));
        }},
        assertNot_0: {value: function (block) {
          _.kotlin.test.assertNot(Kotlin.toString(block), block);
        }},
        assertTrue_1: {value: function (actual, message) {
          return _.kotlin.test.assertEquals(true, actual, message);
        }},
        assertFalse: {value: function (actual, message) {
          return _.kotlin.test.assertEquals(false, actual, message);
        }},
        assertEquals: {value: function (expected, actual, message) {
          _.kotlin.test.asserter.assertEquals(message, expected, actual);
        }},
        assertNotNull: {value: function (actual, message) {
          _.kotlin.test.asserter.assertNotNull(message, actual);
          return actual != null ? actual : Kotlin.throwNPE();
        }},
        assertNotNull_0: {value: function (actual, message, block) {
          _.kotlin.test.asserter.assertNotNull(message, actual);
          if (actual != null) {
            block(actual);
          }
        }},
        assertNull: {value: function (actual, message) {
          _.kotlin.test.asserter.assertNull(message, actual);
        }},
        fail: {value: function (message) {
          _.kotlin.test.asserter.fail(message);
        }},
        expect: {value: function (expected, block) {
          _.kotlin.test.expect_0(expected, Kotlin.toString(block), block);
        }},
        expect_0: {value: function (expected, message, block) {
          var actual = block();
          _.kotlin.test.assertEquals(expected, actual, message);
        }},
        fails: {value: function (block) {
          try {
            block();
            _.kotlin.test.asserter.fail('Expected an exception to be thrown');
            return null;
          }
           catch (e) {
            return e;
          }
        }},
        Asserter: {value: classes.c1q}
      }),
      filter_4: {value: function ($receiver, predicate) {
        return _.kotlin.FilterIterator($receiver, predicate);
      }},
      fc: {value: function (predicate, it) {
        return !predicate(it);
      }},
      filterNot_4: {value: function ($receiver, predicate) {
        return _.kotlin.filter_4($receiver, _.kotlin.fc.bind(null, predicate));
      }},
      filterNotNull_0: {value: function ($receiver) {
        return _.kotlin.FilterNotNullIterator($receiver);
      }},
      map_5: {value: function ($receiver, transform) {
        return _.kotlin.MapIterator($receiver, transform);
      }},
      flatMap_4: {value: function ($receiver, transform) {
        return _.kotlin.FlatMapIterator($receiver, transform);
      }},
      fd: {value: function (it) {
        if (it == null)
          throw Kotlin.IllegalArgumentException('null element in iterator ' + $receiver.toString());
        else
          return it;
      }},
      requireNoNulls_0: {value: function ($receiver) {
        return _.kotlin.map_5($receiver, _.kotlin.fd);
      }},
      fe: {value: function (count, it) {
        return --count.v >= 0;
      }},
      take_4: {value: function ($receiver, n) {
        var count = {v: n};
        return _.kotlin.takeWhile_4($receiver, _.kotlin.fe.bind(null, count));
      }},
      takeWhile_4: {value: function ($receiver, predicate) {
        return _.kotlin.TakeWhileIterator($receiver, predicate);
      }},
      plus_14: {value: function ($receiver, element) {
        return _.kotlin.CompositeIterator([$receiver, _.kotlin.SingleIterator(element)]);
      }},
      plus_15: {value: function ($receiver, iterator) {
        return _.kotlin.CompositeIterator([$receiver, iterator]);
      }},
      plus_16: {value: function ($receiver, collection) {
        return _.kotlin.plus_15($receiver, collection.iterator());
      }},
      filter_5: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNot_5: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotNull_1: {value: function ($receiver) {
        return _.kotlin.filterNotNullTo($receiver, Kotlin.ArrayList(0));
      }},
      map_6: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_0($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMap_5: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo($receiver, Kotlin.ArrayList(0), transform);
      }},
      take_5: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_5($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_5: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo($receiver, Kotlin.ArrayList(0), predicate);
      }},
      requireNoNulls_1: {value: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element == null) {
              throw Kotlin.IllegalArgumentException('null element found in ' + $receiver.toString());
            }
          }
        }
        return $receiver != null ? $receiver : Kotlin.throwNPE();
      }},
      plus_17: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_18: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_19: {value: function ($receiver, collection) {
        return _.kotlin.plus_18($receiver, collection.iterator());
      }},
      get_size: {value: function ($receiver) {
        return $receiver.size();
      }},
      get_empty: {value: function ($receiver) {
        return $receiver.isEmpty();
      }},
      set: {value: function ($receiver, key, value) {
        return $receiver.put(key, value);
      }},
      orEmpty_1: {value: function ($receiver) {
        var tmp$0;
        return $receiver != null ? $receiver : (tmp$0 = Kotlin.emptyMap()) != null ? tmp$0 : Kotlin.throwNPE();
      }},
      get_key: {value: function ($receiver) {
        return $receiver.getKey();
      }},
      get_value: {value: function ($receiver) {
        return $receiver.getValue();
      }},
      component1: {value: function ($receiver) {
        return $receiver.getKey();
      }},
      component2: {value: function ($receiver) {
        return $receiver.getValue();
      }},
      getOrElse: {value: function ($receiver, key, defaultValue) {
        if ($receiver.containsKey(key)) {
          var tmp$0;
          return (tmp$0 = $receiver.get(key)) != null ? tmp$0 : Kotlin.throwNPE();
        }
         else {
          return defaultValue();
        }
      }},
      getOrPut: {value: function ($receiver, key, defaultValue) {
        if ($receiver.containsKey(key)) {
          var tmp$0;
          return (tmp$0 = $receiver.get(key)) != null ? tmp$0 : Kotlin.throwNPE();
        }
         else {
          var answer = defaultValue();
          $receiver.put(key, answer);
          return answer;
        }
      }},
      iterator: {value: function ($receiver) {
        var entrySet = $receiver.entrySet();
        return entrySet.iterator();
      }},
      mapTo: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = _.kotlin.iterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      mapValuesTo: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = _.kotlin.iterator($receiver);
          while (tmp$0.hasNext()) {
            var e = tmp$0.next();
            var newValue = transform(e);
            result.put(_.kotlin.get_key(e), newValue);
          }
        }
        return result;
      }},
      putAll: {value: function ($receiver, values) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var v = tmp$0[tmp$2];
            {
              $receiver.put(v.first, v.second);
            }
          }
        }
      }},
      toMap: {value: function ($receiver, map) {
        map.putAll($receiver);
        return map;
      }},
      map_7: {value: function ($receiver, transform) {
        return _.kotlin.mapTo($receiver, Kotlin.ArrayList(_.kotlin.get_size($receiver)), transform);
      }},
      mapValues_0: {value: function ($receiver, transform) {
        return _.kotlin.mapValuesTo($receiver, Kotlin.ComplexHashMap(_.kotlin.get_size($receiver)), transform);
      }},
      all_5: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_5: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_5: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_5: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_6: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_5($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_5: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_6: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_5($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_5: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_5: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_8: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_6($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_6: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_6: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_5($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_5: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_5: {value: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_5: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_4: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_5: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_4: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_5: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_5($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      ff: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_5: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.ff);
            list.add(element);
          }
        }
        return result;
      }},
      drop_5: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_5($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_5: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_5($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_5: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      take_6: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_6($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_6: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_5($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_5: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_5: {value: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_5: {value: function ($receiver) {
        var list = _.kotlin.toCollection_5($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_5: {value: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, Kotlin.LinkedList());
      }},
      toList_5: {value: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, Kotlin.ArrayList(0));
      }},
      toSet_5: {value: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_5: {value: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, Kotlin.TreeSet());
      }},
      plus_20: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_5($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_21: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_5($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_22: {value: function ($receiver, collection) {
        return _.kotlin.plus_21($receiver, collection.iterator());
      }},
      withIndices_5: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      fg: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_5: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_5($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fg.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_5: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_5: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_5($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      dom: Kotlin.definePackage(null, {
        createDocument: {value: function () {
          return document.implementation.createDocument(null, null, null);
        }},
        toXmlString: {value: function ($receiver) {
          return $receiver.outerHTML;
        }},
        toXmlString_0: {value: function ($receiver, xmlDeclaration) {
          return $receiver.outerHTML;
        }},
        eventHandler: {value: function (handler) {
          return _.kotlin.dom.EventListenerHandler(handler);
        }},
        EventListenerHandler: {value: Kotlin.createClass(classes.c1p, function (handler) {
          Object.defineProperty(this, 'handler', {value: handler});
        }, /** @lends _.kotlin.dom.EventListenerHandler.prototype */ {
          handleEvent: {value: function (e) {
            if (e != null) {
              this.handler(e);
            }
          }, writable: true}
        })},
        f0: {value: function (handler, e) {
          if (Kotlin.isType(e, MouseEvent)) {
            handler(e);
          }
        }},
        mouseEventHandler: {value: function (handler) {
          return _.kotlin.dom.eventHandler(_.kotlin.dom.f0.bind(null, handler));
        }},
        on: {value: function ($receiver, name, capture, handler) {
          return _.kotlin.dom.on_0($receiver, name, capture, _.kotlin.dom.eventHandler(handler));
        }},
        on_0: {value: function ($receiver, name, capture, listener) {
          var tmp$0;
          if (Kotlin.isType($receiver, EventTarget)) {
            addEventListener(name, listener, capture);
            tmp$0 = _.kotlin.dom.CloseableEventListener($receiver, listener, name, capture);
          }
           else {
            tmp$0 = null;
          }
          return tmp$0;
        }},
        CloseableEventListener: {value: Kotlin.createClass(Kotlin.Closeable, function (target, listener, name, capture) {
          Object.defineProperty(this, 'target', {value: target});
          Object.defineProperty(this, 'listener', {value: listener});
          Object.defineProperty(this, 'name', {value: name});
          Object.defineProperty(this, 'capture', {value: capture});
        }, /** @lends _.kotlin.dom.CloseableEventListener.prototype */ {
          close: {value: function () {
            this.target.removeEventListener(this.name, this.listener, this.capture);
          }, writable: true}
        })},
        onClick: {value: function ($receiver, capture, handler) {
          return _.kotlin.dom.on_0($receiver, 'click', capture, _.kotlin.dom.mouseEventHandler(handler));
        }},
        onDoubleClick: {value: function ($receiver, capture, handler) {
          return _.kotlin.dom.on_0($receiver, 'dblclick', capture, _.kotlin.dom.mouseEventHandler(handler));
        }},
        emptyElementList: {value: function () {
          return Kotlin.emptyList();
        }},
        emptyNodeList: {value: function () {
          return Kotlin.emptyList();
        }},
        get_text: {value: function ($receiver) {
          return $receiver.textContent;
        }},
        set_text: {value: function ($receiver, value) {
          $receiver.textContent = value;
        }},
        get_childrenText: {value: function ($receiver) {
          var buffer = Kotlin.StringBuilder();
          var nodeList = $receiver.childNodes;
          var i = 0;
          var size = nodeList.length;
          while (i < size) {
            var node = nodeList.item(i);
            if (node != null) {
              if (_.kotlin.dom.isText(node)) {
                buffer.append(node.nodeValue);
              }
            }
            i++;
          }
          return buffer.toString();
        }},
        set_childrenText: {value: function ($receiver, value) {
          var element = $receiver;
          {
            var tmp$0 = _.kotlin.dom.children(element).iterator();
            while (tmp$0.hasNext()) {
              var node = tmp$0.next();
              if (_.kotlin.dom.isText(node)) {
                $receiver.removeChild(node);
              }
            }
          }
          _.kotlin.dom.addText(element, value, null);
        }},
        get_id: {value: function ($receiver) {
          return $receiver.getAttribute('id') !== null ? $receiver.getAttribute('id') : '';
        }},
        set_id: {value: function ($receiver, value) {
          $receiver.setAttribute('id', value);
          $receiver.setIdAttribute('id', true);
        }},
        get_style: {value: function ($receiver) {
          return $receiver.getAttribute('style') !== null ? $receiver.getAttribute('style') : '';
        }},
        set_style: {value: function ($receiver, value) {
          $receiver.setAttribute('style', value);
        }},
        get_classes: {value: function ($receiver) {
          return $receiver.getAttribute('class') !== null ? $receiver.getAttribute('class') : '';
        }},
        set_classes: {value: function ($receiver, value) {
          $receiver.setAttribute('class', value);
        }},
        hasClass: {value: function ($receiver, cssClass) {
          var c = _.kotlin.dom.get_classes($receiver);
          return _.js.matches(c, '(^|.*' + '\\' + 's+)' + cssClass + '(' + '$' + '|' + '\\' + 's+.*)');
        }},
        children: {value: function ($receiver) {
          return _.kotlin.dom.toList($receiver != null ? $receiver.childNodes : null);
        }},
        f1: {value: function (it) {
          return it.nodeType === Node.ELEMENT_NODE;
        }},
        f2: {value: function (it) {
          return it != null ? it : Kotlin.throwNPE();
        }},
        childElements: {value: function ($receiver) {
          return _.kotlin.map_6(_.kotlin.filter_5(_.kotlin.dom.children($receiver), _.kotlin.dom.f1), _.kotlin.dom.f2);
        }},
        f3: {value: function (name, it) {
          return it.nodeType === Node.ELEMENT_NODE && Kotlin.equals(it.nodeName, name);
        }},
        f4: {value: function (it) {
          return it != null ? it : Kotlin.throwNPE();
        }},
        childElements_0: {value: function ($receiver, name) {
          return _.kotlin.map_6(_.kotlin.filter_5(_.kotlin.dom.children($receiver), _.kotlin.dom.f3.bind(null, name)), _.kotlin.dom.f4);
        }},
        get_elements: {value: function ($receiver) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName('*') : null);
        }},
        get_elements: {value: function ($receiver) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName('*') : null);
        }},
        elements: {value: function ($receiver, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName(localName) : null);
        }},
        elements_0: {value: function ($receiver, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName(localName) : null);
        }},
        elements_1: {value: function ($receiver, namespaceUri, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagNameNS(namespaceUri, localName) : null);
        }},
        elements_2: {value: function ($receiver, namespaceUri, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagNameNS(namespaceUri, localName) : null);
        }},
        toList: {value: function ($receiver) {
          var tmp$0;
          if ($receiver == null) {
            tmp$0 = _.kotlin.dom.emptyNodeList();
          }
           else {
            tmp$0 = _.kotlin.dom.NodeListAsList($receiver);
          }
          return tmp$0;
        }},
        toElementList: {value: function ($receiver) {
          var tmp$0;
          if ($receiver == null) {
            tmp$0 = Kotlin.ArrayList(0);
          }
           else {
            tmp$0 = _.kotlin.dom.ElementListAsList($receiver);
          }
          return tmp$0;
        }},
        f5: {value: function (selector, it) {
          return _.kotlin.dom.hasClass(it, selector.substring(1));
        }},
        get: {value: function ($receiver, selector) {
          var root = $receiver != null ? $receiver.documentElement : null;
          var tmp$0;
          if (root != null) {
            if (Kotlin.equals(selector, '*')) {
              tmp$0 = _.kotlin.dom.get_elements($receiver);
            }
             else if (selector.startsWith('.')) {
              tmp$0 = _.kotlin.toList(_.kotlin.filter_5(_.kotlin.dom.get_elements($receiver), _.kotlin.dom.f5.bind(null, selector)));
            }
             else if (selector.startsWith('#')) {
              var id = selector.substring(1);
              var element = $receiver != null ? $receiver.getElementById(id) : null;
              return element != null ? _.kotlin.arrayList([element]) : _.kotlin.dom.emptyElementList();
            }
             else {
              tmp$0 = _.kotlin.dom.elements_0($receiver, selector);
            }
          }
           else {
            tmp$0 = _.kotlin.dom.emptyElementList();
          }
          return tmp$0;
        }},
        f6: {value: function (selector, it) {
          return _.kotlin.dom.hasClass(it, selector.substring(1));
        }},
        get_0: {value: function ($receiver, selector) {
          var tmp$1;
          if (Kotlin.equals(selector, '*')) {
            tmp$1 = _.kotlin.dom.get_elements($receiver);
          }
           else if (selector.startsWith('.')) {
            tmp$1 = _.kotlin.toList(_.kotlin.filter_5(_.kotlin.dom.get_elements($receiver), _.kotlin.dom.f6.bind(null, selector)));
          }
           else if (selector.startsWith('#')) {
            var tmp$0;
            var element = (tmp$0 = $receiver.ownerDocument) != null ? tmp$0.getElementById(selector.substring(1)) : null;
            return element != null ? _.kotlin.arrayList([element]) : _.kotlin.dom.emptyElementList();
          }
           else {
            tmp$1 = _.kotlin.dom.elements($receiver, selector);
          }
          return tmp$1;
        }},
        NodeListAsList: {value: Kotlin.createClass(Kotlin.AbstractList, function $fun(nodeList) {
          Object.defineProperty(this, 'nodeList', {value: nodeList});
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.NodeListAsList.prototype */ {
          get: {value: function (index) {
            var node = this.nodeList.item(index);
            if (node == null) {
              throw new RangeError('NodeList does not contain a node at index: ' + index);
            }
             else {
              return node;
            }
          }, writable: true},
          size: {value: function () {
            return this.nodeList.length;
          }, writable: true}
        })},
        ElementListAsList: {value: Kotlin.createClass(Kotlin.AbstractList, function $fun(nodeList) {
          Object.defineProperty(this, 'nodeList', {value: nodeList});
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.ElementListAsList.prototype */ {
          get: {value: function (index) {
            var node = this.nodeList.item(index);
            if (node == null) {
              throw new RangeError('NodeList does not contain a node at index: ' + index);
            }
             else if (node.nodeType === Node.ELEMENT_NODE) {
              return node != null ? node : Kotlin.throwNPE();
            }
             else {
              throw Kotlin.IllegalArgumentException('Node is not an Element as expected but is ' + node.toString());
            }
          }, writable: true},
          size: {value: function () {
            return this.nodeList.length;
          }, writable: true}
        })},
        clear: {value: function ($receiver) {
          while (true) {
            var child = $receiver.firstChild;
            if (child == null) {
              return;
            }
             else {
              $receiver.removeChild(child);
            }
          }
        }},
        nextSiblings: {value: function ($receiver) {
          return _.kotlin.dom.NextSiblingIterator($receiver);
        }},
        NextSiblingIterator: {value: Kotlin.createClass(classes.c1r, function $fun(node) {
          Object.defineProperty(this, 'node', {value: node, writable: true});
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.NextSiblingIterator.prototype */ {
          computeNext: {value: function () {
            var nextValue = this.node.nextSibling;
            if (nextValue != null) {
              this.setNext(nextValue);
              this.node = nextValue;
            }
             else {
              this.done();
            }
          }, writable: true}
        })},
        previousSiblings: {value: function ($receiver) {
          return _.kotlin.dom.PreviousSiblingIterator($receiver);
        }},
        PreviousSiblingIterator: {value: Kotlin.createClass(classes.c1r, function $fun(node) {
          Object.defineProperty(this, 'node', {value: node, writable: true});
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.PreviousSiblingIterator.prototype */ {
          computeNext: {value: function () {
            var nextValue = this.node.previousSibling;
            if (nextValue != null) {
              this.setNext(nextValue);
              this.node = nextValue;
            }
             else {
              this.done();
            }
          }, writable: true}
        })},
        isText: {value: function ($receiver) {
          var nt = $receiver.nodeType;
          return nt === Node.TEXT_NODE || nt === Node.CDATA_SECTION_NODE;
        }},
        attribute: {value: function ($receiver, name) {
          return $receiver.getAttribute(name) !== null ? $receiver.getAttribute(name) : '';
        }},
        get_head: {value: function ($receiver) {
          return $receiver != null && $receiver.length > 0 ? $receiver.item(0) : null;
        }},
        get_first: {value: function ($receiver) {
          return _.kotlin.dom.get_head($receiver);
        }},
        get_tail: {value: function ($receiver) {
          if ($receiver == null) {
            return null;
          }
           else {
            var s = $receiver.length;
            return s > 0 ? $receiver.item(s - 1) : null;
          }
        }},
        get_last: {value: function ($receiver) {
          return _.kotlin.dom.get_tail($receiver);
        }},
        toXmlString_1: {value: function ($receiver, xmlDeclaration) {
          var tmp$0;
          if ($receiver == null)
            tmp$0 = '';
          else {
            tmp$0 = _.kotlin.dom.nodesToXmlString(_.kotlin.dom.toList($receiver), xmlDeclaration);
          }
          return tmp$0;
        }},
        nodesToXmlString: {value: function (nodes, xmlDeclaration) {
          var builder = Kotlin.StringBuilder();
          {
            var tmp$0 = nodes.iterator();
            while (tmp$0.hasNext()) {
              var n = tmp$0.next();
              builder.append(_.kotlin.dom.toXmlString_0(n, xmlDeclaration));
            }
          }
          return builder.toString();
        }},
        plus: {value: function ($receiver, child) {
          if (child != null) {
            $receiver.appendChild(child);
          }
          return $receiver;
        }},
        plus_0: {value: function ($receiver, text) {
          return _.kotlin.dom.addText($receiver, text, null);
        }},
        plusAssign: {value: function ($receiver, text) {
          return _.kotlin.dom.addText($receiver, text, null);
        }},
        createElement: {value: function ($receiver, name, init) {
          var tmp$0;
          var elem = (tmp$0 = $receiver.createElement(name)) != null ? tmp$0 : Kotlin.throwNPE();
          init(elem);
          return elem;
        }},
        createElement_0: {value: function ($receiver, name, doc, init) {
          var tmp$0;
          var elem = (tmp$0 = _.kotlin.dom.ownerDocument($receiver, doc).createElement(name)) != null ? tmp$0 : Kotlin.throwNPE();
          init(elem);
          return elem;
        }},
        ownerDocument: {value: function ($receiver, doc) {
          var tmp$0;
          if ($receiver.nodeType === Node.DOCUMENT_NODE)
            tmp$0 = $receiver != null ? $receiver : Kotlin.throwNPE();
          else if (doc == null)
            tmp$0 = $receiver.ownerDocument;
          else
            tmp$0 = doc;
          var answer = tmp$0;
          if (answer == null) {
            throw Kotlin.IllegalArgumentException('Element does not have an ownerDocument and none was provided for: ' + $receiver.toString());
          }
           else {
            return answer;
          }
        }},
        addElement: {value: function ($receiver, name, init) {
          var child = _.kotlin.dom.createElement($receiver, name, init);
          $receiver.appendChild(child);
          return child;
        }},
        addElement_0: {value: function ($receiver, name, doc, init) {
          var child = _.kotlin.dom.createElement_0($receiver, name, doc, init);
          $receiver.appendChild(child);
          return child;
        }},
        addText: {value: function ($receiver, text, doc) {
          if (text != null) {
            var tmp$0;
            var child = (tmp$0 = _.kotlin.dom.ownerDocument($receiver, doc).createTextNode(text)) != null ? tmp$0 : Kotlin.throwNPE();
            $receiver.appendChild(child);
          }
          return $receiver;
        }}
      }),
      all_6: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_6: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_6: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_6: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_7: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_6($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_6: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_7: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_6($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_6: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_6: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_9: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_7($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_7: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_7: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_6($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_6: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_6: {value: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_6: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_5: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_6: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_5: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_6: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_6($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      fh: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_6: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fh);
            list.add(element);
          }
        }
        return result;
      }},
      drop_6: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_6($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_6: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_6($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_6: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      take_7: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_7($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_7: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_6($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_6: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_6: {value: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_6: {value: function ($receiver) {
        var list = _.kotlin.toCollection_6($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_6: {value: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, Kotlin.LinkedList());
      }},
      toList_6: {value: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, Kotlin.ArrayList(0));
      }},
      toSet_6: {value: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_6: {value: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, Kotlin.TreeSet());
      }},
      plus_23: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_6($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_24: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_6($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_25: {value: function ($receiver, collection) {
        return _.kotlin.plus_24($receiver, collection.iterator());
      }},
      withIndices_6: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      fi: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_6: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_6($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fi.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_6: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_6: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_6($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      all_7: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_7: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_7: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_7: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_8: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_7($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_7: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_8: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_7($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_7: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_7: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_10: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_8($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_8: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_8: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_7($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_7: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_7: {value: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_7: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_6: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_7: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_6: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_7: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_7($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      fj: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_7: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fj);
            list.add(element);
          }
        }
        return result;
      }},
      drop_7: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_7($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_7: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_7($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_7: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      take_8: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_8($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_8: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_7($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_7: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_7: {value: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_7: {value: function ($receiver) {
        var list = _.kotlin.toCollection_7($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_7: {value: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, Kotlin.LinkedList());
      }},
      toList_7: {value: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, Kotlin.ArrayList(0));
      }},
      toSet_7: {value: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_7: {value: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, Kotlin.TreeSet());
      }},
      plus_26: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_7($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_27: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_7($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_28: {value: function ($receiver, collection) {
        return _.kotlin.plus_27($receiver, collection.iterator());
      }},
      withIndices_7: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      fk: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_7: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_7($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fk.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_7: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_7: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_7($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      iterate: {value: function (nextFunction) {
        return _.kotlin.FunctionIterator(nextFunction);
      }},
      FilterIterator: {value: Kotlin.createClass(classes.c1r, function $fun(iterator, predicate) {
        Object.defineProperty(this, 'iterator', {value: iterator});
        Object.defineProperty(this, 'predicate', {value: predicate});
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.FilterIterator.prototype */ {
        computeNext: {value: function () {
          while (this.iterator.hasNext()) {
            var next = this.iterator.next();
            if (this.predicate(next)) {
              this.setNext(next);
              return;
            }
          }
          this.done();
        }, writable: true}
      })},
      FilterNotNullIterator: {value: Kotlin.createClass(classes.c1r, function $fun(iterator) {
        Object.defineProperty(this, 'iterator', {value: iterator});
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.FilterNotNullIterator.prototype */ {
        computeNext: {value: function () {
          if (this.iterator != null) {
            while (this.iterator.hasNext()) {
              var next = this.iterator.next();
              if (next != null) {
                this.setNext(next);
                return;
              }
            }
          }
          this.done();
        }, writable: true}
      })},
      MapIterator: {value: Kotlin.createClass(classes.c1r, function $fun(iterator, transform) {
        Object.defineProperty(this, 'iterator', {value: iterator});
        Object.defineProperty(this, 'transform', {value: transform});
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.MapIterator.prototype */ {
        computeNext: {value: function () {
          if (this.iterator.hasNext()) {
            this.setNext(this.transform(this.iterator.next()));
          }
           else {
            this.done();
          }
        }, writable: true}
      })},
      FlatMapIterator: {value: Kotlin.createClass(classes.c1r, function $fun(iterator, transform) {
        Object.defineProperty(this, 'iterator', {value: iterator});
        Object.defineProperty(this, 'transform', {value: transform});
        $fun.baseInitializer.call(this);
        Object.defineProperty(this, 'transformed', {value: _.kotlin.iterate(function () {
          return null;
        }), writable: true});
      }, /** @lends _.kotlin.FlatMapIterator.prototype */ {
        computeNext: {value: function () {
          while (true) {
            if (this.transformed.hasNext()) {
              this.setNext(this.transformed.next());
              return;
            }
            if (this.iterator.hasNext()) {
              this.transformed = this.transform(this.iterator.next());
            }
             else {
              this.done();
              return;
            }
          }
        }, writable: true}
      })},
      TakeWhileIterator: {value: Kotlin.createClass(classes.c1r, function $fun(iterator, predicate) {
        Object.defineProperty(this, 'iterator', {value: iterator});
        Object.defineProperty(this, 'predicate', {value: predicate});
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.TakeWhileIterator.prototype */ {
        computeNext: {value: function () {
          if (this.iterator.hasNext()) {
            var item = this.iterator.next();
            if (this.predicate(item)) {
              this.setNext(item);
              return;
            }
          }
          this.done();
        }, writable: true}
      })},
      FunctionIterator: {value: Kotlin.createClass(classes.c1r, function $fun(nextFunction) {
        Object.defineProperty(this, 'nextFunction', {value: nextFunction});
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.FunctionIterator.prototype */ {
        computeNext: {value: function () {
          var next = this.nextFunction();
          if (next == null) {
            this.done();
          }
           else {
            this.setNext(next);
          }
        }, writable: true}
      })},
      CompositeIterator: {value: Kotlin.createClass(classes.c1r, function $fun(iterators) {
        $fun.baseInitializer.call(this);
        Object.defineProperty(this, 'iteratorsIter', {value: Kotlin.arrayIterator(iterators)});
        Object.defineProperty(this, 'currentIter', {value: null, writable: true});
      }, /** @lends _.kotlin.CompositeIterator.prototype */ {
        computeNext: {value: function () {
          while (true) {
            if (this.currentIter == null) {
              if (this.iteratorsIter.hasNext()) {
                this.currentIter = this.iteratorsIter.next();
              }
               else {
                this.done();
                return;
              }
            }
            var iter = this.currentIter;
            if (iter != null) {
              if (iter.hasNext()) {
                this.setNext(iter.next());
                return;
              }
               else {
                this.currentIter = null;
              }
            }
          }
        }, writable: true}
      })},
      SingleIterator: {value: Kotlin.createClass(classes.c1r, function $fun(value) {
        Object.defineProperty(this, 'value', {value: value});
        $fun.baseInitializer.call(this);
        Object.defineProperty(this, 'first', {value: true, writable: true});
      }, /** @lends _.kotlin.SingleIterator.prototype */ {
        computeNext: {value: function () {
          if (this.first) {
            this.first = false;
            this.setNext(this.value);
          }
           else {
            this.done();
          }
        }, writable: true}
      })},
      IndexIterator: {value: Kotlin.createClass(Kotlin.Iterator, function (iterator) {
        Object.defineProperty(this, 'iterator', {value: iterator});
        Object.defineProperty(this, 'index', {value: 0, writable: true});
      }, /** @lends _.kotlin.IndexIterator.prototype */ {
        next: {value: function () {
          var tmp$0, tmp$1;
          return _.kotlin.Pair((tmp$0 = this.index, tmp$1 = tmp$0, this.index = tmp$0 + 1, tmp$1), this.iterator.next());
        }, writable: true},
        hasNext: {value: function () {
          return this.iterator.hasNext();
        }, writable: true}
      })},
      all_8: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_8: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_8: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_8: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_9: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_8($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_8: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_9: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_8($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_8: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_8: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_11: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_9($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_9: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_9: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_8($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_8: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_8: {value: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_8: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_7: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_8: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_7: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_8: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_8($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      fl: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_8: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fl);
            list.add(element);
          }
        }
        return result;
      }},
      drop_8: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_8($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_8: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_8($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_8: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      take_9: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_9($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_9: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_8($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_8: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_8: {value: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_8: {value: function ($receiver) {
        var list = _.kotlin.toCollection_8($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_8: {value: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, Kotlin.LinkedList());
      }},
      toList_8: {value: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, Kotlin.ArrayList(0));
      }},
      toSet_8: {value: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_8: {value: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, Kotlin.TreeSet());
      }},
      plus_29: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_8($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_30: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_8($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_31: {value: function ($receiver, collection) {
        return _.kotlin.plus_30($receiver, collection.iterator());
      }},
      withIndices_8: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      fm: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_8: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_8($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fm.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_8: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_8: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_8($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      trim: {value: function ($receiver, text) {
        return _.kotlin.trimTrailing(_.kotlin.trimLeading($receiver, text), text);
      }},
      trim_0: {value: function ($receiver, prefix, postfix) {
        return _.kotlin.trimTrailing(_.kotlin.trimLeading($receiver, prefix), postfix);
      }},
      trimLeading: {value: function ($receiver, prefix) {
        var answer = $receiver;
        if (answer.startsWith(prefix)) {
          answer = answer.substring(prefix.length);
        }
        return answer;
      }},
      trimTrailing: {value: function ($receiver, postfix) {
        var answer = $receiver;
        if (answer.endsWith(postfix)) {
          answer = answer.substring(0, $receiver.length - postfix.length);
        }
        return answer;
      }},
      isNotEmpty: {value: function ($receiver) {
        return $receiver != null && $receiver.length > 0;
      }},
      iterator_0: {value: function ($receiver) {
        return Kotlin.createObject(_.jet.CharIterator, function $fun() {
          $fun.baseInitializer.call(this);
          Object.defineProperty(this, 'index', {value: 0, writable: true, enumerable: true});
        }, {
          nextChar: {value: function () {
            var tmp$0, tmp$1;
            return $receiver.get((tmp$0 = this.index, tmp$1 = tmp$0, this.index = tmp$0 + 1, tmp$1));
          }, writable: true, enumerable: true},
          hasNext: {value: function () {
            return this.index < $receiver.length;
          }, writable: true, enumerable: true}
        });
      }},
      orEmpty_2: {value: function ($receiver) {
        return $receiver !== null ? $receiver : '';
      }},
      get_size: {value: function ($receiver) {
        return $receiver.length;
      }},
      count_9: {value: function ($receiver, predicate) {
        var answer = 0;
        {
          var tmp$0 = _.kotlin.iterator_0($receiver);
          while (tmp$0.hasNext()) {
            var c = tmp$0.next();
            if (predicate(c)) {
              answer++;
            }
          }
        }
        return answer;
      }},
      count_10: {value: function ($receiver) {
        if (Kotlin.isType($receiver, _.jet.Collection)) {
          return $receiver.size();
        }
        var number = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var elem = tmp$0.next();
            ++number;
          }
        }
        return number;
      }},
      fn: {value: function (count, n, it) {
        ++count.v;
        return count.v <= n;
      }},
      countTo: {value: function (n) {
        var count = {v: 0};
        return _.kotlin.fn.bind(null, count, n);
      }},
      first: {value: function ($receiver) {
        if (Kotlin.isType($receiver, _.jet.List)) {
          return _.kotlin.first($receiver);
        }
        return $receiver.iterator().next();
      }},
      containsItem: {value: function ($receiver, item) {
        if (Kotlin.isType($receiver, Kotlin.AbstractCollection)) {
          return $receiver.contains(item);
        }
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var elem = tmp$0.next();
            if (Kotlin.equals(elem, item)) {
              return true;
            }
          }
        }
        return false;
      }},
      sort: {value: function ($receiver) {
        var list = _.kotlin.toCollection($receiver, Kotlin.ArrayList(0));
        Kotlin.collectionsSort(list);
        return list;
      }},
      sort_0: {value: function ($receiver, comparator) {
        var list = _.kotlin.toCollection($receiver, Kotlin.ArrayList(0));
        Kotlin.collectionsSort(list, comparator);
        return list;
      }},
      all_9: {value: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_9: {value: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_11: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_9: {value: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filterTo_9: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNotTo_9: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNotNullTo_1: {value: function ($receiver, result) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null)
              result.add(element);
          }
        }
        return result;
      }},
      partition_9: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      mapTo_10: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMapTo_9: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_9: {value: function ($receiver, operation) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_9: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      reduce_9: {value: function ($receiver, operation) {
        var iterator = $receiver;
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      groupBy_9: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_9($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      fo: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_9: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fo);
            list.add(element);
          }
        }
        return result;
      }},
      drop_9: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_9($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_9: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_9($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_9: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      takeWhileTo_9: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_9: {value: function ($receiver, result) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_9: {value: function ($receiver) {
        var list = _.kotlin.toCollection_9($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_9: {value: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, Kotlin.LinkedList());
      }},
      toList_9: {value: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, Kotlin.ArrayList(0));
      }},
      toSet_9: {value: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_9: {value: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, Kotlin.TreeSet());
      }},
      withIndices_9: {value: function ($receiver) {
        return _.kotlin.IndexIterator($receiver);
      }},
      fp: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_9: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_9($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fp.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_9: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_9: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_9($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      isNotEmpty_1: {value: function ($receiver) {
        return !_.kotlin.isEmpty($receiver);
      }},
      isEmpty: {value: function ($receiver) {
        return $receiver.length === 0;
      }},
      orEmpty_3: {value: function ($receiver) {
        return $receiver != null ? $receiver : [];
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      iterator_1: {value: function ($receiver) {
        return Kotlin.createObject(Kotlin.Iterator, null, {
          hasNext: {value: function () {
            return $receiver.hasMoreElements();
          }, writable: true, enumerable: true},
          next: {value: function () {
            return $receiver.nextElement();
          }, writable: true, enumerable: true}
        });
      }},
      toArrayList: {value: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, Kotlin.ArrayList(0));
      }},
      toHashSet: {value: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, Kotlin.ComplexHashSet());
      }},
      to: {value: function ($receiver, that) {
        return _.kotlin.Pair($receiver, that);
      }},
      run: {value: function (f) {
        return f();
      }},
      with: {value: function (receiver, f) {
        return f(receiver);
      }},
      let: {value: function ($receiver, f) {
        return f($receiver);
      }},
      support: Kotlin.definePackage(function () {
        Object.defineProperty(this, 'State', {value: Kotlin.createObject(null, function () {
          Object.defineProperty(this, 'Ready', {value: 0});
          Object.defineProperty(this, 'NotReady', {value: 1});
          Object.defineProperty(this, 'Done', {value: 2});
          Object.defineProperty(this, 'Failed', {value: 3});
        })});
      }, {
        AbstractIterator: {value: classes.c1r}
      })
    }),
    org: Kotlin.definePackage(null, {
      kevoree: Kotlin.definePackage(null, {
        loader: Kotlin.definePackage(null, {
          XMIModelLoader: {value: Kotlin.createClass(classes.c6, function $fun() {
            $fun.baseInitializer.call(this);
            Object.defineProperty(this, 'factory', {value: _.org.kevoree.factory.MainFactory(), writable: true});
          })},
          JSONModelLoader: {value: Kotlin.createClass(classes.cb, function $fun() {
            $fun.baseInitializer.call(this);
            Object.defineProperty(this, 'factory', {value: _.org.kevoree.factory.MainFactory(), writable: true});
          })}
        }),
        DeployUnit: {value: classes.c0},
        ContainerNode: {value: classes.c1},
        MessagePortType: {value: classes.c2},
        GroupType: {value: classes.c3},
        NamedElement: {value: classes.cl},
        Wire: {value: classes.cm},
        LifeCycleTypeDefinition: {value: classes.cn},
        Repository: {value: classes.co},
        NetworkProperty: {value: classes.cp},
        ServicePortType: {value: classes.cq},
        ChannelType: {value: classes.cr},
        AdaptationPrimitiveTypeRef: {value: classes.cs},
        ContainerRoot: {value: classes.ct},
        Channel: {value: classes.cu},
        TypedElement: {value: classes.cw},
        Parameter: {value: classes.cx},
        NodeNetwork: {value: classes.cy},
        NodeLink: {value: classes.cz},
        MBinding: {value: classes.c10},
        PortType: {value: classes.c11},
        Operation: {value: classes.c12},
        Instance: {value: classes.c13},
        NodeType: {value: classes.c14},
        TypeDefinition: {value: classes.c15},
        PortTypeRef: {value: classes.c16},
        DictionaryAttribute: {value: classes.c17},
        CompositeType: {value: classes.c18},
        KevoreeFactory: {value: classes.c19},
        DictionaryValue: {value: classes.c1a},
        PortTypeMapping: {value: classes.c1b},
        Group: {value: classes.c1c},
        ExtraFonctionalProperty: {value: classes.c1d},
        DictionaryType: {value: classes.c1e},
        Namespace: {value: classes.c1f},
        ComponentType: {value: classes.c1g},
        AdaptationPrimitiveType: {value: classes.c1h},
        TypeLibrary: {value: classes.c1i},
        Port: {value: classes.c1j},
        IntegrationPattern: {value: classes.c1k},
        Dictionary: {value: classes.c1l},
        ComponentInstance: {value: classes.c1m},
        impl: Kotlin.definePackage(null, {
          CompositeTypeImpl: {value: Kotlin.createClass([classes.cv, classes.c18], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$factoryBean', {value: null, writable: true});
            Object.defineProperty(this, '$bean', {value: null, writable: true});
            Object.defineProperty(this, '$abstract', {value: null, writable: true});
            Object.defineProperty(this, '$startMethod', {value: null, writable: true});
            Object.defineProperty(this, '$stopMethod', {value: null, writable: true});
            Object.defineProperty(this, '$updateMethod', {value: null, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$dictionaryType', {value: null, writable: true});
            Object.defineProperty(this, '_superTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '_required', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllRequiredCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_integrationPatterns', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllIntegrationPatternsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '$extraFonctionalProperties', {value: null, writable: true});
            Object.defineProperty(this, '_provided', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllProvidedCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_childs', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '_wires', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllWiresCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.CompositeTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._required) != null ? tmp$2.clear() : null;
              (tmp$3 = this._integrationPatterns) != null ? tmp$3.clear() : null;
              this.extraFonctionalProperties = null;
              (tmp$4 = this._provided) != null ? tmp$4.clear() : null;
              (tmp$5 = this._childs) != null ? tmp$5.clear() : null;
              (tmp$6 = this._wires) != null ? tmp$6.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            }},
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            }},
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            }},
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            }},
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            }},
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            }},
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: {value: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            }},
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            doAddSuperTypes: {value: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            }},
            addSuperTypes: {value: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            }, writable: true},
            addAllSuperTypes: {value: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            }, writable: true},
            internal_addSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            internal_addAllSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            removeSuperTypes: {value: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            }, writable: true},
            removeAllSuperTypes: {value: function () {
              this.internal_removeAllSuperTypes(true, true);
            }, writable: true},
            internal_removeSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            internal_removeAllSuperTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            }},
            required: {
              get: function () {
                return _.kotlin.toList(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: {value: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            }},
            doAddRequired: {value: function (requiredP) {
              var _key_ = (requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey(_key_)) {
                this._required.put(_key_, requiredP);
                (requiredP != null ? requiredP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
              }
            }},
            addRequired: {value: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
            }, writable: true},
            addAllRequired: {value: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
            }, writable: true},
            internal_addRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            }},
            internal_addAllRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            }},
            removeRequired: {value: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
            }, writable: true},
            removeAllRequired: {value: function () {
              this.internal_removeAllRequired(true, true);
            }, writable: true},
            internal_removeRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey())) {
                this._required.remove((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey());
                ((requiredP != null ? requiredP : Kotlin.throwNPE()) != null ? requiredP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            }},
            internal_removeAllRequired: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.required) != null ? tmp$0 : Kotlin.throwNPE();
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            }},
            integrationPatterns: {
              get: function () {
                return _.kotlin.toList(this._integrationPatterns.values());
              },
              set: function (integrationPatternsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (integrationPatternsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_integrationPatterns(integrationPatternsP, true, true);
              }
            },
            internal_integrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._integrationPatterns.values(), integrationPatternsP)) {
                this._integrationPatterns.clear();
                {
                  var tmp$0 = integrationPatternsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._integrationPatterns.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_integrationPatterns, el), _.org.kevoree.util.Constants.Ref_integrationPatterns);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
                }
              }
            }},
            doAddIntegrationPatterns: {value: function (integrationPatternsP) {
              var _key_ = (integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._integrationPatterns.containsKey(_key_)) {
                this._integrationPatterns.put(_key_, integrationPatternsP);
                (integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP), _.org.kevoree.util.Constants.Ref_integrationPatterns);
              }
            }},
            addIntegrationPatterns: {value: function (integrationPatternsP) {
              this.internal_addIntegrationPatterns(integrationPatternsP, true, true);
            }, writable: true},
            addAllIntegrationPatterns: {value: function (integrationPatternsP) {
              this.internal_addAllIntegrationPatterns(integrationPatternsP, true, true);
            }, writable: true},
            internal_addIntegrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddIntegrationPatterns(integrationPatternsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
              }
            }},
            internal_addAllIntegrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = integrationPatternsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddIntegrationPatterns(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = integrationPatternsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddIntegrationPatterns(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
              }
            }},
            removeIntegrationPatterns: {value: function (integrationPatternsP) {
              this.internal_removeIntegrationPatterns(integrationPatternsP, true, true);
            }, writable: true},
            removeAllIntegrationPatterns: {value: function () {
              this.internal_removeAllIntegrationPatterns(true, true);
            }, writable: true},
            internal_removeIntegrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._integrationPatterns.size() !== 0 && this._integrationPatterns.containsKey((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey())) {
                this._integrationPatterns.remove((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey());
                ((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()) != null ? integrationPatternsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllIntegrationPatternsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
                }
              }
            }},
            internal_removeAllIntegrationPatterns: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllIntegrationPatternsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.integrationPatterns) != null ? tmp$0 : Kotlin.throwNPE();
              this._integrationPatterns.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, temp_els));
                this.removeAllIntegrationPatternsCurrentlyProcessing = false;
              }
            }},
            extraFonctionalProperties: {
              get: function () {
                return this.$extraFonctionalProperties;
              },
              set: function (extraFonctionalPropertiesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_extraFonctionalProperties(extraFonctionalPropertiesP, true, true);
              }
            },
            internal_extraFonctionalProperties: {value: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$extraFonctionalProperties, extraFonctionalPropertiesP)) {
                if (this.$extraFonctionalProperties != null) {
                  var tmp$0;
                  (((tmp$0 = this.$extraFonctionalProperties) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (extraFonctionalPropertiesP != null) {
                  (extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                }
                this.$extraFonctionalProperties = extraFonctionalPropertiesP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
                }
              }
            }},
            provided: {
              get: function () {
                return _.kotlin.toList(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: {value: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            }},
            doAddProvided: {value: function (providedP) {
              var _key_ = (providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey(_key_)) {
                this._provided.put(_key_, providedP);
                (providedP != null ? providedP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
              }
            }},
            addProvided: {value: function (providedP) {
              this.internal_addProvided(providedP, true, true);
            }, writable: true},
            addAllProvided: {value: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
            }, writable: true},
            internal_addProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            }},
            internal_addAllProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            }},
            removeProvided: {value: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
            }, writable: true},
            removeAllProvided: {value: function () {
              this.internal_removeAllProvided(true, true);
            }, writable: true},
            internal_removeProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey())) {
                this._provided.remove((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey());
                ((providedP != null ? providedP : Kotlin.throwNPE()) != null ? providedP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            }},
            internal_removeAllProvided: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.provided) != null ? tmp$0 : Kotlin.throwNPE();
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            }},
            childs: {
              get: function () {
                return _.kotlin.toList(this._childs.values());
              },
              set: function (childsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (childsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_childs(childsP, true, true);
              }
            },
            internal_childs: {value: function (childsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._childs.values(), childsP)) {
                this._childs.clear();
                {
                  var tmp$0 = childsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._childs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, childsP));
                }
              }
            }},
            doAddChilds: {value: function (childsP) {
              var _key_ = (childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._childs.containsKey(_key_)) {
                this._childs.put(_key_, childsP);
              }
            }},
            addChilds: {value: function (childsP) {
              this.internal_addChilds(childsP, true, true);
            }, writable: true},
            addAllChilds: {value: function (childsP) {
              this.internal_addAllChilds(childsP, true, true);
            }, writable: true},
            internal_addChilds: {value: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddChilds(childsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, childsP));
              }
            }},
            internal_addAllChilds: {value: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = childsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddChilds(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = childsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddChilds(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, childsP));
              }
            }},
            removeChilds: {value: function (childsP) {
              this.internal_removeChilds(childsP, true, true);
            }, writable: true},
            removeAllChilds: {value: function () {
              this.internal_removeAllChilds(true, true);
            }, writable: true},
            internal_removeChilds: {value: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._childs.size() !== 0 && this._childs.containsKey((childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey())) {
                this._childs.remove((childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, childsP));
                }
              }
            }},
            internal_removeAllChilds: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.childs) != null ? tmp$0 : Kotlin.throwNPE();
              this._childs.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, temp_els));
              }
            }},
            wires: {
              get: function () {
                return _.kotlin.toList(this._wires.values());
              },
              set: function (wiresP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (wiresP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_wires(wiresP, true, true);
              }
            },
            internal_wires: {value: function (wiresP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._wires.values(), wiresP)) {
                this._wires.clear();
                {
                  var tmp$0 = wiresP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._wires.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_wires, el), _.org.kevoree.util.Constants.Ref_wires);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, wiresP));
                }
              }
            }},
            doAddWires: {value: function (wiresP) {
              var _key_ = (wiresP != null ? wiresP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._wires.containsKey(_key_)) {
                this._wires.put(_key_, wiresP);
                (wiresP != null ? wiresP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_wires, wiresP), _.org.kevoree.util.Constants.Ref_wires);
              }
            }},
            addWires: {value: function (wiresP) {
              this.internal_addWires(wiresP, true, true);
            }, writable: true},
            addAllWires: {value: function (wiresP) {
              this.internal_addAllWires(wiresP, true, true);
            }, writable: true},
            internal_addWires: {value: function (wiresP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddWires(wiresP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, wiresP));
              }
            }},
            internal_addAllWires: {value: function (wiresP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = wiresP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddWires(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = wiresP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddWires(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, wiresP));
              }
            }},
            removeWires: {value: function (wiresP) {
              this.internal_removeWires(wiresP, true, true);
            }, writable: true},
            removeAllWires: {value: function () {
              this.internal_removeAllWires(true, true);
            }, writable: true},
            internal_removeWires: {value: function (wiresP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._wires.size() !== 0 && this._wires.containsKey((wiresP != null ? wiresP : Kotlin.throwNPE()).internalGetKey())) {
                this._wires.remove((wiresP != null ? wiresP : Kotlin.throwNPE()).internalGetKey());
                ((wiresP != null ? wiresP : Kotlin.throwNPE()) != null ? wiresP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllWiresCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, wiresP));
                }
              }
            }},
            internal_removeAllWires: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllWiresCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.wires) != null ? tmp$0 : Kotlin.throwNPE();
              this._wires.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, temp_els));
                this.removeAllWiresCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRequired();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._required.size() !== 0 && this._required.containsKey(value)) {
                    var obj_1 = this._required.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._required.remove(value);
                    this._required.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_integrationPatterns) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllIntegrationPatterns();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._integrationPatterns.size() !== 0 && this._integrationPatterns.containsKey(value)) {
                    var obj_2 = this._integrationPatterns.get(value);
                    var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_2 == null) {
                      throw new Error('Key newed to null ' + obj_2);
                    }
                    this._integrationPatterns.remove(value);
                    this._integrationPatterns.put(objNewKey_2, obj_2);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_extraFonctionalProperties(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_extraFonctionalProperties(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_extraFonctionalProperties(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllProvided();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._provided.size() !== 0 && this._provided.containsKey(value)) {
                    var obj_3 = this._provided.get(value);
                    var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_3 == null) {
                      throw new Error('Key newed to null ' + obj_3);
                    }
                    this._provided.remove(value);
                    this._provided.put(objNewKey_3, obj_3);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_childs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllChilds();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._childs.size() !== 0 && this._childs.containsKey(value)) {
                    var obj_4 = this._childs.get(value);
                    var objNewKey_4 = (obj_4 != null ? obj_4 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_4 == null) {
                      throw new Error('Key newed to null ' + obj_4);
                    }
                    this._childs.remove(value);
                    this._childs.put(objNewKey_4, obj_4);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_wires) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addWires(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllWires(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeWires(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllWires();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._wires.size() !== 0 && this._wires.containsKey(value)) {
                    var obj_5 = this._wires.get(value);
                    var objNewKey_5 = (obj_5 != null ? obj_5 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_5 == null) {
                      throw new Error('Key newed to null ' + obj_5);
                    }
                    this._wires.remove(value);
                    this._wires.put(objNewKey_5, obj_5);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findSuperTypesByID: {value: function (key) {
              return this._superTypes.get(key);
            }, writable: true},
            findRequiredByID: {value: function (key) {
              return this._required.get(key);
            }, writable: true},
            findIntegrationPatternsByID: {value: function (key) {
              return this._integrationPatterns.get(key);
            }, writable: true},
            findProvidedByID: {value: function (key) {
              return this._provided.get(key);
            }, writable: true},
            findChildsByID: {value: function (key) {
              return this._childs.get(key);
            }, writable: true},
            findWiresByID: {value: function (key) {
              return this._wires.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                return this.findRequiredByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_integrationPatterns) {
                return this.findIntegrationPatternsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                var objFound_0 = this.extraFonctionalProperties;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                return this.findProvidedByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_childs) {
                return this.findChildsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_wires) {
                return this.findWiresByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$0 = this._required.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._required.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_integrationPatterns, _.org.kevoree.util.Constants.org_kevoree_IntegrationPattern);
                {
                  var tmp$1 = this._integrationPatterns.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._integrationPatterns.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_integrationPatterns);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_integrationPatterns);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties, _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty);
                this.internal_visit(visitor, this.extraFonctionalProperties, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$2 = this._provided.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._provided.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_wires, _.org.kevoree.util.Constants.org_kevoree_Wire);
                {
                  var tmp$3 = this._wires.keySet().iterator();
                  while (tmp$3.hasNext()) {
                    var KMFLoopEntryKey_2 = tmp$3.next();
                    this.internal_visit(visitor, this._wires.get(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_wires);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_wires);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$4 = this._deployUnits.keySet().iterator();
                  while (tmp$4.hasNext()) {
                    var KMFLoopEntryKey_3 = tmp$4.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$5 = this._superTypes.keySet().iterator();
                  while (tmp$5.hasNext()) {
                    var KMFLoopEntryKey_4 = tmp$5.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_4), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_childs, _.org.kevoree.util.Constants.org_kevoree_ComponentType);
                {
                  var tmp$6 = this._childs.keySet().iterator();
                  while (tmp$6.hasNext()) {
                    var KMFLoopEntryKey_5 = tmp$6.next();
                    this.internal_visit(visitor, this._childs.get(KMFLoopEntryKey_5), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_childs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_childs);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_CompositeType;
            }, writable: true}
          })},
          DictionaryTypeImpl: {value: Kotlin.createClass([classes.cv, classes.c1e], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_attributes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllAttributesCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_defaultValues', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllDefaultValuesCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.DictionaryTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1;
              (tmp$0 = this._attributes) != null ? tmp$0.clear() : null;
              (tmp$1 = this._defaultValues) != null ? tmp$1.clear() : null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            attributes: {
              get: function () {
                return _.kotlin.toList(this._attributes.values());
              },
              set: function (attributesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (attributesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_attributes(attributesP, true, true);
              }
            },
            internal_attributes: {value: function (attributesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._attributes.values(), attributesP)) {
                this._attributes.clear();
                {
                  var tmp$0 = attributesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._attributes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_attributes, el), _.org.kevoree.util.Constants.Ref_attributes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP));
                }
              }
            }},
            doAddAttributes: {value: function (attributesP) {
              var _key_ = (attributesP != null ? attributesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._attributes.containsKey(_key_)) {
                this._attributes.put(_key_, attributesP);
                (attributesP != null ? attributesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_attributes, attributesP), _.org.kevoree.util.Constants.Ref_attributes);
              }
            }},
            addAttributes: {value: function (attributesP) {
              this.internal_addAttributes(attributesP, true, true);
            }, writable: true},
            addAllAttributes: {value: function (attributesP) {
              this.internal_addAllAttributes(attributesP, true, true);
            }, writable: true},
            internal_addAttributes: {value: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddAttributes(attributesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP));
              }
            }},
            internal_addAllAttributes: {value: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = attributesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddAttributes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = attributesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddAttributes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP));
              }
            }},
            removeAttributes: {value: function (attributesP) {
              this.internal_removeAttributes(attributesP, true, true);
            }, writable: true},
            removeAllAttributes: {value: function () {
              this.internal_removeAllAttributes(true, true);
            }, writable: true},
            internal_removeAttributes: {value: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._attributes.size() !== 0 && this._attributes.containsKey((attributesP != null ? attributesP : Kotlin.throwNPE()).internalGetKey())) {
                this._attributes.remove((attributesP != null ? attributesP : Kotlin.throwNPE()).internalGetKey());
                ((attributesP != null ? attributesP : Kotlin.throwNPE()) != null ? attributesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllAttributesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP));
                }
              }
            }},
            internal_removeAllAttributes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllAttributesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.attributes) != null ? tmp$0 : Kotlin.throwNPE();
              this._attributes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, temp_els));
                this.removeAllAttributesCurrentlyProcessing = false;
              }
            }},
            defaultValues: {
              get: function () {
                return _.kotlin.toList(this._defaultValues.values());
              },
              set: function (defaultValuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (defaultValuesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_defaultValues(defaultValuesP, true, true);
              }
            },
            internal_defaultValues: {value: function (defaultValuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._defaultValues.values(), defaultValuesP)) {
                this._defaultValues.clear();
                {
                  var tmp$0 = defaultValuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._defaultValues.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_defaultValues, el), _.org.kevoree.util.Constants.Ref_defaultValues);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP));
                }
              }
            }},
            doAddDefaultValues: {value: function (defaultValuesP) {
              var _key_ = (defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._defaultValues.containsKey(_key_)) {
                this._defaultValues.put(_key_, defaultValuesP);
                (defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP), _.org.kevoree.util.Constants.Ref_defaultValues);
              }
            }},
            addDefaultValues: {value: function (defaultValuesP) {
              this.internal_addDefaultValues(defaultValuesP, true, true);
            }, writable: true},
            addAllDefaultValues: {value: function (defaultValuesP) {
              this.internal_addAllDefaultValues(defaultValuesP, true, true);
            }, writable: true},
            internal_addDefaultValues: {value: function (defaultValuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDefaultValues(defaultValuesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP));
              }
            }},
            internal_addAllDefaultValues: {value: function (defaultValuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = defaultValuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDefaultValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = defaultValuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDefaultValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP));
              }
            }},
            removeDefaultValues: {value: function (defaultValuesP) {
              this.internal_removeDefaultValues(defaultValuesP, true, true);
            }, writable: true},
            removeAllDefaultValues: {value: function () {
              this.internal_removeAllDefaultValues(true, true);
            }, writable: true},
            internal_removeDefaultValues: {value: function (defaultValuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._defaultValues.size() !== 0 && this._defaultValues.containsKey((defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()).internalGetKey())) {
                this._defaultValues.remove((defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()).internalGetKey());
                ((defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()) != null ? defaultValuesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllDefaultValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP));
                }
              }
            }},
            internal_removeAllDefaultValues: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllDefaultValuesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.defaultValues) != null ? tmp$0 : Kotlin.throwNPE();
              this._defaultValues.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, temp_els));
                this.removeAllDefaultValuesCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_attributes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllAttributes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._attributes.size() !== 0 && this._attributes.containsKey(value)) {
                    var obj = this._attributes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._attributes.remove(value);
                    this._attributes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_defaultValues) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDefaultValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDefaultValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDefaultValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDefaultValues();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._defaultValues.size() !== 0 && this._defaultValues.containsKey(value)) {
                    var obj_0 = this._defaultValues.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._defaultValues.remove(value);
                    this._defaultValues.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findAttributesByID: {value: function (key) {
              return this._attributes.get(key);
            }, writable: true},
            findDefaultValuesByID: {value: function (key) {
              return this._defaultValues.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_attributes) {
                return this.findAttributesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_defaultValues) {
                return this.findDefaultValuesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_attributes, _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute);
                {
                  var tmp$0 = this._attributes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._attributes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_attributes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_attributes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_defaultValues, _.org.kevoree.util.Constants.org_kevoree_DictionaryValue);
                {
                  var tmp$1 = this._defaultValues.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._defaultValues.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_defaultValues);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_defaultValues);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryType;
            }, writable: true}
          })},
          ChannelImpl: {value: Kotlin.createClass([classes.cv, classes.cu], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$metaData', {value: null, writable: true});
            Object.defineProperty(this, '$started', {value: true, writable: true});
            Object.defineProperty(this, '$typeDefinition', {value: null, writable: true});
            Object.defineProperty(this, '$dictionary', {value: null, writable: true});
            Object.defineProperty(this, '_bindings', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.ChannelImpl.prototype */ {
            delete: {value: function () {
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$0;
              (tmp$0 = this._bindings) != null ? tmp$0.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            }},
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            }},
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: {value: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            }},
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: {value: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            }},
            bindings: {
              get: function () {
                return _.kotlin.toList(this._bindings.values());
              },
              set: function (bindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (bindingsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_bindings(bindingsP, true, true);
              }
            },
            internal_bindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._bindings.values(), bindingsP)) {
                this.internal_removeAllBindings(true, false);
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._bindings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
                }
              }
            }},
            doAddBindings: {value: function (bindingsP) {
              var _key_ = (bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._bindings.containsKey(_key_)) {
                this._bindings.put(_key_, bindingsP);
              }
            }},
            addBindings: {value: function (bindingsP) {
              this.internal_addBindings(bindingsP, true, true);
            }, writable: true},
            addAllBindings: {value: function (bindingsP) {
              this.internal_addAllBindings(bindingsP, true, true);
            }, writable: true},
            internal_addBindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddBindings(bindingsP);
              if (setOpposite) {
                (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
              }
            }},
            internal_addAllBindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddBindings(el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = bindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
              }
            }},
            removeBindings: {value: function (bindingsP) {
              this.internal_removeBindings(bindingsP, true, true);
            }, writable: true},
            removeAllBindings: {value: function () {
              this.internal_removeAllBindings(true, true);
            }, writable: true},
            internal_removeBindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._bindings.size() !== 0 && this._bindings.containsKey((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._bindings.remove((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
                }
                if (setOpposite) {
                  (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, null, false, fireEvents);
                }
              }
            }},
            internal_removeAllBindings: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.bindings) != null ? tmp$0 : Kotlin.throwNPE();
              if (setOpposite) {
                {
                  var tmp$1 = (temp_els != null ? temp_els : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var el = tmp$1.next();
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, null, false, fireEvents);
                  }
                }
              }
              this._bindings.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_bindings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.internal_removeAllBindings(setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._bindings.size() !== 0 && this._bindings.containsKey(value)) {
                    var obj = this._bindings.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._bindings.remove(value);
                    this._bindings.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findBindingsByID: {value: function (key) {
              return this._bindings.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_bindings) {
                return this.findBindingsByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_bindings, _.org.kevoree.util.Constants.org_kevoree_MBinding);
                {
                  var tmp$0 = this._bindings.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._bindings.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_bindings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_bindings);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Channel;
            }, writable: true}
          })},
          NamespaceImpl: {value: Kotlin.createClass([classes.cv, classes.c1f], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '_childs', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllChildsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '$parent', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.NamespaceImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._childs) != null ? tmp$0.clear() : null;
              this.parent = null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            childs: {
              get: function () {
                return _.kotlin.toList(this._childs.values());
              },
              set: function (childsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (childsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_childs(childsP, true, true);
              }
            },
            internal_childs: {value: function (childsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._childs.values(), childsP)) {
                this._childs.clear();
                {
                  var tmp$0 = childsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._childs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_childs, el), _.org.kevoree.util.Constants.Ref_childs);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, childsP));
                }
              }
            }},
            doAddChilds: {value: function (childsP) {
              var _key_ = (childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._childs.containsKey(_key_)) {
                this._childs.put(_key_, childsP);
                (childsP != null ? childsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_childs, childsP), _.org.kevoree.util.Constants.Ref_childs);
              }
            }},
            addChilds: {value: function (childsP) {
              this.internal_addChilds(childsP, true, true);
            }, writable: true},
            addAllChilds: {value: function (childsP) {
              this.internal_addAllChilds(childsP, true, true);
            }, writable: true},
            internal_addChilds: {value: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddChilds(childsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, childsP));
              }
            }},
            internal_addAllChilds: {value: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = childsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddChilds(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = childsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddChilds(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, childsP));
              }
            }},
            removeChilds: {value: function (childsP) {
              this.internal_removeChilds(childsP, true, true);
            }, writable: true},
            removeAllChilds: {value: function () {
              this.internal_removeAllChilds(true, true);
            }, writable: true},
            internal_removeChilds: {value: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._childs.size() !== 0 && this._childs.containsKey((childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey())) {
                this._childs.remove((childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey());
                ((childsP != null ? childsP : Kotlin.throwNPE()) != null ? childsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllChildsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, childsP));
                }
              }
            }},
            internal_removeAllChilds: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllChildsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.childs) != null ? tmp$0 : Kotlin.throwNPE();
              this._childs.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, temp_els));
                this.removeAllChildsCurrentlyProcessing = false;
              }
            }},
            parent: {
              get: function () {
                return this.$parent;
              },
              set: function (parentP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_parent(parentP, true, true);
              }
            },
            internal_parent: {value: function (parentP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$parent, parentP)) {
                this.$parent = parentP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_parent, parentP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_childs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllChilds();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._childs.size() !== 0 && this._childs.containsKey(value)) {
                    var obj = this._childs.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._childs.remove(value);
                    this._childs.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_parent) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_parent(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_parent(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_parent(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findChildsByID: {value: function (key) {
              return this._childs.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_childs) {
                return this.findChildsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_parent) {
                var objFound = this.parent;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_childs, _.org.kevoree.util.Constants.org_kevoree_Namespace);
                {
                  var tmp$0 = this._childs.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._childs.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_childs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_childs);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_parent, _.org.kevoree.util.Constants.org_kevoree_Namespace);
                this.internal_visit(visitor, this.parent, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_parent);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_parent);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Namespace;
            }, writable: true}
          })},
          ContainerNodeImpl: {value: Kotlin.createClass([classes.cv, classes.c1], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$metaData', {value: null, writable: true});
            Object.defineProperty(this, '$started', {value: true, writable: true});
            Object.defineProperty(this, '$typeDefinition', {value: null, writable: true});
            Object.defineProperty(this, '$dictionary', {value: null, writable: true});
            Object.defineProperty(this, '_components', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllComponentsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_hosts', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$host', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.ContainerNodeImpl.prototype */ {
            delete: {value: function () {
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$0, tmp$1;
              (tmp$0 = this._components) != null ? tmp$0.clear() : null;
              (tmp$1 = this._hosts) != null ? tmp$1.clear() : null;
              this.host = null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            }},
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            }},
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: {value: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            }},
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: {value: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            }},
            components: {
              get: function () {
                return _.kotlin.toList(this._components.values());
              },
              set: function (componentsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (componentsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_components(componentsP, true, true);
              }
            },
            internal_components: {value: function (componentsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._components.values(), componentsP)) {
                this._components.clear();
                {
                  var tmp$0 = componentsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._components.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_components, el), _.org.kevoree.util.Constants.Ref_components);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP));
                }
              }
            }},
            doAddComponents: {value: function (componentsP) {
              var _key_ = (componentsP != null ? componentsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._components.containsKey(_key_)) {
                this._components.put(_key_, componentsP);
                (componentsP != null ? componentsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_components, componentsP), _.org.kevoree.util.Constants.Ref_components);
              }
            }},
            addComponents: {value: function (componentsP) {
              this.internal_addComponents(componentsP, true, true);
            }, writable: true},
            addAllComponents: {value: function (componentsP) {
              this.internal_addAllComponents(componentsP, true, true);
            }, writable: true},
            internal_addComponents: {value: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddComponents(componentsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP));
              }
            }},
            internal_addAllComponents: {value: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = componentsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddComponents(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = componentsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddComponents(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP));
              }
            }},
            removeComponents: {value: function (componentsP) {
              this.internal_removeComponents(componentsP, true, true);
            }, writable: true},
            removeAllComponents: {value: function () {
              this.internal_removeAllComponents(true, true);
            }, writable: true},
            internal_removeComponents: {value: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._components.size() !== 0 && this._components.containsKey((componentsP != null ? componentsP : Kotlin.throwNPE()).internalGetKey())) {
                this._components.remove((componentsP != null ? componentsP : Kotlin.throwNPE()).internalGetKey());
                ((componentsP != null ? componentsP : Kotlin.throwNPE()) != null ? componentsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllComponentsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP));
                }
              }
            }},
            internal_removeAllComponents: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllComponentsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.components) != null ? tmp$0 : Kotlin.throwNPE();
              this._components.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, temp_els));
                this.removeAllComponentsCurrentlyProcessing = false;
              }
            }},
            hosts: {
              get: function () {
                return _.kotlin.toList(this._hosts.values());
              },
              set: function (hostsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (hostsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_hosts(hostsP, true, true);
              }
            },
            internal_hosts: {value: function (hostsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._hosts.values(), hostsP)) {
                this.internal_removeAllHosts(true, false);
                {
                  var tmp$0 = hostsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._hosts.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP));
                }
              }
            }},
            doAddHosts: {value: function (hostsP) {
              var _key_ = (hostsP != null ? hostsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._hosts.containsKey(_key_)) {
                this._hosts.put(_key_, hostsP);
              }
            }},
            addHosts: {value: function (hostsP) {
              this.internal_addHosts(hostsP, true, true);
            }, writable: true},
            addAllHosts: {value: function (hostsP) {
              this.internal_addAllHosts(hostsP, true, true);
            }, writable: true},
            internal_addHosts: {value: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddHosts(hostsP);
              if (setOpposite) {
                (hostsP != null ? hostsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP));
              }
            }},
            internal_addAllHosts: {value: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = hostsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddHosts(el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = hostsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddHosts(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP));
              }
            }},
            removeHosts: {value: function (hostsP) {
              this.internal_removeHosts(hostsP, true, true);
            }, writable: true},
            removeAllHosts: {value: function () {
              this.internal_removeAllHosts(true, true);
            }, writable: true},
            internal_removeHosts: {value: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._hosts.size() !== 0 && this._hosts.containsKey((hostsP != null ? hostsP : Kotlin.throwNPE()).internalGetKey())) {
                this._hosts.remove((hostsP != null ? hostsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP));
                }
                if (setOpposite) {
                  (hostsP != null ? hostsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, null, false, fireEvents);
                }
              }
            }},
            internal_removeAllHosts: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.hosts) != null ? tmp$0 : Kotlin.throwNPE();
              if (setOpposite) {
                {
                  var tmp$1 = (temp_els != null ? temp_els : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var el = tmp$1.next();
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, null, false, fireEvents);
                  }
                }
              }
              this._hosts.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, temp_els));
              }
            }},
            host: {
              get: function () {
                return this.$host;
              },
              set: function (hostP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_host(hostP, true, true);
              }
            },
            internal_host: {value: function (hostP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$host, hostP)) {
                if (setOpposite) {
                  if (this.$host != null) {
                    var tmp$0;
                    ((tmp$0 = this.$host) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_hosts, this, false, fireEvents);
                  }
                  if (hostP != null) {
                    hostP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.util.Constants.Ref_hosts, this, false, fireEvents);
                  }
                }
                this.$host = hostP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_host, hostP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_components) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllComponents();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._components.size() !== 0 && this._components.containsKey(value)) {
                    var obj = this._components.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._components.remove(value);
                    this._components.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_hosts) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.internal_removeAllHosts(setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._hosts.size() !== 0 && this._hosts.containsKey(value)) {
                    var obj_0 = this._hosts.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._hosts.remove(value);
                    this._hosts.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_host) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_host(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_host(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_host(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findComponentsByID: {value: function (key) {
              return this._components.get(key);
            }, writable: true},
            findHostsByID: {value: function (key) {
              return this._hosts.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_components) {
                return this.findComponentsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_hosts) {
                return this.findHostsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_host) {
                var objFound_1 = this.host;
                if (objFound_1 != null && Kotlin.equals((objFound_1 != null ? objFound_1 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_1;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_components, _.org.kevoree.util.Constants.org_kevoree_ComponentInstance);
                {
                  var tmp$0 = this._components.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._components.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_components);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_components);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hosts, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                {
                  var tmp$1 = this._hosts.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._hosts.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hosts);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hosts);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_host, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.host, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_host);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_host);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ContainerNode;
            }, writable: true}
          })},
          ComponentInstanceImpl: {value: Kotlin.createClass([classes.cv, classes.c1m], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$metaData', {value: null, writable: true});
            Object.defineProperty(this, '$started', {value: true, writable: true});
            Object.defineProperty(this, '$typeDefinition', {value: null, writable: true});
            Object.defineProperty(this, '$dictionary', {value: null, writable: true});
            Object.defineProperty(this, '_provided', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllProvidedCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_required', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllRequiredCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '$namespace', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.ComponentInstanceImpl.prototype */ {
            delete: {value: function () {
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$0, tmp$1;
              (tmp$0 = this._provided) != null ? tmp$0.clear() : null;
              (tmp$1 = this._required) != null ? tmp$1.clear() : null;
              this.namespace = null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            }},
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            }},
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: {value: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            }},
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: {value: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            }},
            provided: {
              get: function () {
                return _.kotlin.toList(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: {value: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            }},
            doAddProvided: {value: function (providedP) {
              var _key_ = (providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey(_key_)) {
                this._provided.put(_key_, providedP);
                (providedP != null ? providedP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
              }
            }},
            addProvided: {value: function (providedP) {
              this.internal_addProvided(providedP, true, true);
            }, writable: true},
            addAllProvided: {value: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
            }, writable: true},
            internal_addProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            }},
            internal_addAllProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            }},
            removeProvided: {value: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
            }, writable: true},
            removeAllProvided: {value: function () {
              this.internal_removeAllProvided(true, true);
            }, writable: true},
            internal_removeProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey())) {
                this._provided.remove((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey());
                ((providedP != null ? providedP : Kotlin.throwNPE()) != null ? providedP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            }},
            internal_removeAllProvided: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.provided) != null ? tmp$0 : Kotlin.throwNPE();
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            }},
            required: {
              get: function () {
                return _.kotlin.toList(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: {value: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            }},
            doAddRequired: {value: function (requiredP) {
              var _key_ = (requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey(_key_)) {
                this._required.put(_key_, requiredP);
                (requiredP != null ? requiredP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
              }
            }},
            addRequired: {value: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
            }, writable: true},
            addAllRequired: {value: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
            }, writable: true},
            internal_addRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            }},
            internal_addAllRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            }},
            removeRequired: {value: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
            }, writable: true},
            removeAllRequired: {value: function () {
              this.internal_removeAllRequired(true, true);
            }, writable: true},
            internal_removeRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey())) {
                this._required.remove((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey());
                ((requiredP != null ? requiredP : Kotlin.throwNPE()) != null ? requiredP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            }},
            internal_removeAllRequired: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.required) != null ? tmp$0 : Kotlin.throwNPE();
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            }},
            namespace: {
              get: function () {
                return this.$namespace;
              },
              set: function (namespaceP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_namespace(namespaceP, true, true);
              }
            },
            internal_namespace: {value: function (namespaceP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$namespace, namespaceP)) {
                this.$namespace = namespaceP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_namespace, namespaceP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllProvided();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._provided.size() !== 0 && this._provided.containsKey(value)) {
                    var obj = this._provided.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._provided.remove(value);
                    this._provided.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRequired();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._required.size() !== 0 && this._required.containsKey(value)) {
                    var obj_0 = this._required.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._required.remove(value);
                    this._required.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_namespace) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_namespace(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_namespace(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_namespace(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findProvidedByID: {value: function (key) {
              return this._provided.get(key);
            }, writable: true},
            findRequiredByID: {value: function (key) {
              return this._required.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                return this.findProvidedByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                return this.findRequiredByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_namespace) {
                var objFound_1 = this.namespace;
                if (objFound_1 != null && Kotlin.equals((objFound_1 != null ? objFound_1 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_1;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_Port);
                {
                  var tmp$0 = this._provided.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._provided.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_Port);
                {
                  var tmp$1 = this._required.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._required.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_namespace, _.org.kevoree.util.Constants.org_kevoree_Namespace);
                this.internal_visit(visitor, this.namespace, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_namespace);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_namespace);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ComponentInstance;
            }, writable: true}
          })},
          MessagePortTypeImpl: {value: Kotlin.createClass([classes.cv, classes.c2], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$factoryBean', {value: null, writable: true});
            Object.defineProperty(this, '$bean', {value: null, writable: true});
            Object.defineProperty(this, '$abstract', {value: null, writable: true});
            Object.defineProperty(this, '$synchrone', {value: null, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$dictionaryType', {value: null, writable: true});
            Object.defineProperty(this, '_superTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '_filters', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.MessagePortTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1, tmp$2;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._filters) != null ? tmp$2.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            }},
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            }},
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            }},
            synchrone: {
              get: function () {
                return this.$synchrone;
              },
              set: function (iP) {
                this.internal_synchrone(iP, true);
              }
            },
            internal_synchrone: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.synchrone)) {
                var oldPath = this.path();
                this.$synchrone = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_synchrone, this.synchrone));
                }
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            }},
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: {value: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            }},
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            doAddSuperTypes: {value: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            }},
            addSuperTypes: {value: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            }, writable: true},
            addAllSuperTypes: {value: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            }, writable: true},
            internal_addSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            internal_addAllSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            removeSuperTypes: {value: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            }, writable: true},
            removeAllSuperTypes: {value: function () {
              this.internal_removeAllSuperTypes(true, true);
            }, writable: true},
            internal_removeSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            internal_removeAllSuperTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            }},
            filters: {
              get: function () {
                return _.kotlin.toList(this._filters.values());
              },
              set: function (filtersP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (filtersP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_filters(filtersP, true, true);
              }
            },
            internal_filters: {value: function (filtersP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._filters.values(), filtersP)) {
                this._filters.clear();
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._filters.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP));
                }
              }
            }},
            doAddFilters: {value: function (filtersP) {
              var _key_ = (filtersP != null ? filtersP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._filters.containsKey(_key_)) {
                this._filters.put(_key_, filtersP);
              }
            }},
            addFilters: {value: function (filtersP) {
              this.internal_addFilters(filtersP, true, true);
            }, writable: true},
            addAllFilters: {value: function (filtersP) {
              this.internal_addAllFilters(filtersP, true, true);
            }, writable: true},
            internal_addFilters: {value: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFilters(filtersP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP));
              }
            }},
            internal_addAllFilters: {value: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFilters(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = filtersP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFilters(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP));
              }
            }},
            removeFilters: {value: function (filtersP) {
              this.internal_removeFilters(filtersP, true, true);
            }, writable: true},
            removeAllFilters: {value: function () {
              this.internal_removeAllFilters(true, true);
            }, writable: true},
            internal_removeFilters: {value: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._filters.size() !== 0 && this._filters.containsKey((filtersP != null ? filtersP : Kotlin.throwNPE()).internalGetKey())) {
                this._filters.remove((filtersP != null ? filtersP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP));
                }
              }
            }},
            internal_removeAllFilters: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.filters) != null ? tmp$0 : Kotlin.throwNPE();
              this._filters.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_synchrone) {
                this.internal_synchrone(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_filters) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllFilters();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._filters.size() !== 0 && this._filters.containsKey(value)) {
                    var obj_1 = this._filters.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._filters.remove(value);
                    this._filters.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findSuperTypesByID: {value: function (key) {
              return this._superTypes.get(key);
            }, writable: true},
            findFiltersByID: {value: function (key) {
              return this._filters.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_filters) {
                return this.findFiltersByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._deployUnits.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$1 = this._superTypes.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_filters, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$2 = this._filters.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._filters.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_filters);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_filters);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.synchrone, _.org.kevoree.util.Constants.Att_synchrone, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_MessagePortType;
            }, writable: true}
          })},
          ParameterImpl: {value: Kotlin.createClass([classes.cv, classes.cx], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$order', {value: null, writable: true});
            Object.defineProperty(this, '$type', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.ParameterImpl.prototype */ {
            delete: {value: function () {
              this.type = null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            order: {
              get: function () {
                return this.$order;
              },
              set: function (iP) {
                this.internal_order(iP, true);
              }
            },
            internal_order: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.order) {
                var oldPath = this.path();
                this.$order = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_order, this.order));
                }
              }
            }},
            type: {
              get: function () {
                return this.$type;
              },
              set: function (typeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_type(typeP, true, true);
              }
            },
            internal_type: {value: function (typeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$type, typeP)) {
                this.$type = typeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_type, typeP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_order) {
                this.internal_order(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_type) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_type(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_type(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_type(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_type) {
                var objFound = this.type;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_type, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                this.internal_visit(visitor, this.type, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_type);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_type);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.order, _.org.kevoree.util.Constants.Att_order, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Parameter;
            }, writable: true}
          })},
          DictionaryAttributeImpl: {value: Kotlin.createClass([classes.cv, classes.c17], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$optional', {value: null, writable: true});
            Object.defineProperty(this, '$state', {value: null, writable: true});
            Object.defineProperty(this, '$datatype', {value: null, writable: true});
            Object.defineProperty(this, '$fragmentDependant', {value: null, writable: true});
            Object.defineProperty(this, '_genericTypes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.DictionaryAttributeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._genericTypes) != null ? tmp$0.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            optional: {
              get: function () {
                return this.$optional;
              },
              set: function (iP) {
                this.internal_optional(iP, true);
              }
            },
            internal_optional: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.optional)) {
                var oldPath = this.path();
                this.$optional = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_optional, this.optional));
                }
              }
            }},
            state: {
              get: function () {
                return this.$state;
              },
              set: function (iP) {
                this.internal_state(iP, true);
              }
            },
            internal_state: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.state)) {
                var oldPath = this.path();
                this.$state = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_state, this.state));
                }
              }
            }},
            datatype: {
              get: function () {
                return this.$datatype;
              },
              set: function (iP) {
                this.internal_datatype(iP, true);
              }
            },
            internal_datatype: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.datatype)) {
                var oldPath = this.path();
                this.$datatype = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_datatype, this.datatype));
                }
              }
            }},
            fragmentDependant: {
              get: function () {
                return this.$fragmentDependant;
              },
              set: function (iP) {
                this.internal_fragmentDependant(iP, true);
              }
            },
            internal_fragmentDependant: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.fragmentDependant)) {
                var oldPath = this.path();
                this.$fragmentDependant = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_fragmentDependant, this.fragmentDependant));
                }
              }
            }},
            genericTypes: {
              get: function () {
                return _.kotlin.toList(this._genericTypes.values());
              },
              set: function (genericTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (genericTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_genericTypes(genericTypesP, true, true);
              }
            },
            internal_genericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._genericTypes.values(), genericTypesP)) {
                this._genericTypes.clear();
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._genericTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
                }
              }
            }},
            doAddGenericTypes: {value: function (genericTypesP) {
              var _key_ = (genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._genericTypes.containsKey(_key_)) {
                this._genericTypes.put(_key_, genericTypesP);
              }
            }},
            addGenericTypes: {value: function (genericTypesP) {
              this.internal_addGenericTypes(genericTypesP, true, true);
            }, writable: true},
            addAllGenericTypes: {value: function (genericTypesP) {
              this.internal_addAllGenericTypes(genericTypesP, true, true);
            }, writable: true},
            internal_addGenericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGenericTypes(genericTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
              }
            }},
            internal_addAllGenericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGenericTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = genericTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGenericTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
              }
            }},
            removeGenericTypes: {value: function (genericTypesP) {
              this.internal_removeGenericTypes(genericTypesP, true, true);
            }, writable: true},
            removeAllGenericTypes: {value: function () {
              this.internal_removeAllGenericTypes(true, true);
            }, writable: true},
            internal_removeGenericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._genericTypes.remove((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
                }
              }
            }},
            internal_removeAllGenericTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.genericTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._genericTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_optional) {
                this.internal_optional(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_state) {
                this.internal_state(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_datatype) {
                this.internal_datatype(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_fragmentDependant) {
                this.internal_fragmentDependant(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllGenericTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey(value)) {
                    var obj = this._genericTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._genericTypes.remove(value);
                    this._genericTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findGenericTypesByID: {value: function (key) {
              return this._genericTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                return this.findGenericTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$0 = this._genericTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._genericTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_genericTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.fragmentDependant, _.org.kevoree.util.Constants.Att_fragmentDependant, this);
              visitor.visit(this.optional, _.org.kevoree.util.Constants.Att_optional, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.state, _.org.kevoree.util.Constants.Att_state, this);
              visitor.visit(this.datatype, _.org.kevoree.util.Constants.Att_datatype, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute;
            }, writable: true}
          })},
          InstanceImpl: {value: Kotlin.createClass([classes.cv, classes.c13], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$metaData', {value: null, writable: true});
            Object.defineProperty(this, '$started', {value: true, writable: true});
            Object.defineProperty(this, '$typeDefinition', {value: null, writable: true});
            Object.defineProperty(this, '$dictionary', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.InstanceImpl.prototype */ {
            delete: {value: function () {
              this.typeDefinition = null;
              this.dictionary = null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            }},
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            }},
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: {value: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            }},
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: {value: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Instance;
            }, writable: true}
          })},
          TypedElementImpl: {value: Kotlin.createClass([classes.cv, classes.cw], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '_genericTypes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.TypedElementImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._genericTypes) != null ? tmp$0.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            genericTypes: {
              get: function () {
                return _.kotlin.toList(this._genericTypes.values());
              },
              set: function (genericTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (genericTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_genericTypes(genericTypesP, true, true);
              }
            },
            internal_genericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._genericTypes.values(), genericTypesP)) {
                this._genericTypes.clear();
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._genericTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
                }
              }
            }},
            doAddGenericTypes: {value: function (genericTypesP) {
              var _key_ = (genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._genericTypes.containsKey(_key_)) {
                this._genericTypes.put(_key_, genericTypesP);
              }
            }},
            addGenericTypes: {value: function (genericTypesP) {
              this.internal_addGenericTypes(genericTypesP, true, true);
            }, writable: true},
            addAllGenericTypes: {value: function (genericTypesP) {
              this.internal_addAllGenericTypes(genericTypesP, true, true);
            }, writable: true},
            internal_addGenericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGenericTypes(genericTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
              }
            }},
            internal_addAllGenericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGenericTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = genericTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGenericTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
              }
            }},
            removeGenericTypes: {value: function (genericTypesP) {
              this.internal_removeGenericTypes(genericTypesP, true, true);
            }, writable: true},
            removeAllGenericTypes: {value: function () {
              this.internal_removeAllGenericTypes(true, true);
            }, writable: true},
            internal_removeGenericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._genericTypes.remove((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
                }
              }
            }},
            internal_removeAllGenericTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.genericTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._genericTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllGenericTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey(value)) {
                    var obj = this._genericTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._genericTypes.remove(value);
                    this._genericTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findGenericTypesByID: {value: function (key) {
              return this._genericTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                return this.findGenericTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$0 = this._genericTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._genericTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_genericTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_TypedElement;
            }, writable: true}
          })},
          NodeTypeImpl: {value: Kotlin.createClass([classes.cv, classes.c14], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$factoryBean', {value: null, writable: true});
            Object.defineProperty(this, '$bean', {value: null, writable: true});
            Object.defineProperty(this, '$abstract', {value: null, writable: true});
            Object.defineProperty(this, '$startMethod', {value: null, writable: true});
            Object.defineProperty(this, '$stopMethod', {value: null, writable: true});
            Object.defineProperty(this, '$updateMethod', {value: null, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$dictionaryType', {value: null, writable: true});
            Object.defineProperty(this, '_superTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '_managedPrimitiveTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '_managedPrimitiveTypeRefs', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllManagedPrimitiveTypeRefsCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.NodeTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1, tmp$2, tmp$3;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._managedPrimitiveTypes) != null ? tmp$2.clear() : null;
              (tmp$3 = this._managedPrimitiveTypeRefs) != null ? tmp$3.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            }},
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            }},
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            }},
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            }},
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            }},
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            }},
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: {value: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            }},
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            doAddSuperTypes: {value: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            }},
            addSuperTypes: {value: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            }, writable: true},
            addAllSuperTypes: {value: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            }, writable: true},
            internal_addSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            internal_addAllSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            removeSuperTypes: {value: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            }, writable: true},
            removeAllSuperTypes: {value: function () {
              this.internal_removeAllSuperTypes(true, true);
            }, writable: true},
            internal_removeSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            internal_removeAllSuperTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            }},
            managedPrimitiveTypes: {
              get: function () {
                return _.kotlin.toList(this._managedPrimitiveTypes.values());
              },
              set: function (managedPrimitiveTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (managedPrimitiveTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_managedPrimitiveTypes(managedPrimitiveTypesP, true, true);
              }
            },
            internal_managedPrimitiveTypes: {value: function (managedPrimitiveTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._managedPrimitiveTypes.values(), managedPrimitiveTypesP)) {
                this._managedPrimitiveTypes.clear();
                {
                  var tmp$0 = managedPrimitiveTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._managedPrimitiveTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, managedPrimitiveTypesP));
                }
              }
            }},
            doAddManagedPrimitiveTypes: {value: function (managedPrimitiveTypesP) {
              var _key_ = (managedPrimitiveTypesP != null ? managedPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._managedPrimitiveTypes.containsKey(_key_)) {
                this._managedPrimitiveTypes.put(_key_, managedPrimitiveTypesP);
              }
            }},
            addManagedPrimitiveTypes: {value: function (managedPrimitiveTypesP) {
              this.internal_addManagedPrimitiveTypes(managedPrimitiveTypesP, true, true);
            }, writable: true},
            addAllManagedPrimitiveTypes: {value: function (managedPrimitiveTypesP) {
              this.internal_addAllManagedPrimitiveTypes(managedPrimitiveTypesP, true, true);
            }, writable: true},
            internal_addManagedPrimitiveTypes: {value: function (managedPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddManagedPrimitiveTypes(managedPrimitiveTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, managedPrimitiveTypesP));
              }
            }},
            internal_addAllManagedPrimitiveTypes: {value: function (managedPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = managedPrimitiveTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddManagedPrimitiveTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = managedPrimitiveTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddManagedPrimitiveTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, managedPrimitiveTypesP));
              }
            }},
            removeManagedPrimitiveTypes: {value: function (managedPrimitiveTypesP) {
              this.internal_removeManagedPrimitiveTypes(managedPrimitiveTypesP, true, true);
            }, writable: true},
            removeAllManagedPrimitiveTypes: {value: function () {
              this.internal_removeAllManagedPrimitiveTypes(true, true);
            }, writable: true},
            internal_removeManagedPrimitiveTypes: {value: function (managedPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._managedPrimitiveTypes.size() !== 0 && this._managedPrimitiveTypes.containsKey((managedPrimitiveTypesP != null ? managedPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._managedPrimitiveTypes.remove((managedPrimitiveTypesP != null ? managedPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, managedPrimitiveTypesP));
                }
              }
            }},
            internal_removeAllManagedPrimitiveTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.managedPrimitiveTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._managedPrimitiveTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, temp_els));
              }
            }},
            managedPrimitiveTypeRefs: {
              get: function () {
                return _.kotlin.toList(this._managedPrimitiveTypeRefs.values());
              },
              set: function (managedPrimitiveTypeRefsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (managedPrimitiveTypeRefsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_managedPrimitiveTypeRefs(managedPrimitiveTypeRefsP, true, true);
              }
            },
            internal_managedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._managedPrimitiveTypeRefs.values(), managedPrimitiveTypeRefsP)) {
                this._managedPrimitiveTypeRefs.clear();
                {
                  var tmp$0 = managedPrimitiveTypeRefsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._managedPrimitiveTypeRefs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, el), _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP));
                }
              }
            }},
            doAddManagedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP) {
              var _key_ = (managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._managedPrimitiveTypeRefs.containsKey(_key_)) {
                this._managedPrimitiveTypeRefs.put(_key_, managedPrimitiveTypeRefsP);
                (managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP), _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs);
              }
            }},
            addManagedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP) {
              this.internal_addManagedPrimitiveTypeRefs(managedPrimitiveTypeRefsP, true, true);
            }, writable: true},
            addAllManagedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP) {
              this.internal_addAllManagedPrimitiveTypeRefs(managedPrimitiveTypeRefsP, true, true);
            }, writable: true},
            internal_addManagedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddManagedPrimitiveTypeRefs(managedPrimitiveTypeRefsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP));
              }
            }},
            internal_addAllManagedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = managedPrimitiveTypeRefsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddManagedPrimitiveTypeRefs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = managedPrimitiveTypeRefsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddManagedPrimitiveTypeRefs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP));
              }
            }},
            removeManagedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP) {
              this.internal_removeManagedPrimitiveTypeRefs(managedPrimitiveTypeRefsP, true, true);
            }, writable: true},
            removeAllManagedPrimitiveTypeRefs: {value: function () {
              this.internal_removeAllManagedPrimitiveTypeRefs(true, true);
            }, writable: true},
            internal_removeManagedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._managedPrimitiveTypeRefs.size() !== 0 && this._managedPrimitiveTypeRefs.containsKey((managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).internalGetKey())) {
                this._managedPrimitiveTypeRefs.remove((managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).internalGetKey());
                ((managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()) != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllManagedPrimitiveTypeRefsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP));
                }
              }
            }},
            internal_removeAllManagedPrimitiveTypeRefs: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllManagedPrimitiveTypeRefsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.managedPrimitiveTypeRefs) != null ? tmp$0 : Kotlin.throwNPE();
              this._managedPrimitiveTypeRefs.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, temp_els));
                this.removeAllManagedPrimitiveTypeRefsCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addManagedPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllManagedPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeManagedPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllManagedPrimitiveTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._managedPrimitiveTypes.size() !== 0 && this._managedPrimitiveTypes.containsKey(value)) {
                    var obj_1 = this._managedPrimitiveTypes.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._managedPrimitiveTypes.remove(value);
                    this._managedPrimitiveTypes.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addManagedPrimitiveTypeRefs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllManagedPrimitiveTypeRefs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeManagedPrimitiveTypeRefs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllManagedPrimitiveTypeRefs();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._managedPrimitiveTypeRefs.size() !== 0 && this._managedPrimitiveTypeRefs.containsKey(value)) {
                    var obj_2 = this._managedPrimitiveTypeRefs.get(value);
                    var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_2 == null) {
                      throw new Error('Key newed to null ' + obj_2);
                    }
                    this._managedPrimitiveTypeRefs.remove(value);
                    this._managedPrimitiveTypeRefs.put(objNewKey_2, obj_2);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findSuperTypesByID: {value: function (key) {
              return this._superTypes.get(key);
            }, writable: true},
            findManagedPrimitiveTypesByID: {value: function (key) {
              return this._managedPrimitiveTypes.get(key);
            }, writable: true},
            findManagedPrimitiveTypeRefsByID: {value: function (key) {
              return this._managedPrimitiveTypeRefs.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes) {
                return this.findManagedPrimitiveTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs) {
                return this.findManagedPrimitiveTypeRefsByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveTypeRef);
                {
                  var tmp$0 = this._managedPrimitiveTypeRefs.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._managedPrimitiveTypeRefs.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$1 = this._deployUnits.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$2 = this._superTypes.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType);
                {
                  var tmp$3 = this._managedPrimitiveTypes.keySet().iterator();
                  while (tmp$3.hasNext()) {
                    var KMFLoopEntryKey_2 = tmp$3.next();
                    this.internal_visit(visitor, this._managedPrimitiveTypes.get(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_managedPrimitiveTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NodeType;
            }, writable: true}
          })},
          DeployUnitImpl: {value: Kotlin.createClass([classes.cv, classes.c0], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$groupName', {value: null, writable: true});
            Object.defineProperty(this, '$unitName', {value: null, writable: true});
            Object.defineProperty(this, '$version', {value: null, writable: true});
            Object.defineProperty(this, '$url', {value: null, writable: true});
            Object.defineProperty(this, '$hashcode', {value: null, writable: true});
            Object.defineProperty(this, '$type', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_requiredLibs', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$targetNodeType', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.DeployUnitImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._requiredLibs) != null ? tmp$0.clear() : null;
              this.targetNodeType = null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
              }
            }},
            groupName: {
              get: function () {
                return this.$groupName;
              },
              set: function (iP) {
                this.internal_groupName(iP, true);
              }
            },
            internal_groupName: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.groupName)) {
                var oldPath = this.path();
                this.$groupName = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_groupName, this.groupName));
                }
              }
            }},
            unitName: {
              get: function () {
                return this.$unitName;
              },
              set: function (iP) {
                this.internal_unitName(iP, true);
              }
            },
            internal_unitName: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.unitName)) {
                var oldPath = this.path();
                this.$unitName = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_unitName, this.unitName));
                }
              }
            }},
            version: {
              get: function () {
                return this.$version;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                this.$version = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version));
                }
              }
            }},
            url: {
              get: function () {
                return this.$url;
              },
              set: function (iP) {
                this.internal_url(iP, true);
              }
            },
            internal_url: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.url)) {
                var oldPath = this.path();
                this.$url = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_url, this.url));
                }
              }
            }},
            hashcode: {
              get: function () {
                return this.$hashcode;
              },
              set: function (iP) {
                this.internal_hashcode(iP, true);
              }
            },
            internal_hashcode: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.hashcode)) {
                var oldPath = this.path();
                this.$hashcode = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_hashcode, this.hashcode));
                }
              }
            }},
            type: {
              get: function () {
                return this.$type;
              },
              set: function (iP) {
                this.internal_type(iP, true);
              }
            },
            internal_type: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.type)) {
                var oldPath = this.path();
                this.$type = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_type, this.type));
                }
              }
            }},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            requiredLibs: {
              get: function () {
                return _.kotlin.toList(this._requiredLibs.values());
              },
              set: function (requiredLibsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredLibsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_requiredLibs(requiredLibsP, true, true);
              }
            },
            internal_requiredLibs: {value: function (requiredLibsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._requiredLibs.values(), requiredLibsP)) {
                this._requiredLibs.clear();
                {
                  var tmp$0 = requiredLibsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._requiredLibs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP));
                }
              }
            }},
            doAddRequiredLibs: {value: function (requiredLibsP) {
              var _key_ = (requiredLibsP != null ? requiredLibsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._requiredLibs.containsKey(_key_)) {
                this._requiredLibs.put(_key_, requiredLibsP);
              }
            }},
            addRequiredLibs: {value: function (requiredLibsP) {
              this.internal_addRequiredLibs(requiredLibsP, true, true);
            }, writable: true},
            addAllRequiredLibs: {value: function (requiredLibsP) {
              this.internal_addAllRequiredLibs(requiredLibsP, true, true);
            }, writable: true},
            internal_addRequiredLibs: {value: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequiredLibs(requiredLibsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP));
              }
            }},
            internal_addAllRequiredLibs: {value: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredLibsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequiredLibs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredLibsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequiredLibs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP));
              }
            }},
            removeRequiredLibs: {value: function (requiredLibsP) {
              this.internal_removeRequiredLibs(requiredLibsP, true, true);
            }, writable: true},
            removeAllRequiredLibs: {value: function () {
              this.internal_removeAllRequiredLibs(true, true);
            }, writable: true},
            internal_removeRequiredLibs: {value: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._requiredLibs.size() !== 0 && this._requiredLibs.containsKey((requiredLibsP != null ? requiredLibsP : Kotlin.throwNPE()).internalGetKey())) {
                this._requiredLibs.remove((requiredLibsP != null ? requiredLibsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP));
                }
              }
            }},
            internal_removeAllRequiredLibs: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.requiredLibs) != null ? tmp$0 : Kotlin.throwNPE();
              this._requiredLibs.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, temp_els));
              }
            }},
            targetNodeType: {
              get: function () {
                return this.$targetNodeType;
              },
              set: function (targetNodeTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_targetNodeType(targetNodeTypeP, true, true);
              }
            },
            internal_targetNodeType: {value: function (targetNodeTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$targetNodeType, targetNodeTypeP)) {
                this.$targetNodeType = targetNodeTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_targetNodeType, targetNodeTypeP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_groupName) {
                this.internal_groupName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_unitName) {
                this.internal_unitName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_version) {
                this.internal_version(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_url) {
                this.internal_url(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_hashcode) {
                this.internal_hashcode(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_type) {
                this.internal_type(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_requiredLibs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRequiredLibs();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._requiredLibs.size() !== 0 && this._requiredLibs.containsKey(value)) {
                    var obj = this._requiredLibs.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._requiredLibs.remove(value);
                    this._requiredLibs.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_targetNodeType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_targetNodeType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_targetNodeType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_targetNodeType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findRequiredLibsByID: {value: function (key) {
              return this._requiredLibs.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_requiredLibs) {
                return this.findRequiredLibsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_targetNodeType) {
                var objFound = this.targetNodeType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_requiredLibs, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._requiredLibs.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._requiredLibs.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_requiredLibs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_requiredLibs);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_targetNodeType, _.org.kevoree.util.Constants.org_kevoree_NodeType);
                this.internal_visit(visitor, this.targetNodeType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_targetNodeType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_targetNodeType);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.groupName, _.org.kevoree.util.Constants.Att_groupName, this);
              visitor.visit(this.unitName, _.org.kevoree.util.Constants.Att_unitName, this);
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.hashcode, _.org.kevoree.util.Constants.Att_hashcode, this);
              visitor.visit(this.type, _.org.kevoree.util.Constants.Att_type, this);
              visitor.visit(this.url, _.org.kevoree.util.Constants.Att_url, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DeployUnit;
            }, writable: true}
          })},
          GroupTypeImpl: {value: Kotlin.createClass([classes.cv, classes.c3], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$factoryBean', {value: null, writable: true});
            Object.defineProperty(this, '$bean', {value: null, writable: true});
            Object.defineProperty(this, '$abstract', {value: null, writable: true});
            Object.defineProperty(this, '$startMethod', {value: null, writable: true});
            Object.defineProperty(this, '$stopMethod', {value: null, writable: true});
            Object.defineProperty(this, '$updateMethod', {value: null, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$dictionaryType', {value: null, writable: true});
            Object.defineProperty(this, '_superTypes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.GroupTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            }},
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            }},
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            }},
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            }},
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            }},
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            }},
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: {value: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            }},
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            doAddSuperTypes: {value: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            }},
            addSuperTypes: {value: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            }, writable: true},
            addAllSuperTypes: {value: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            }, writable: true},
            internal_addSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            internal_addAllSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            removeSuperTypes: {value: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            }, writable: true},
            removeAllSuperTypes: {value: function () {
              this.internal_removeAllSuperTypes(true, true);
            }, writable: true},
            internal_removeSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            internal_removeAllSuperTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findSuperTypesByID: {value: function (key) {
              return this._superTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._deployUnits.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$1 = this._superTypes.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_GroupType;
            }, writable: true}
          })},
          AdaptationPrimitiveTypeRefImpl: {value: Kotlin.createClass([classes.cv, classes.cs], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$maxTime', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '$ref', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.AdaptationPrimitiveTypeRefImpl.prototype */ {
            delete: {value: function () {
              this.ref = null;
            }, writable: true},
            maxTime: {
              get: function () {
                return this.$maxTime;
              },
              set: function (iP) {
                this.internal_maxTime(iP, true);
              }
            },
            internal_maxTime: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.maxTime)) {
                var oldPath = this.path();
                this.$maxTime = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_maxTime, this.maxTime));
                }
              }
            }},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            ref: {
              get: function () {
                return this.$ref;
              },
              set: function (refP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_ref(refP, true, true);
              }
            },
            internal_ref: {value: function (refP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$ref, refP)) {
                this.$ref = refP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ref, refP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_maxTime) {
                this.internal_maxTime(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_ref) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_ref(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_ref(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_ref(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_ref) {
                var objFound = this.ref;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_ref, _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType);
                this.internal_visit(visitor, this.ref, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_ref);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_ref);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.maxTime, _.org.kevoree.util.Constants.Att_maxTime, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveTypeRef;
            }, writable: true}
          })},
          IntegrationPatternImpl: {value: Kotlin.createClass([classes.cv, classes.c1k], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '_extraFonctionalProperties', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllExtraFonctionalPropertiesCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_portTypes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.IntegrationPatternImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1;
              (tmp$0 = this._extraFonctionalProperties) != null ? tmp$0.clear() : null;
              (tmp$1 = this._portTypes) != null ? tmp$1.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            extraFonctionalProperties: {
              get: function () {
                return _.kotlin.toList(this._extraFonctionalProperties.values());
              },
              set: function (extraFonctionalPropertiesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (extraFonctionalPropertiesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_extraFonctionalProperties(extraFonctionalPropertiesP, true, true);
              }
            },
            internal_extraFonctionalProperties: {value: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._extraFonctionalProperties.values(), extraFonctionalPropertiesP)) {
                this._extraFonctionalProperties.clear();
                {
                  var tmp$0 = extraFonctionalPropertiesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._extraFonctionalProperties.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, el), _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
                }
              }
            }},
            doAddExtraFonctionalProperties: {value: function (extraFonctionalPropertiesP) {
              var _key_ = (extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._extraFonctionalProperties.containsKey(_key_)) {
                this._extraFonctionalProperties.put(_key_, extraFonctionalPropertiesP);
                (extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP), _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
              }
            }},
            addExtraFonctionalProperties: {value: function (extraFonctionalPropertiesP) {
              this.internal_addExtraFonctionalProperties(extraFonctionalPropertiesP, true, true);
            }, writable: true},
            addAllExtraFonctionalProperties: {value: function (extraFonctionalPropertiesP) {
              this.internal_addAllExtraFonctionalProperties(extraFonctionalPropertiesP, true, true);
            }, writable: true},
            internal_addExtraFonctionalProperties: {value: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddExtraFonctionalProperties(extraFonctionalPropertiesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
              }
            }},
            internal_addAllExtraFonctionalProperties: {value: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = extraFonctionalPropertiesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddExtraFonctionalProperties(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = extraFonctionalPropertiesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddExtraFonctionalProperties(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
              }
            }},
            removeExtraFonctionalProperties: {value: function (extraFonctionalPropertiesP) {
              this.internal_removeExtraFonctionalProperties(extraFonctionalPropertiesP, true, true);
            }, writable: true},
            removeAllExtraFonctionalProperties: {value: function () {
              this.internal_removeAllExtraFonctionalProperties(true, true);
            }, writable: true},
            internal_removeExtraFonctionalProperties: {value: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._extraFonctionalProperties.size() !== 0 && this._extraFonctionalProperties.containsKey((extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).internalGetKey())) {
                this._extraFonctionalProperties.remove((extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).internalGetKey());
                ((extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()) != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllExtraFonctionalPropertiesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
                }
              }
            }},
            internal_removeAllExtraFonctionalProperties: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllExtraFonctionalPropertiesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.extraFonctionalProperties) != null ? tmp$0 : Kotlin.throwNPE();
              this._extraFonctionalProperties.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, temp_els));
                this.removeAllExtraFonctionalPropertiesCurrentlyProcessing = false;
              }
            }},
            portTypes: {
              get: function () {
                return _.kotlin.toList(this._portTypes.values());
              },
              set: function (portTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (portTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_portTypes(portTypesP, true, true);
              }
            },
            internal_portTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._portTypes.values(), portTypesP)) {
                this._portTypes.clear();
                {
                  var tmp$0 = portTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._portTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
                }
              }
            }},
            doAddPortTypes: {value: function (portTypesP) {
              var _key_ = (portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._portTypes.containsKey(_key_)) {
                this._portTypes.put(_key_, portTypesP);
              }
            }},
            addPortTypes: {value: function (portTypesP) {
              this.internal_addPortTypes(portTypesP, true, true);
            }, writable: true},
            addAllPortTypes: {value: function (portTypesP) {
              this.internal_addAllPortTypes(portTypesP, true, true);
            }, writable: true},
            internal_addPortTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddPortTypes(portTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
              }
            }},
            internal_addAllPortTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = portTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddPortTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = portTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddPortTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
              }
            }},
            removePortTypes: {value: function (portTypesP) {
              this.internal_removePortTypes(portTypesP, true, true);
            }, writable: true},
            removeAllPortTypes: {value: function () {
              this.internal_removeAllPortTypes(true, true);
            }, writable: true},
            internal_removePortTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._portTypes.size() !== 0 && this._portTypes.containsKey((portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._portTypes.remove((portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
                }
              }
            }},
            internal_removeAllPortTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.portTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._portTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addExtraFonctionalProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllExtraFonctionalProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeExtraFonctionalProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllExtraFonctionalProperties();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._extraFonctionalProperties.size() !== 0 && this._extraFonctionalProperties.containsKey(value)) {
                    var obj = this._extraFonctionalProperties.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._extraFonctionalProperties.remove(value);
                    this._extraFonctionalProperties.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_portTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addPortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllPortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removePortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllPortTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._portTypes.size() !== 0 && this._portTypes.containsKey(value)) {
                    var obj_0 = this._portTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._portTypes.remove(value);
                    this._portTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findExtraFonctionalPropertiesByID: {value: function (key) {
              return this._extraFonctionalProperties.get(key);
            }, writable: true},
            findPortTypesByID: {value: function (key) {
              return this._portTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                return this.findExtraFonctionalPropertiesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_portTypes) {
                return this.findPortTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties, _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty);
                {
                  var tmp$0 = this._extraFonctionalProperties.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._extraFonctionalProperties.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_portTypes, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$1 = this._portTypes.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._portTypes.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_portTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_portTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_IntegrationPattern;
            }, writable: true}
          })},
          ChannelTypeImpl: {value: Kotlin.createClass([classes.cv, classes.cr], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$factoryBean', {value: null, writable: true});
            Object.defineProperty(this, '$bean', {value: null, writable: true});
            Object.defineProperty(this, '$abstract', {value: null, writable: true});
            Object.defineProperty(this, '$startMethod', {value: null, writable: true});
            Object.defineProperty(this, '$stopMethod', {value: null, writable: true});
            Object.defineProperty(this, '$updateMethod', {value: null, writable: true});
            Object.defineProperty(this, '$lowerBindings', {value: null, writable: true});
            Object.defineProperty(this, '$upperBindings', {value: null, writable: true});
            Object.defineProperty(this, '$lowerFragments', {value: null, writable: true});
            Object.defineProperty(this, '$upperFragments', {value: null, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$dictionaryType', {value: null, writable: true});
            Object.defineProperty(this, '_superTypes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.ChannelTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            }},
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            }},
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            }},
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            }},
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            }},
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            }},
            lowerBindings: {
              get: function () {
                return this.$lowerBindings;
              },
              set: function (iP) {
                this.internal_lowerBindings(iP, true);
              }
            },
            internal_lowerBindings: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.lowerBindings) {
                var oldPath = this.path();
                this.$lowerBindings = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lowerBindings, this.lowerBindings));
                }
              }
            }},
            upperBindings: {
              get: function () {
                return this.$upperBindings;
              },
              set: function (iP) {
                this.internal_upperBindings(iP, true);
              }
            },
            internal_upperBindings: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.upperBindings) {
                var oldPath = this.path();
                this.$upperBindings = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_upperBindings, this.upperBindings));
                }
              }
            }},
            lowerFragments: {
              get: function () {
                return this.$lowerFragments;
              },
              set: function (iP) {
                this.internal_lowerFragments(iP, true);
              }
            },
            internal_lowerFragments: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.lowerFragments) {
                var oldPath = this.path();
                this.$lowerFragments = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lowerFragments, this.lowerFragments));
                }
              }
            }},
            upperFragments: {
              get: function () {
                return this.$upperFragments;
              },
              set: function (iP) {
                this.internal_upperFragments(iP, true);
              }
            },
            internal_upperFragments: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.upperFragments) {
                var oldPath = this.path();
                this.$upperFragments = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_upperFragments, this.upperFragments));
                }
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            }},
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: {value: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            }},
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            doAddSuperTypes: {value: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            }},
            addSuperTypes: {value: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            }, writable: true},
            addAllSuperTypes: {value: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            }, writable: true},
            internal_addSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            internal_addAllSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            removeSuperTypes: {value: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            }, writable: true},
            removeAllSuperTypes: {value: function () {
              this.internal_removeAllSuperTypes(true, true);
            }, writable: true},
            internal_removeSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            internal_removeAllSuperTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lowerBindings) {
                this.internal_lowerBindings(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_upperBindings) {
                this.internal_upperBindings(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lowerFragments) {
                this.internal_lowerFragments(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_upperFragments) {
                this.internal_upperFragments(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findSuperTypesByID: {value: function (key) {
              return this._superTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._deployUnits.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$1 = this._superTypes.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.upperFragments, _.org.kevoree.util.Constants.Att_upperFragments, this);
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.upperBindings, _.org.kevoree.util.Constants.Att_upperBindings, this);
              visitor.visit(this.lowerBindings, _.org.kevoree.util.Constants.Att_lowerBindings, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.lowerFragments, _.org.kevoree.util.Constants.Att_lowerFragments, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ChannelType;
            }, writable: true}
          })},
          ServicePortTypeImpl: {value: Kotlin.createClass([classes.cv, classes.cq], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$factoryBean', {value: null, writable: true});
            Object.defineProperty(this, '$bean', {value: null, writable: true});
            Object.defineProperty(this, '$abstract', {value: null, writable: true});
            Object.defineProperty(this, '$synchrone', {value: null, writable: true});
            Object.defineProperty(this, '$interface', {value: null, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$dictionaryType', {value: null, writable: true});
            Object.defineProperty(this, '_superTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '_operations', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllOperationsCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.ServicePortTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1, tmp$2;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._operations) != null ? tmp$2.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            }},
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            }},
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            }},
            synchrone: {
              get: function () {
                return this.$synchrone;
              },
              set: function (iP) {
                this.internal_synchrone(iP, true);
              }
            },
            internal_synchrone: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.synchrone)) {
                var oldPath = this.path();
                this.$synchrone = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_synchrone, this.synchrone));
                }
              }
            }},
            interface: {
              get: function () {
                return this.$interface;
              },
              set: function (iP) {
                this.internal_interface(iP, true);
              }
            },
            internal_interface: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.interface)) {
                var oldPath = this.path();
                this.$interface = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_interface, this.interface));
                }
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            }},
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: {value: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            }},
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            doAddSuperTypes: {value: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            }},
            addSuperTypes: {value: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            }, writable: true},
            addAllSuperTypes: {value: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            }, writable: true},
            internal_addSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            internal_addAllSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            removeSuperTypes: {value: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            }, writable: true},
            removeAllSuperTypes: {value: function () {
              this.internal_removeAllSuperTypes(true, true);
            }, writable: true},
            internal_removeSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            internal_removeAllSuperTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            }},
            operations: {
              get: function () {
                return _.kotlin.toList(this._operations.values());
              },
              set: function (operationsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (operationsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_operations(operationsP, true, true);
              }
            },
            internal_operations: {value: function (operationsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._operations.values(), operationsP)) {
                this._operations.clear();
                {
                  var tmp$0 = operationsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._operations.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_operations, el), _.org.kevoree.util.Constants.Ref_operations);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP));
                }
              }
            }},
            doAddOperations: {value: function (operationsP) {
              var _key_ = (operationsP != null ? operationsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._operations.containsKey(_key_)) {
                this._operations.put(_key_, operationsP);
                (operationsP != null ? operationsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_operations, operationsP), _.org.kevoree.util.Constants.Ref_operations);
              }
            }},
            addOperations: {value: function (operationsP) {
              this.internal_addOperations(operationsP, true, true);
            }, writable: true},
            addAllOperations: {value: function (operationsP) {
              this.internal_addAllOperations(operationsP, true, true);
            }, writable: true},
            internal_addOperations: {value: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddOperations(operationsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP));
              }
            }},
            internal_addAllOperations: {value: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = operationsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddOperations(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = operationsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddOperations(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP));
              }
            }},
            removeOperations: {value: function (operationsP) {
              this.internal_removeOperations(operationsP, true, true);
            }, writable: true},
            removeAllOperations: {value: function () {
              this.internal_removeAllOperations(true, true);
            }, writable: true},
            internal_removeOperations: {value: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._operations.size() !== 0 && this._operations.containsKey((operationsP != null ? operationsP : Kotlin.throwNPE()).internalGetKey())) {
                this._operations.remove((operationsP != null ? operationsP : Kotlin.throwNPE()).internalGetKey());
                ((operationsP != null ? operationsP : Kotlin.throwNPE()) != null ? operationsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllOperationsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP));
                }
              }
            }},
            internal_removeAllOperations: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllOperationsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.operations) != null ? tmp$0 : Kotlin.throwNPE();
              this._operations.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, temp_els));
                this.removeAllOperationsCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_synchrone) {
                this.internal_synchrone(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_interface) {
                this.internal_interface(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_operations) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllOperations();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._operations.size() !== 0 && this._operations.containsKey(value)) {
                    var obj_1 = this._operations.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._operations.remove(value);
                    this._operations.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findSuperTypesByID: {value: function (key) {
              return this._superTypes.get(key);
            }, writable: true},
            findOperationsByID: {value: function (key) {
              return this._operations.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_operations) {
                return this.findOperationsByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_operations, _.org.kevoree.util.Constants.org_kevoree_Operation);
                {
                  var tmp$0 = this._operations.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._operations.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_operations);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_operations);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$1 = this._deployUnits.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$2 = this._superTypes.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.synchrone, _.org.kevoree.util.Constants.Att_synchrone, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.interface, _.org.kevoree.util.Constants.Att_interface, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ServicePortType;
            }, writable: true}
          })},
          NamedElementImpl: {value: Kotlin.createClass([classes.cv, classes.cl], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.NamedElementImpl.prototype */ {
            delete: {value: function () {
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NamedElement;
            }, writable: true}
          })},
          GroupImpl: {value: Kotlin.createClass([classes.cv, classes.c1c], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$metaData', {value: null, writable: true});
            Object.defineProperty(this, '$started', {value: true, writable: true});
            Object.defineProperty(this, '$typeDefinition', {value: null, writable: true});
            Object.defineProperty(this, '$dictionary', {value: null, writable: true});
            Object.defineProperty(this, '_subNodes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.GroupImpl.prototype */ {
            delete: {value: function () {
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$0;
              (tmp$0 = this._subNodes) != null ? tmp$0.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            }},
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            }},
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: {value: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            }},
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: {value: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            }},
            subNodes: {
              get: function () {
                return _.kotlin.toList(this._subNodes.values());
              },
              set: function (subNodesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (subNodesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_subNodes(subNodesP, true, true);
              }
            },
            internal_subNodes: {value: function (subNodesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._subNodes.values(), subNodesP)) {
                this._subNodes.clear();
                {
                  var tmp$0 = subNodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._subNodes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP));
                }
              }
            }},
            doAddSubNodes: {value: function (subNodesP) {
              var _key_ = (subNodesP != null ? subNodesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._subNodes.containsKey(_key_)) {
                this._subNodes.put(_key_, subNodesP);
              }
            }},
            addSubNodes: {value: function (subNodesP) {
              this.internal_addSubNodes(subNodesP, true, true);
            }, writable: true},
            addAllSubNodes: {value: function (subNodesP) {
              this.internal_addAllSubNodes(subNodesP, true, true);
            }, writable: true},
            internal_addSubNodes: {value: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSubNodes(subNodesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP));
              }
            }},
            internal_addAllSubNodes: {value: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = subNodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSubNodes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = subNodesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSubNodes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP));
              }
            }},
            removeSubNodes: {value: function (subNodesP) {
              this.internal_removeSubNodes(subNodesP, true, true);
            }, writable: true},
            removeAllSubNodes: {value: function () {
              this.internal_removeAllSubNodes(true, true);
            }, writable: true},
            internal_removeSubNodes: {value: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._subNodes.size() !== 0 && this._subNodes.containsKey((subNodesP != null ? subNodesP : Kotlin.throwNPE()).internalGetKey())) {
                this._subNodes.remove((subNodesP != null ? subNodesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP));
                }
              }
            }},
            internal_removeAllSubNodes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.subNodes) != null ? tmp$0 : Kotlin.throwNPE();
              this._subNodes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_subNodes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSubNodes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._subNodes.size() !== 0 && this._subNodes.containsKey(value)) {
                    var obj = this._subNodes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._subNodes.remove(value);
                    this._subNodes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findSubNodesByID: {value: function (key) {
              return this._subNodes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_subNodes) {
                return this.findSubNodesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_subNodes, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                {
                  var tmp$0 = this._subNodes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._subNodes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_subNodes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_subNodes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Group;
            }, writable: true}
          })},
          NodeNetworkImpl: {value: Kotlin.createClass([classes.cv, classes.cy], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_link', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllLinkCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '$initBy', {value: null, writable: true});
            Object.defineProperty(this, '$target', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.NodeNetworkImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._link) != null ? tmp$0.clear() : null;
              this.initBy = null;
              this.target = null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            link: {
              get: function () {
                return _.kotlin.toList(this._link.values());
              },
              set: function (linkP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (linkP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_link(linkP, true, true);
              }
            },
            internal_link: {value: function (linkP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._link.values(), linkP)) {
                this._link.clear();
                {
                  var tmp$0 = linkP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._link.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_link, el), _.org.kevoree.util.Constants.Ref_link);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP));
                }
              }
            }},
            doAddLink: {value: function (linkP) {
              var _key_ = (linkP != null ? linkP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._link.containsKey(_key_)) {
                this._link.put(_key_, linkP);
                (linkP != null ? linkP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_link, linkP), _.org.kevoree.util.Constants.Ref_link);
              }
            }},
            addLink: {value: function (linkP) {
              this.internal_addLink(linkP, true, true);
            }, writable: true},
            addAllLink: {value: function (linkP) {
              this.internal_addAllLink(linkP, true, true);
            }, writable: true},
            internal_addLink: {value: function (linkP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddLink(linkP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP));
              }
            }},
            internal_addAllLink: {value: function (linkP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = linkP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddLink(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = linkP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddLink(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP));
              }
            }},
            removeLink: {value: function (linkP) {
              this.internal_removeLink(linkP, true, true);
            }, writable: true},
            removeAllLink: {value: function () {
              this.internal_removeAllLink(true, true);
            }, writable: true},
            internal_removeLink: {value: function (linkP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._link.size() !== 0 && this._link.containsKey((linkP != null ? linkP : Kotlin.throwNPE()).internalGetKey())) {
                this._link.remove((linkP != null ? linkP : Kotlin.throwNPE()).internalGetKey());
                ((linkP != null ? linkP : Kotlin.throwNPE()) != null ? linkP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllLinkCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP));
                }
              }
            }},
            internal_removeAllLink: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllLinkCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.link) != null ? tmp$0 : Kotlin.throwNPE();
              this._link.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, temp_els));
                this.removeAllLinkCurrentlyProcessing = false;
              }
            }},
            initBy: {
              get: function () {
                return this.$initBy;
              },
              set: function (initByP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_initBy(initByP, true, true);
              }
            },
            internal_initBy: {value: function (initByP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$initBy, initByP)) {
                this.$initBy = initByP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_initBy, initByP));
                }
              }
            }},
            target: {
              get: function () {
                return this.$target;
              },
              set: function (targetP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_target(targetP, true, true);
              }
            },
            internal_target: {value: function (targetP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$target, targetP)) {
                this.$target = targetP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_target, targetP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_link) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addLink(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllLink(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeLink(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllLink();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._link.size() !== 0 && this._link.containsKey(value)) {
                    var obj = this._link.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._link.remove(value);
                    this._link.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_initBy) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_initBy(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_initBy(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_initBy(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_target) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_target(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_target(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_target(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findLinkByID: {value: function (key) {
              return this._link.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_link) {
                return this.findLinkByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_initBy) {
                var objFound = this.initBy;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_target) {
                var objFound_0 = this.target;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_link, _.org.kevoree.util.Constants.org_kevoree_NodeLink);
                {
                  var tmp$0 = this._link.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._link.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_link);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_link);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_initBy, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.initBy, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_initBy);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_initBy);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_target, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.target, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_target);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_target);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NodeNetwork;
            }, writable: true}
          })},
          NetworkPropertyImpl: {value: Kotlin.createClass([classes.cv, classes.cp], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$value', {value: null, writable: true});
            Object.defineProperty(this, '$lastCheck', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.NetworkPropertyImpl.prototype */ {
            delete: {value: function () {
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            value: {
              get: function () {
                return this.$value;
              },
              set: function (iP) {
                this.internal_value(iP, true);
              }
            },
            internal_value: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.value)) {
                var oldPath = this.path();
                this.$value = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_value, this.value));
                }
              }
            }},
            lastCheck: {
              get: function () {
                return this.$lastCheck;
              },
              set: function (iP) {
                this.internal_lastCheck(iP, true);
              }
            },
            internal_lastCheck: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.lastCheck)) {
                var oldPath = this.path();
                this.$lastCheck = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lastCheck, this.lastCheck));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_value) {
                this.internal_value(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lastCheck) {
                this.internal_lastCheck(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.value, _.org.kevoree.util.Constants.Att_value, this);
              visitor.visit(this.lastCheck, _.org.kevoree.util.Constants.Att_lastCheck, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NetworkProperty;
            }, writable: true}
          })},
          AdaptationPrimitiveTypeImpl: {value: Kotlin.createClass([classes.cv, classes.c1h], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.AdaptationPrimitiveTypeImpl.prototype */ {
            delete: {value: function () {
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType;
            }, writable: true}
          })},
          NodeLinkImpl: {value: Kotlin.createClass([classes.cv, classes.cz], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$networkType', {value: null, writable: true});
            Object.defineProperty(this, '$estimatedRate', {value: null, writable: true});
            Object.defineProperty(this, '$lastCheck', {value: null, writable: true});
            Object.defineProperty(this, '$zoneID', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_networkProperties', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllNetworkPropertiesCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.NodeLinkImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._networkProperties) != null ? tmp$0.clear() : null;
            }, writable: true},
            networkType: {
              get: function () {
                return this.$networkType;
              },
              set: function (iP) {
                this.internal_networkType(iP, true);
              }
            },
            internal_networkType: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.networkType)) {
                var oldPath = this.path();
                this.$networkType = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_networkType, this.networkType));
                }
              }
            }},
            estimatedRate: {
              get: function () {
                return this.$estimatedRate;
              },
              set: function (iP) {
                this.internal_estimatedRate(iP, true);
              }
            },
            internal_estimatedRate: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.estimatedRate) {
                var oldPath = this.path();
                this.$estimatedRate = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_estimatedRate, this.estimatedRate));
                }
              }
            }},
            lastCheck: {
              get: function () {
                return this.$lastCheck;
              },
              set: function (iP) {
                this.internal_lastCheck(iP, true);
              }
            },
            internal_lastCheck: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.lastCheck)) {
                var oldPath = this.path();
                this.$lastCheck = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lastCheck, this.lastCheck));
                }
              }
            }},
            zoneID: {
              get: function () {
                return this.$zoneID;
              },
              set: function (iP) {
                this.internal_zoneID(iP, true);
              }
            },
            internal_zoneID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.zoneID)) {
                var oldPath = this.path();
                this.$zoneID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_zoneID, this.zoneID));
                }
              }
            }},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            networkProperties: {
              get: function () {
                return _.kotlin.toList(this._networkProperties.values());
              },
              set: function (networkPropertiesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (networkPropertiesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_networkProperties(networkPropertiesP, true, true);
              }
            },
            internal_networkProperties: {value: function (networkPropertiesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._networkProperties.values(), networkPropertiesP)) {
                this._networkProperties.clear();
                {
                  var tmp$0 = networkPropertiesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._networkProperties.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_networkProperties, el), _.org.kevoree.util.Constants.Ref_networkProperties);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP));
                }
              }
            }},
            doAddNetworkProperties: {value: function (networkPropertiesP) {
              var _key_ = (networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._networkProperties.containsKey(_key_)) {
                this._networkProperties.put(_key_, networkPropertiesP);
                (networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP), _.org.kevoree.util.Constants.Ref_networkProperties);
              }
            }},
            addNetworkProperties: {value: function (networkPropertiesP) {
              this.internal_addNetworkProperties(networkPropertiesP, true, true);
            }, writable: true},
            addAllNetworkProperties: {value: function (networkPropertiesP) {
              this.internal_addAllNetworkProperties(networkPropertiesP, true, true);
            }, writable: true},
            internal_addNetworkProperties: {value: function (networkPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNetworkProperties(networkPropertiesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP));
              }
            }},
            internal_addAllNetworkProperties: {value: function (networkPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = networkPropertiesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNetworkProperties(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = networkPropertiesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNetworkProperties(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP));
              }
            }},
            removeNetworkProperties: {value: function (networkPropertiesP) {
              this.internal_removeNetworkProperties(networkPropertiesP, true, true);
            }, writable: true},
            removeAllNetworkProperties: {value: function () {
              this.internal_removeAllNetworkProperties(true, true);
            }, writable: true},
            internal_removeNetworkProperties: {value: function (networkPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._networkProperties.size() !== 0 && this._networkProperties.containsKey((networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).internalGetKey())) {
                this._networkProperties.remove((networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).internalGetKey());
                ((networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()) != null ? networkPropertiesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllNetworkPropertiesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP));
                }
              }
            }},
            internal_removeAllNetworkProperties: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNetworkPropertiesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.networkProperties) != null ? tmp$0 : Kotlin.throwNPE();
              this._networkProperties.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, temp_els));
                this.removeAllNetworkPropertiesCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_networkType) {
                this.internal_networkType(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_estimatedRate) {
                this.internal_estimatedRate(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lastCheck) {
                this.internal_lastCheck(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_zoneID) {
                this.internal_zoneID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_networkProperties) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addNetworkProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllNetworkProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeNetworkProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllNetworkProperties();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._networkProperties.size() !== 0 && this._networkProperties.containsKey(value)) {
                    var obj = this._networkProperties.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._networkProperties.remove(value);
                    this._networkProperties.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findNetworkPropertiesByID: {value: function (key) {
              return this._networkProperties.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_networkProperties) {
                return this.findNetworkPropertiesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_networkProperties, _.org.kevoree.util.Constants.org_kevoree_NetworkProperty);
                {
                  var tmp$0 = this._networkProperties.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._networkProperties.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_networkProperties);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_networkProperties);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.estimatedRate, _.org.kevoree.util.Constants.Att_estimatedRate, this);
              visitor.visit(this.networkType, _.org.kevoree.util.Constants.Att_networkType, this);
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.lastCheck, _.org.kevoree.util.Constants.Att_lastCheck, this);
              visitor.visit(this.zoneID, _.org.kevoree.util.Constants.Att_zoneID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NodeLink;
            }, writable: true}
          })},
          DictionaryValueImpl: {value: Kotlin.createClass([classes.cv, classes.c1a], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$value', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '$attribute', {value: null, writable: true});
            Object.defineProperty(this, '$targetNode', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.DictionaryValueImpl.prototype */ {
            delete: {value: function () {
              this.attribute = null;
              this.targetNode = null;
            }, writable: true},
            value: {
              get: function () {
                return this.$value;
              },
              set: function (iP) {
                this.internal_value(iP, true);
              }
            },
            internal_value: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.value)) {
                var oldPath = this.path();
                this.$value = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_value, this.value));
                }
              }
            }},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            attribute: {
              get: function () {
                return this.$attribute;
              },
              set: function (attributeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_attribute(attributeP, true, true);
              }
            },
            internal_attribute: {value: function (attributeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$attribute, attributeP)) {
                this.$attribute = attributeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_attribute, attributeP));
                }
              }
            }},
            targetNode: {
              get: function () {
                return this.$targetNode;
              },
              set: function (targetNodeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_targetNode(targetNodeP, true, true);
              }
            },
            internal_targetNode: {value: function (targetNodeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$targetNode, targetNodeP)) {
                this.$targetNode = targetNodeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_targetNode, targetNodeP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_value) {
                this.internal_value(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_attribute) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_attribute(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_attribute(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_attribute(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_targetNode) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_targetNode(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_targetNode(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_targetNode(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_attribute) {
                var objFound = this.attribute;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_targetNode) {
                var objFound_0 = this.targetNode;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_attribute, _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute);
                this.internal_visit(visitor, this.attribute, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_attribute);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_attribute);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_targetNode, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.targetNode, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_targetNode);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_targetNode);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.value, _.org.kevoree.util.Constants.Att_value, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryValue;
            }, writable: true}
          })},
          OperationImpl: {value: Kotlin.createClass([classes.cv, classes.c12], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '_parameters', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllParametersCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '$returnType', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.OperationImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._parameters) != null ? tmp$0.clear() : null;
              this.returnType = null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            parameters: {
              get: function () {
                return _.kotlin.toList(this._parameters.values());
              },
              set: function (parametersP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (parametersP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_parameters(parametersP, true, true);
              }
            },
            internal_parameters: {value: function (parametersP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._parameters.values(), parametersP)) {
                this._parameters.clear();
                {
                  var tmp$0 = parametersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._parameters.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_parameters, el), _.org.kevoree.util.Constants.Ref_parameters);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP));
                }
              }
            }},
            doAddParameters: {value: function (parametersP) {
              var _key_ = (parametersP != null ? parametersP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._parameters.containsKey(_key_)) {
                this._parameters.put(_key_, parametersP);
                (parametersP != null ? parametersP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_parameters, parametersP), _.org.kevoree.util.Constants.Ref_parameters);
              }
            }},
            addParameters: {value: function (parametersP) {
              this.internal_addParameters(parametersP, true, true);
            }, writable: true},
            addAllParameters: {value: function (parametersP) {
              this.internal_addAllParameters(parametersP, true, true);
            }, writable: true},
            internal_addParameters: {value: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddParameters(parametersP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP));
              }
            }},
            internal_addAllParameters: {value: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = parametersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddParameters(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = parametersP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddParameters(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP));
              }
            }},
            removeParameters: {value: function (parametersP) {
              this.internal_removeParameters(parametersP, true, true);
            }, writable: true},
            removeAllParameters: {value: function () {
              this.internal_removeAllParameters(true, true);
            }, writable: true},
            internal_removeParameters: {value: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._parameters.size() !== 0 && this._parameters.containsKey((parametersP != null ? parametersP : Kotlin.throwNPE()).internalGetKey())) {
                this._parameters.remove((parametersP != null ? parametersP : Kotlin.throwNPE()).internalGetKey());
                ((parametersP != null ? parametersP : Kotlin.throwNPE()) != null ? parametersP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllParametersCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP));
                }
              }
            }},
            internal_removeAllParameters: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllParametersCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.parameters) != null ? tmp$0 : Kotlin.throwNPE();
              this._parameters.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, temp_els));
                this.removeAllParametersCurrentlyProcessing = false;
              }
            }},
            returnType: {
              get: function () {
                return this.$returnType;
              },
              set: function (returnTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_returnType(returnTypeP, true, true);
              }
            },
            internal_returnType: {value: function (returnTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$returnType, returnTypeP)) {
                this.$returnType = returnTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_returnType, returnTypeP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_parameters) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllParameters();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._parameters.size() !== 0 && this._parameters.containsKey(value)) {
                    var obj = this._parameters.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._parameters.remove(value);
                    this._parameters.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_returnType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_returnType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_returnType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_returnType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findParametersByID: {value: function (key) {
              return this._parameters.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_parameters) {
                return this.findParametersByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_returnType) {
                var objFound = this.returnType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_parameters, _.org.kevoree.util.Constants.org_kevoree_Parameter);
                {
                  var tmp$0 = this._parameters.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._parameters.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_parameters);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_parameters);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_returnType, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                this.internal_visit(visitor, this.returnType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_returnType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_returnType);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Operation;
            }, writable: true}
          })},
          DefaultKevoreeFactory: {value: Kotlin.createClass(classes.c19, null, /** @lends _.org.kevoree.impl.DefaultKevoreeFactory.prototype */ {
            getVersion: {value: function () {
              return '2.0.12-SNAPSHOT';
            }, writable: true},
            createComponentInstance: {value: function () {
              return _.org.kevoree.impl.ComponentInstanceImpl();
            }, writable: true},
            createComponentType: {value: function () {
              return _.org.kevoree.impl.ComponentTypeImpl();
            }, writable: true},
            createContainerNode: {value: function () {
              return _.org.kevoree.impl.ContainerNodeImpl();
            }, writable: true},
            createContainerRoot: {value: function () {
              return _.org.kevoree.impl.ContainerRootImpl();
            }, writable: true},
            createPort: {value: function () {
              return _.org.kevoree.impl.PortImpl();
            }, writable: true},
            createNamespace: {value: function () {
              return _.org.kevoree.impl.NamespaceImpl();
            }, writable: true},
            createDictionary: {value: function () {
              return _.org.kevoree.impl.DictionaryImpl();
            }, writable: true},
            createDictionaryType: {value: function () {
              return _.org.kevoree.impl.DictionaryTypeImpl();
            }, writable: true},
            createDictionaryAttribute: {value: function () {
              return _.org.kevoree.impl.DictionaryAttributeImpl();
            }, writable: true},
            createDictionaryValue: {value: function () {
              return _.org.kevoree.impl.DictionaryValueImpl();
            }, writable: true},
            createCompositeType: {value: function () {
              return _.org.kevoree.impl.CompositeTypeImpl();
            }, writable: true},
            createPortTypeRef: {value: function () {
              return _.org.kevoree.impl.PortTypeRefImpl();
            }, writable: true},
            createWire: {value: function () {
              return _.org.kevoree.impl.WireImpl();
            }, writable: true},
            createServicePortType: {value: function () {
              return _.org.kevoree.impl.ServicePortTypeImpl();
            }, writable: true},
            createOperation: {value: function () {
              return _.org.kevoree.impl.OperationImpl();
            }, writable: true},
            createParameter: {value: function () {
              return _.org.kevoree.impl.ParameterImpl();
            }, writable: true},
            createTypedElement: {value: function () {
              return _.org.kevoree.impl.TypedElementImpl();
            }, writable: true},
            createMessagePortType: {value: function () {
              return _.org.kevoree.impl.MessagePortTypeImpl();
            }, writable: true},
            createRepository: {value: function () {
              return _.org.kevoree.impl.RepositoryImpl();
            }, writable: true},
            createDeployUnit: {value: function () {
              return _.org.kevoree.impl.DeployUnitImpl();
            }, writable: true},
            createTypeLibrary: {value: function () {
              return _.org.kevoree.impl.TypeLibraryImpl();
            }, writable: true},
            createNamedElement: {value: function () {
              return _.org.kevoree.impl.NamedElementImpl();
            }, writable: true},
            createIntegrationPattern: {value: function () {
              return _.org.kevoree.impl.IntegrationPatternImpl();
            }, writable: true},
            createExtraFonctionalProperty: {value: function () {
              return _.org.kevoree.impl.ExtraFonctionalPropertyImpl();
            }, writable: true},
            createPortTypeMapping: {value: function () {
              return _.org.kevoree.impl.PortTypeMappingImpl();
            }, writable: true},
            createChannel: {value: function () {
              return _.org.kevoree.impl.ChannelImpl();
            }, writable: true},
            createMBinding: {value: function () {
              return _.org.kevoree.impl.MBindingImpl();
            }, writable: true},
            createNodeNetwork: {value: function () {
              return _.org.kevoree.impl.NodeNetworkImpl();
            }, writable: true},
            createNodeLink: {value: function () {
              return _.org.kevoree.impl.NodeLinkImpl();
            }, writable: true},
            createNetworkProperty: {value: function () {
              return _.org.kevoree.impl.NetworkPropertyImpl();
            }, writable: true},
            createChannelType: {value: function () {
              return _.org.kevoree.impl.ChannelTypeImpl();
            }, writable: true},
            createInstance: {value: function () {
              return _.org.kevoree.impl.InstanceImpl();
            }, writable: true},
            createGroup: {value: function () {
              return _.org.kevoree.impl.GroupImpl();
            }, writable: true},
            createGroupType: {value: function () {
              return _.org.kevoree.impl.GroupTypeImpl();
            }, writable: true},
            createNodeType: {value: function () {
              return _.org.kevoree.impl.NodeTypeImpl();
            }, writable: true},
            createAdaptationPrimitiveType: {value: function () {
              return _.org.kevoree.impl.AdaptationPrimitiveTypeImpl();
            }, writable: true},
            createAdaptationPrimitiveTypeRef: {value: function () {
              return _.org.kevoree.impl.AdaptationPrimitiveTypeRefImpl();
            }, writable: true},
            create: {value: function (metaClassName) {
              if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ComponentInstance) {
                return this.createComponentInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ComponentInstance) {
                return this.createComponentInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ComponentType) {
                return this.createComponentType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ComponentType) {
                return this.createComponentType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ContainerNode) {
                return this.createContainerNode();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ContainerNode) {
                return this.createContainerNode();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ContainerRoot) {
                return this.createContainerRoot();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ContainerRoot) {
                return this.createContainerRoot();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Port) {
                return this.createPort();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Port) {
                return this.createPort();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Namespace) {
                return this.createNamespace();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Namespace) {
                return this.createNamespace();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Dictionary) {
                return this.createDictionary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Dictionary) {
                return this.createDictionary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryType) {
                return this.createDictionaryType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DictionaryType) {
                return this.createDictionaryType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute) {
                return this.createDictionaryAttribute();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DictionaryAttribute) {
                return this.createDictionaryAttribute();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryValue) {
                return this.createDictionaryValue();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DictionaryValue) {
                return this.createDictionaryValue();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_CompositeType) {
                return this.createCompositeType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_CompositeType) {
                return this.createCompositeType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_PortTypeRef) {
                return this.createPortTypeRef();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_PortTypeRef) {
                return this.createPortTypeRef();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Wire) {
                return this.createWire();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Wire) {
                return this.createWire();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ServicePortType) {
                return this.createServicePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ServicePortType) {
                return this.createServicePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Operation) {
                return this.createOperation();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Operation) {
                return this.createOperation();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Parameter) {
                return this.createParameter();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Parameter) {
                return this.createParameter();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_TypedElement) {
                return this.createTypedElement();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_TypedElement) {
                return this.createTypedElement();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_MessagePortType) {
                return this.createMessagePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_MessagePortType) {
                return this.createMessagePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Repository) {
                return this.createRepository();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Repository) {
                return this.createRepository();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DeployUnit) {
                return this.createDeployUnit();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DeployUnit) {
                return this.createDeployUnit();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_TypeLibrary) {
                return this.createTypeLibrary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_TypeLibrary) {
                return this.createTypeLibrary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NamedElement) {
                return this.createNamedElement();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NamedElement) {
                return this.createNamedElement();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_IntegrationPattern) {
                return this.createIntegrationPattern();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_IntegrationPattern) {
                return this.createIntegrationPattern();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty) {
                return this.createExtraFonctionalProperty();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ExtraFonctionalProperty) {
                return this.createExtraFonctionalProperty();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping) {
                return this.createPortTypeMapping();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_PortTypeMapping) {
                return this.createPortTypeMapping();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Channel) {
                return this.createChannel();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Channel) {
                return this.createChannel();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_MBinding) {
                return this.createMBinding();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_MBinding) {
                return this.createMBinding();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NodeNetwork) {
                return this.createNodeNetwork();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NodeNetwork) {
                return this.createNodeNetwork();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NodeLink) {
                return this.createNodeLink();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NodeLink) {
                return this.createNodeLink();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NetworkProperty) {
                return this.createNetworkProperty();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NetworkProperty) {
                return this.createNetworkProperty();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ChannelType) {
                return this.createChannelType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ChannelType) {
                return this.createChannelType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Instance) {
                return this.createInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Instance) {
                return this.createInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Group) {
                return this.createGroup();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Group) {
                return this.createGroup();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_GroupType) {
                return this.createGroupType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_GroupType) {
                return this.createGroupType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NodeType) {
                return this.createNodeType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NodeType) {
                return this.createNodeType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType) {
                return this.createAdaptationPrimitiveType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_AdaptationPrimitiveType) {
                return this.createAdaptationPrimitiveType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveTypeRef) {
                return this.createAdaptationPrimitiveTypeRef();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_AdaptationPrimitiveTypeRef) {
                return this.createAdaptationPrimitiveTypeRef();
              }
               else {
                return null;
              }
            }, writable: true}
          })},
          ContainerRootImpl: {value: Kotlin.createClass([classes.cv, classes.ct], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_nodes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllNodesCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_typeDefinitions', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllTypeDefinitionsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_repositories', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllRepositoriesCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_dataTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllDataTypesCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_libraries', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllLibrariesCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_hubs', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllHubsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_mBindings', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllMBindingsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllDeployUnitsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_nodeNetworks', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllNodeNetworksCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_groups', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllGroupsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_adaptationPrimitiveTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllAdaptationPrimitiveTypesCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.ContainerRootImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7, tmp$8, tmp$9, tmp$10;
              (tmp$0 = this._nodes) != null ? tmp$0.clear() : null;
              (tmp$1 = this._typeDefinitions) != null ? tmp$1.clear() : null;
              (tmp$2 = this._repositories) != null ? tmp$2.clear() : null;
              (tmp$3 = this._dataTypes) != null ? tmp$3.clear() : null;
              (tmp$4 = this._libraries) != null ? tmp$4.clear() : null;
              (tmp$5 = this._hubs) != null ? tmp$5.clear() : null;
              (tmp$6 = this._mBindings) != null ? tmp$6.clear() : null;
              (tmp$7 = this._deployUnits) != null ? tmp$7.clear() : null;
              (tmp$8 = this._nodeNetworks) != null ? tmp$8.clear() : null;
              (tmp$9 = this._groups) != null ? tmp$9.clear() : null;
              (tmp$10 = this._adaptationPrimitiveTypes) != null ? tmp$10.clear() : null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            nodes: {
              get: function () {
                return _.kotlin.toList(this._nodes.values());
              },
              set: function (nodesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (nodesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_nodes(nodesP, true, true);
              }
            },
            internal_nodes: {value: function (nodesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._nodes.values(), nodesP)) {
                this._nodes.clear();
                {
                  var tmp$0 = nodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._nodes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_nodes, el), _.org.kevoree.util.Constants.Ref_nodes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP));
                }
              }
            }},
            doAddNodes: {value: function (nodesP) {
              var _key_ = (nodesP != null ? nodesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._nodes.containsKey(_key_)) {
                this._nodes.put(_key_, nodesP);
                (nodesP != null ? nodesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_nodes, nodesP), _.org.kevoree.util.Constants.Ref_nodes);
              }
            }},
            addNodes: {value: function (nodesP) {
              this.internal_addNodes(nodesP, true, true);
            }, writable: true},
            addAllNodes: {value: function (nodesP) {
              this.internal_addAllNodes(nodesP, true, true);
            }, writable: true},
            internal_addNodes: {value: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNodes(nodesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP));
              }
            }},
            internal_addAllNodes: {value: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = nodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNodes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = nodesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNodes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP));
              }
            }},
            removeNodes: {value: function (nodesP) {
              this.internal_removeNodes(nodesP, true, true);
            }, writable: true},
            removeAllNodes: {value: function () {
              this.internal_removeAllNodes(true, true);
            }, writable: true},
            internal_removeNodes: {value: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._nodes.size() !== 0 && this._nodes.containsKey((nodesP != null ? nodesP : Kotlin.throwNPE()).internalGetKey())) {
                this._nodes.remove((nodesP != null ? nodesP : Kotlin.throwNPE()).internalGetKey());
                ((nodesP != null ? nodesP : Kotlin.throwNPE()) != null ? nodesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllNodesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP));
                }
              }
            }},
            internal_removeAllNodes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNodesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.nodes) != null ? tmp$0 : Kotlin.throwNPE();
              this._nodes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, temp_els));
                this.removeAllNodesCurrentlyProcessing = false;
              }
            }},
            typeDefinitions: {
              get: function () {
                return _.kotlin.toList(this._typeDefinitions.values());
              },
              set: function (typeDefinitionsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (typeDefinitionsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_typeDefinitions(typeDefinitionsP, true, true);
              }
            },
            internal_typeDefinitions: {value: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._typeDefinitions.values(), typeDefinitionsP)) {
                this._typeDefinitions.clear();
                {
                  var tmp$0 = typeDefinitionsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._typeDefinitions.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_typeDefinitions, el), _.org.kevoree.util.Constants.Ref_typeDefinitions);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP));
                }
              }
            }},
            doAddTypeDefinitions: {value: function (typeDefinitionsP) {
              var _key_ = (typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._typeDefinitions.containsKey(_key_)) {
                this._typeDefinitions.put(_key_, typeDefinitionsP);
                (typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP), _.org.kevoree.util.Constants.Ref_typeDefinitions);
              }
            }},
            addTypeDefinitions: {value: function (typeDefinitionsP) {
              this.internal_addTypeDefinitions(typeDefinitionsP, true, true);
            }, writable: true},
            addAllTypeDefinitions: {value: function (typeDefinitionsP) {
              this.internal_addAllTypeDefinitions(typeDefinitionsP, true, true);
            }, writable: true},
            internal_addTypeDefinitions: {value: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddTypeDefinitions(typeDefinitionsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP));
              }
            }},
            internal_addAllTypeDefinitions: {value: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = typeDefinitionsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddTypeDefinitions(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = typeDefinitionsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddTypeDefinitions(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP));
              }
            }},
            removeTypeDefinitions: {value: function (typeDefinitionsP) {
              this.internal_removeTypeDefinitions(typeDefinitionsP, true, true);
            }, writable: true},
            removeAllTypeDefinitions: {value: function () {
              this.internal_removeAllTypeDefinitions(true, true);
            }, writable: true},
            internal_removeTypeDefinitions: {value: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._typeDefinitions.size() !== 0 && this._typeDefinitions.containsKey((typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).internalGetKey())) {
                this._typeDefinitions.remove((typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).internalGetKey());
                ((typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()) != null ? typeDefinitionsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllTypeDefinitionsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP));
                }
              }
            }},
            internal_removeAllTypeDefinitions: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllTypeDefinitionsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.typeDefinitions) != null ? tmp$0 : Kotlin.throwNPE();
              this._typeDefinitions.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, temp_els));
                this.removeAllTypeDefinitionsCurrentlyProcessing = false;
              }
            }},
            repositories: {
              get: function () {
                return _.kotlin.toList(this._repositories.values());
              },
              set: function (repositoriesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (repositoriesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_repositories(repositoriesP, true, true);
              }
            },
            internal_repositories: {value: function (repositoriesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._repositories.values(), repositoriesP)) {
                this._repositories.clear();
                {
                  var tmp$0 = repositoriesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._repositories.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_repositories, el), _.org.kevoree.util.Constants.Ref_repositories);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP));
                }
              }
            }},
            doAddRepositories: {value: function (repositoriesP) {
              var _key_ = (repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._repositories.containsKey(_key_)) {
                this._repositories.put(_key_, repositoriesP);
                (repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP), _.org.kevoree.util.Constants.Ref_repositories);
              }
            }},
            addRepositories: {value: function (repositoriesP) {
              this.internal_addRepositories(repositoriesP, true, true);
            }, writable: true},
            addAllRepositories: {value: function (repositoriesP) {
              this.internal_addAllRepositories(repositoriesP, true, true);
            }, writable: true},
            internal_addRepositories: {value: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRepositories(repositoriesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP));
              }
            }},
            internal_addAllRepositories: {value: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = repositoriesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRepositories(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = repositoriesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRepositories(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP));
              }
            }},
            removeRepositories: {value: function (repositoriesP) {
              this.internal_removeRepositories(repositoriesP, true, true);
            }, writable: true},
            removeAllRepositories: {value: function () {
              this.internal_removeAllRepositories(true, true);
            }, writable: true},
            internal_removeRepositories: {value: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._repositories.size() !== 0 && this._repositories.containsKey((repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).internalGetKey())) {
                this._repositories.remove((repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).internalGetKey());
                ((repositoriesP != null ? repositoriesP : Kotlin.throwNPE()) != null ? repositoriesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRepositoriesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP));
                }
              }
            }},
            internal_removeAllRepositories: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRepositoriesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.repositories) != null ? tmp$0 : Kotlin.throwNPE();
              this._repositories.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, temp_els));
                this.removeAllRepositoriesCurrentlyProcessing = false;
              }
            }},
            dataTypes: {
              get: function () {
                return _.kotlin.toList(this._dataTypes.values());
              },
              set: function (dataTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (dataTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_dataTypes(dataTypesP, true, true);
              }
            },
            internal_dataTypes: {value: function (dataTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._dataTypes.values(), dataTypesP)) {
                this._dataTypes.clear();
                {
                  var tmp$0 = dataTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._dataTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_dataTypes, el), _.org.kevoree.util.Constants.Ref_dataTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP));
                }
              }
            }},
            doAddDataTypes: {value: function (dataTypesP) {
              var _key_ = (dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._dataTypes.containsKey(_key_)) {
                this._dataTypes.put(_key_, dataTypesP);
                (dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP), _.org.kevoree.util.Constants.Ref_dataTypes);
              }
            }},
            addDataTypes: {value: function (dataTypesP) {
              this.internal_addDataTypes(dataTypesP, true, true);
            }, writable: true},
            addAllDataTypes: {value: function (dataTypesP) {
              this.internal_addAllDataTypes(dataTypesP, true, true);
            }, writable: true},
            internal_addDataTypes: {value: function (dataTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDataTypes(dataTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP));
              }
            }},
            internal_addAllDataTypes: {value: function (dataTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = dataTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDataTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = dataTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDataTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP));
              }
            }},
            removeDataTypes: {value: function (dataTypesP) {
              this.internal_removeDataTypes(dataTypesP, true, true);
            }, writable: true},
            removeAllDataTypes: {value: function () {
              this.internal_removeAllDataTypes(true, true);
            }, writable: true},
            internal_removeDataTypes: {value: function (dataTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._dataTypes.size() !== 0 && this._dataTypes.containsKey((dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._dataTypes.remove((dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).internalGetKey());
                ((dataTypesP != null ? dataTypesP : Kotlin.throwNPE()) != null ? dataTypesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllDataTypesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP));
                }
              }
            }},
            internal_removeAllDataTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllDataTypesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.dataTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._dataTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, temp_els));
                this.removeAllDataTypesCurrentlyProcessing = false;
              }
            }},
            libraries: {
              get: function () {
                return _.kotlin.toList(this._libraries.values());
              },
              set: function (librariesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (librariesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_libraries(librariesP, true, true);
              }
            },
            internal_libraries: {value: function (librariesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._libraries.values(), librariesP)) {
                this._libraries.clear();
                {
                  var tmp$0 = librariesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._libraries.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_libraries, el), _.org.kevoree.util.Constants.Ref_libraries);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP));
                }
              }
            }},
            doAddLibraries: {value: function (librariesP) {
              var _key_ = (librariesP != null ? librariesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._libraries.containsKey(_key_)) {
                this._libraries.put(_key_, librariesP);
                (librariesP != null ? librariesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_libraries, librariesP), _.org.kevoree.util.Constants.Ref_libraries);
              }
            }},
            addLibraries: {value: function (librariesP) {
              this.internal_addLibraries(librariesP, true, true);
            }, writable: true},
            addAllLibraries: {value: function (librariesP) {
              this.internal_addAllLibraries(librariesP, true, true);
            }, writable: true},
            internal_addLibraries: {value: function (librariesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddLibraries(librariesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP));
              }
            }},
            internal_addAllLibraries: {value: function (librariesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = librariesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddLibraries(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = librariesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddLibraries(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP));
              }
            }},
            removeLibraries: {value: function (librariesP) {
              this.internal_removeLibraries(librariesP, true, true);
            }, writable: true},
            removeAllLibraries: {value: function () {
              this.internal_removeAllLibraries(true, true);
            }, writable: true},
            internal_removeLibraries: {value: function (librariesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._libraries.size() !== 0 && this._libraries.containsKey((librariesP != null ? librariesP : Kotlin.throwNPE()).internalGetKey())) {
                this._libraries.remove((librariesP != null ? librariesP : Kotlin.throwNPE()).internalGetKey());
                ((librariesP != null ? librariesP : Kotlin.throwNPE()) != null ? librariesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllLibrariesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP));
                }
              }
            }},
            internal_removeAllLibraries: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllLibrariesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.libraries) != null ? tmp$0 : Kotlin.throwNPE();
              this._libraries.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, temp_els));
                this.removeAllLibrariesCurrentlyProcessing = false;
              }
            }},
            hubs: {
              get: function () {
                return _.kotlin.toList(this._hubs.values());
              },
              set: function (hubsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (hubsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_hubs(hubsP, true, true);
              }
            },
            internal_hubs: {value: function (hubsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._hubs.values(), hubsP)) {
                this._hubs.clear();
                {
                  var tmp$0 = hubsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._hubs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_hubs, el), _.org.kevoree.util.Constants.Ref_hubs);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP));
                }
              }
            }},
            doAddHubs: {value: function (hubsP) {
              var _key_ = (hubsP != null ? hubsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._hubs.containsKey(_key_)) {
                this._hubs.put(_key_, hubsP);
                (hubsP != null ? hubsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_hubs, hubsP), _.org.kevoree.util.Constants.Ref_hubs);
              }
            }},
            addHubs: {value: function (hubsP) {
              this.internal_addHubs(hubsP, true, true);
            }, writable: true},
            addAllHubs: {value: function (hubsP) {
              this.internal_addAllHubs(hubsP, true, true);
            }, writable: true},
            internal_addHubs: {value: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddHubs(hubsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP));
              }
            }},
            internal_addAllHubs: {value: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = hubsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddHubs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = hubsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddHubs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP));
              }
            }},
            removeHubs: {value: function (hubsP) {
              this.internal_removeHubs(hubsP, true, true);
            }, writable: true},
            removeAllHubs: {value: function () {
              this.internal_removeAllHubs(true, true);
            }, writable: true},
            internal_removeHubs: {value: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._hubs.size() !== 0 && this._hubs.containsKey((hubsP != null ? hubsP : Kotlin.throwNPE()).internalGetKey())) {
                this._hubs.remove((hubsP != null ? hubsP : Kotlin.throwNPE()).internalGetKey());
                ((hubsP != null ? hubsP : Kotlin.throwNPE()) != null ? hubsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllHubsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP));
                }
              }
            }},
            internal_removeAllHubs: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllHubsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.hubs) != null ? tmp$0 : Kotlin.throwNPE();
              this._hubs.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, temp_els));
                this.removeAllHubsCurrentlyProcessing = false;
              }
            }},
            mBindings: {
              get: function () {
                return _.kotlin.toList(this._mBindings.values());
              },
              set: function (mBindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (mBindingsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_mBindings(mBindingsP, true, true);
              }
            },
            internal_mBindings: {value: function (mBindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._mBindings.values(), mBindingsP)) {
                this._mBindings.clear();
                {
                  var tmp$0 = mBindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._mBindings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_mBindings, el), _.org.kevoree.util.Constants.Ref_mBindings);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP));
                }
              }
            }},
            doAddMBindings: {value: function (mBindingsP) {
              var _key_ = (mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._mBindings.containsKey(_key_)) {
                this._mBindings.put(_key_, mBindingsP);
                (mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP), _.org.kevoree.util.Constants.Ref_mBindings);
              }
            }},
            addMBindings: {value: function (mBindingsP) {
              this.internal_addMBindings(mBindingsP, true, true);
            }, writable: true},
            addAllMBindings: {value: function (mBindingsP) {
              this.internal_addAllMBindings(mBindingsP, true, true);
            }, writable: true},
            internal_addMBindings: {value: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMBindings(mBindingsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP));
              }
            }},
            internal_addAllMBindings: {value: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = mBindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMBindings(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = mBindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP));
              }
            }},
            removeMBindings: {value: function (mBindingsP) {
              this.internal_removeMBindings(mBindingsP, true, true);
            }, writable: true},
            removeAllMBindings: {value: function () {
              this.internal_removeAllMBindings(true, true);
            }, writable: true},
            internal_removeMBindings: {value: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._mBindings.size() !== 0 && this._mBindings.containsKey((mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._mBindings.remove((mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).internalGetKey());
                ((mBindingsP != null ? mBindingsP : Kotlin.throwNPE()) != null ? mBindingsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllMBindingsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP));
                }
              }
            }},
            internal_removeAllMBindings: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMBindingsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.mBindings) != null ? tmp$0 : Kotlin.throwNPE();
              this._mBindings.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, temp_els));
                this.removeAllMBindingsCurrentlyProcessing = false;
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_deployUnits, el), _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
                (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP), _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                ((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()) != null ? deployUnitsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllDeployUnitsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllDeployUnitsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
                this.removeAllDeployUnitsCurrentlyProcessing = false;
              }
            }},
            nodeNetworks: {
              get: function () {
                return _.kotlin.toList(this._nodeNetworks.values());
              },
              set: function (nodeNetworksP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (nodeNetworksP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_nodeNetworks(nodeNetworksP, true, true);
              }
            },
            internal_nodeNetworks: {value: function (nodeNetworksP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._nodeNetworks.values(), nodeNetworksP)) {
                this._nodeNetworks.clear();
                {
                  var tmp$0 = nodeNetworksP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._nodeNetworks.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_nodeNetworks, el), _.org.kevoree.util.Constants.Ref_nodeNetworks);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP));
                }
              }
            }},
            doAddNodeNetworks: {value: function (nodeNetworksP) {
              var _key_ = (nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._nodeNetworks.containsKey(_key_)) {
                this._nodeNetworks.put(_key_, nodeNetworksP);
                (nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP), _.org.kevoree.util.Constants.Ref_nodeNetworks);
              }
            }},
            addNodeNetworks: {value: function (nodeNetworksP) {
              this.internal_addNodeNetworks(nodeNetworksP, true, true);
            }, writable: true},
            addAllNodeNetworks: {value: function (nodeNetworksP) {
              this.internal_addAllNodeNetworks(nodeNetworksP, true, true);
            }, writable: true},
            internal_addNodeNetworks: {value: function (nodeNetworksP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNodeNetworks(nodeNetworksP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP));
              }
            }},
            internal_addAllNodeNetworks: {value: function (nodeNetworksP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = nodeNetworksP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNodeNetworks(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = nodeNetworksP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNodeNetworks(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP));
              }
            }},
            removeNodeNetworks: {value: function (nodeNetworksP) {
              this.internal_removeNodeNetworks(nodeNetworksP, true, true);
            }, writable: true},
            removeAllNodeNetworks: {value: function () {
              this.internal_removeAllNodeNetworks(true, true);
            }, writable: true},
            internal_removeNodeNetworks: {value: function (nodeNetworksP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._nodeNetworks.size() !== 0 && this._nodeNetworks.containsKey((nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).internalGetKey())) {
                this._nodeNetworks.remove((nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).internalGetKey());
                ((nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()) != null ? nodeNetworksP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllNodeNetworksCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP));
                }
              }
            }},
            internal_removeAllNodeNetworks: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNodeNetworksCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.nodeNetworks) != null ? tmp$0 : Kotlin.throwNPE();
              this._nodeNetworks.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, temp_els));
                this.removeAllNodeNetworksCurrentlyProcessing = false;
              }
            }},
            groups: {
              get: function () {
                return _.kotlin.toList(this._groups.values());
              },
              set: function (groupsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (groupsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_groups(groupsP, true, true);
              }
            },
            internal_groups: {value: function (groupsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._groups.values(), groupsP)) {
                this._groups.clear();
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._groups.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_groups, el), _.org.kevoree.util.Constants.Ref_groups);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP));
                }
              }
            }},
            doAddGroups: {value: function (groupsP) {
              var _key_ = (groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._groups.containsKey(_key_)) {
                this._groups.put(_key_, groupsP);
                (groupsP != null ? groupsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_groups, groupsP), _.org.kevoree.util.Constants.Ref_groups);
              }
            }},
            addGroups: {value: function (groupsP) {
              this.internal_addGroups(groupsP, true, true);
            }, writable: true},
            addAllGroups: {value: function (groupsP) {
              this.internal_addAllGroups(groupsP, true, true);
            }, writable: true},
            internal_addGroups: {value: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGroups(groupsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP));
              }
            }},
            internal_addAllGroups: {value: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGroups(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = groupsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGroups(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP));
              }
            }},
            removeGroups: {value: function (groupsP) {
              this.internal_removeGroups(groupsP, true, true);
            }, writable: true},
            removeAllGroups: {value: function () {
              this.internal_removeAllGroups(true, true);
            }, writable: true},
            internal_removeGroups: {value: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._groups.size() !== 0 && this._groups.containsKey((groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey())) {
                this._groups.remove((groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey());
                ((groupsP != null ? groupsP : Kotlin.throwNPE()) != null ? groupsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllGroupsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP));
                }
              }
            }},
            internal_removeAllGroups: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllGroupsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.groups) != null ? tmp$0 : Kotlin.throwNPE();
              this._groups.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, temp_els));
                this.removeAllGroupsCurrentlyProcessing = false;
              }
            }},
            adaptationPrimitiveTypes: {
              get: function () {
                return _.kotlin.toList(this._adaptationPrimitiveTypes.values());
              },
              set: function (adaptationPrimitiveTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (adaptationPrimitiveTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_adaptationPrimitiveTypes(adaptationPrimitiveTypesP, true, true);
              }
            },
            internal_adaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._adaptationPrimitiveTypes.values(), adaptationPrimitiveTypesP)) {
                this._adaptationPrimitiveTypes.clear();
                {
                  var tmp$0 = adaptationPrimitiveTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._adaptationPrimitiveTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, el), _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP));
                }
              }
            }},
            doAddAdaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP) {
              var _key_ = (adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._adaptationPrimitiveTypes.containsKey(_key_)) {
                this._adaptationPrimitiveTypes.put(_key_, adaptationPrimitiveTypesP);
                (adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP), _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes);
              }
            }},
            addAdaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP) {
              this.internal_addAdaptationPrimitiveTypes(adaptationPrimitiveTypesP, true, true);
            }, writable: true},
            addAllAdaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP) {
              this.internal_addAllAdaptationPrimitiveTypes(adaptationPrimitiveTypesP, true, true);
            }, writable: true},
            internal_addAdaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddAdaptationPrimitiveTypes(adaptationPrimitiveTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP));
              }
            }},
            internal_addAllAdaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = adaptationPrimitiveTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddAdaptationPrimitiveTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = adaptationPrimitiveTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddAdaptationPrimitiveTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP));
              }
            }},
            removeAdaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP) {
              this.internal_removeAdaptationPrimitiveTypes(adaptationPrimitiveTypesP, true, true);
            }, writable: true},
            removeAllAdaptationPrimitiveTypes: {value: function () {
              this.internal_removeAllAdaptationPrimitiveTypes(true, true);
            }, writable: true},
            internal_removeAdaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._adaptationPrimitiveTypes.size() !== 0 && this._adaptationPrimitiveTypes.containsKey((adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._adaptationPrimitiveTypes.remove((adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey());
                ((adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()) != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllAdaptationPrimitiveTypesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP));
                }
              }
            }},
            internal_removeAllAdaptationPrimitiveTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllAdaptationPrimitiveTypesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.adaptationPrimitiveTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._adaptationPrimitiveTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, temp_els));
                this.removeAllAdaptationPrimitiveTypesCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_nodes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllNodes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._nodes.size() !== 0 && this._nodes.containsKey(value)) {
                    var obj = this._nodes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._nodes.remove(value);
                    this._nodes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinitions) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllTypeDefinitions();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._typeDefinitions.size() !== 0 && this._typeDefinitions.containsKey(value)) {
                    var obj_0 = this._typeDefinitions.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._typeDefinitions.remove(value);
                    this._typeDefinitions.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_repositories) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRepositories();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._repositories.size() !== 0 && this._repositories.containsKey(value)) {
                    var obj_1 = this._repositories.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._repositories.remove(value);
                    this._repositories.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dataTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDataTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDataTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDataTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDataTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._dataTypes.size() !== 0 && this._dataTypes.containsKey(value)) {
                    var obj_2 = this._dataTypes.get(value);
                    var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_2 == null) {
                      throw new Error('Key newed to null ' + obj_2);
                    }
                    this._dataTypes.remove(value);
                    this._dataTypes.put(objNewKey_2, obj_2);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_libraries) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addLibraries(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllLibraries(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeLibraries(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllLibraries();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._libraries.size() !== 0 && this._libraries.containsKey(value)) {
                    var obj_3 = this._libraries.get(value);
                    var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_3 == null) {
                      throw new Error('Key newed to null ' + obj_3);
                    }
                    this._libraries.remove(value);
                    this._libraries.put(objNewKey_3, obj_3);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_hubs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllHubs();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._hubs.size() !== 0 && this._hubs.containsKey(value)) {
                    var obj_4 = this._hubs.get(value);
                    var objNewKey_4 = (obj_4 != null ? obj_4 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_4 == null) {
                      throw new Error('Key newed to null ' + obj_4);
                    }
                    this._hubs.remove(value);
                    this._hubs.put(objNewKey_4, obj_4);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_mBindings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllMBindings();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._mBindings.size() !== 0 && this._mBindings.containsKey(value)) {
                    var obj_5 = this._mBindings.get(value);
                    var objNewKey_5 = (obj_5 != null ? obj_5 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_5 == null) {
                      throw new Error('Key newed to null ' + obj_5);
                    }
                    this._mBindings.remove(value);
                    this._mBindings.put(objNewKey_5, obj_5);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj_6 = this._deployUnits.get(value);
                    var objNewKey_6 = (obj_6 != null ? obj_6 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_6 == null) {
                      throw new Error('Key newed to null ' + obj_6);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey_6, obj_6);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_nodeNetworks) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addNodeNetworks(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllNodeNetworks(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeNodeNetworks(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllNodeNetworks();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._nodeNetworks.size() !== 0 && this._nodeNetworks.containsKey(value)) {
                    var obj_7 = this._nodeNetworks.get(value);
                    var objNewKey_7 = (obj_7 != null ? obj_7 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_7 == null) {
                      throw new Error('Key newed to null ' + obj_7);
                    }
                    this._nodeNetworks.remove(value);
                    this._nodeNetworks.put(objNewKey_7, obj_7);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_groups) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllGroups();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._groups.size() !== 0 && this._groups.containsKey(value)) {
                    var obj_8 = this._groups.get(value);
                    var objNewKey_8 = (obj_8 != null ? obj_8 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_8 == null) {
                      throw new Error('Key newed to null ' + obj_8);
                    }
                    this._groups.remove(value);
                    this._groups.put(objNewKey_8, obj_8);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addAdaptationPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllAdaptationPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeAdaptationPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllAdaptationPrimitiveTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._adaptationPrimitiveTypes.size() !== 0 && this._adaptationPrimitiveTypes.containsKey(value)) {
                    var obj_9 = this._adaptationPrimitiveTypes.get(value);
                    var objNewKey_9 = (obj_9 != null ? obj_9 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_9 == null) {
                      throw new Error('Key newed to null ' + obj_9);
                    }
                    this._adaptationPrimitiveTypes.remove(value);
                    this._adaptationPrimitiveTypes.put(objNewKey_9, obj_9);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findNodesByID: {value: function (key) {
              return this._nodes.get(key);
            }, writable: true},
            findTypeDefinitionsByID: {value: function (key) {
              return this._typeDefinitions.get(key);
            }, writable: true},
            findRepositoriesByID: {value: function (key) {
              return this._repositories.get(key);
            }, writable: true},
            findDataTypesByID: {value: function (key) {
              return this._dataTypes.get(key);
            }, writable: true},
            findLibrariesByID: {value: function (key) {
              return this._libraries.get(key);
            }, writable: true},
            findHubsByID: {value: function (key) {
              return this._hubs.get(key);
            }, writable: true},
            findMBindingsByID: {value: function (key) {
              return this._mBindings.get(key);
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findNodeNetworksByID: {value: function (key) {
              return this._nodeNetworks.get(key);
            }, writable: true},
            findGroupsByID: {value: function (key) {
              return this._groups.get(key);
            }, writable: true},
            findAdaptationPrimitiveTypesByID: {value: function (key) {
              return this._adaptationPrimitiveTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_nodes) {
                return this.findNodesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinitions) {
                return this.findTypeDefinitionsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_repositories) {
                return this.findRepositoriesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dataTypes) {
                return this.findDataTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_libraries) {
                return this.findLibrariesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_hubs) {
                return this.findHubsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_mBindings) {
                return this.findMBindingsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_nodeNetworks) {
                return this.findNodeNetworksByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_groups) {
                return this.findGroupsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes) {
                return this.findAdaptationPrimitiveTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_nodes, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                {
                  var tmp$0 = this._nodes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._nodes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_nodes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_nodes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinitions, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$1 = this._typeDefinitions.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._typeDefinitions.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinitions);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinitions);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_repositories, _.org.kevoree.util.Constants.org_kevoree_Repository);
                {
                  var tmp$2 = this._repositories.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._repositories.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_repositories);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_repositories);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dataTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$3 = this._dataTypes.keySet().iterator();
                  while (tmp$3.hasNext()) {
                    var KMFLoopEntryKey_2 = tmp$3.next();
                    this.internal_visit(visitor, this._dataTypes.get(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dataTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dataTypes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_libraries, _.org.kevoree.util.Constants.org_kevoree_TypeLibrary);
                {
                  var tmp$4 = this._libraries.keySet().iterator();
                  while (tmp$4.hasNext()) {
                    var KMFLoopEntryKey_3 = tmp$4.next();
                    this.internal_visit(visitor, this._libraries.get(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_libraries);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_libraries);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hubs, _.org.kevoree.util.Constants.org_kevoree_Channel);
                {
                  var tmp$5 = this._hubs.keySet().iterator();
                  while (tmp$5.hasNext()) {
                    var KMFLoopEntryKey_4 = tmp$5.next();
                    this.internal_visit(visitor, this._hubs.get(KMFLoopEntryKey_4), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hubs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hubs);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_mBindings, _.org.kevoree.util.Constants.org_kevoree_MBinding);
                {
                  var tmp$6 = this._mBindings.keySet().iterator();
                  while (tmp$6.hasNext()) {
                    var KMFLoopEntryKey_5 = tmp$6.next();
                    this.internal_visit(visitor, this._mBindings.get(KMFLoopEntryKey_5), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_mBindings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_mBindings);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$7 = this._deployUnits.keySet().iterator();
                  while (tmp$7.hasNext()) {
                    var KMFLoopEntryKey_6 = tmp$7.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_6), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_nodeNetworks, _.org.kevoree.util.Constants.org_kevoree_NodeNetwork);
                {
                  var tmp$8 = this._nodeNetworks.keySet().iterator();
                  while (tmp$8.hasNext()) {
                    var KMFLoopEntryKey_7 = tmp$8.next();
                    this.internal_visit(visitor, this._nodeNetworks.get(KMFLoopEntryKey_7), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_nodeNetworks);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_nodeNetworks);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_groups, _.org.kevoree.util.Constants.org_kevoree_Group);
                {
                  var tmp$9 = this._groups.keySet().iterator();
                  while (tmp$9.hasNext()) {
                    var KMFLoopEntryKey_8 = tmp$9.next();
                    this.internal_visit(visitor, this._groups.get(KMFLoopEntryKey_8), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_groups);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_groups);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType);
                {
                  var tmp$10 = this._adaptationPrimitiveTypes.keySet().iterator();
                  while (tmp$10.hasNext()) {
                    var KMFLoopEntryKey_9 = tmp$10.next();
                    this.internal_visit(visitor, this._adaptationPrimitiveTypes.get(KMFLoopEntryKey_9), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ContainerRoot;
            }, writable: true}
          })},
          PortImpl: {value: Kotlin.createClass([classes.cv, classes.c1j], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_bindings', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$portTypeRef', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.PortImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._bindings) != null ? tmp$0.clear() : null;
              this.portTypeRef = null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            bindings: {
              get: function () {
                return _.kotlin.toList(this._bindings.values());
              },
              set: function (bindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (bindingsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_bindings(bindingsP, true, true);
              }
            },
            internal_bindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._bindings.values(), bindingsP)) {
                this.internal_removeAllBindings(true, false);
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._bindings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
                }
              }
            }},
            doAddBindings: {value: function (bindingsP) {
              var _key_ = (bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._bindings.containsKey(_key_)) {
                this._bindings.put(_key_, bindingsP);
              }
            }},
            addBindings: {value: function (bindingsP) {
              this.internal_addBindings(bindingsP, true, true);
            }, writable: true},
            addAllBindings: {value: function (bindingsP) {
              this.internal_addAllBindings(bindingsP, true, true);
            }, writable: true},
            internal_addBindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddBindings(bindingsP);
              if (setOpposite) {
                (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
              }
            }},
            internal_addAllBindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddBindings(el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = bindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
              }
            }},
            removeBindings: {value: function (bindingsP) {
              this.internal_removeBindings(bindingsP, true, true);
            }, writable: true},
            removeAllBindings: {value: function () {
              this.internal_removeAllBindings(true, true);
            }, writable: true},
            internal_removeBindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._bindings.size() !== 0 && this._bindings.containsKey((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._bindings.remove((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
                }
                if (setOpposite) {
                  (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, null, false, fireEvents);
                }
              }
            }},
            internal_removeAllBindings: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.bindings) != null ? tmp$0 : Kotlin.throwNPE();
              if (setOpposite) {
                {
                  var tmp$1 = (temp_els != null ? temp_els : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var el = tmp$1.next();
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, null, false, fireEvents);
                  }
                }
              }
              this._bindings.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, temp_els));
              }
            }},
            portTypeRef: {
              get: function () {
                return this.$portTypeRef;
              },
              set: function (portTypeRefP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_portTypeRef(portTypeRefP, true, true);
              }
            },
            internal_portTypeRef: {value: function (portTypeRefP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$portTypeRef, portTypeRefP)) {
                this.$portTypeRef = portTypeRefP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypeRef, portTypeRefP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_bindings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.internal_removeAllBindings(setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._bindings.size() !== 0 && this._bindings.containsKey(value)) {
                    var obj = this._bindings.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._bindings.remove(value);
                    this._bindings.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_portTypeRef) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_portTypeRef(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_portTypeRef(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_portTypeRef(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findBindingsByID: {value: function (key) {
              return this._bindings.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_bindings) {
                return this.findBindingsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_portTypeRef) {
                var objFound = this.portTypeRef;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_bindings, _.org.kevoree.util.Constants.org_kevoree_MBinding);
                {
                  var tmp$0 = this._bindings.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._bindings.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_bindings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_bindings);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_portTypeRef, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                this.internal_visit(visitor, this.portTypeRef, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_portTypeRef);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_portTypeRef);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Port;
            }, writable: true}
          })},
          RepositoryImpl: {value: Kotlin.createClass([classes.cv, classes.co], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$url', {value: null, writable: true});
            Object.defineProperty(this, '_units', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.RepositoryImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._units) != null ? tmp$0.clear() : null;
            }, writable: true},
            url: {
              get: function () {
                return this.$url;
              },
              set: function (iP) {
                this.internal_url(iP, true);
              }
            },
            internal_url: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.url)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$url = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_url, this.url));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_url, this.path()));
                }
              }
            }},
            units: {
              get: function () {
                return _.kotlin.toList(this._units.values());
              },
              set: function (unitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (unitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_units(unitsP, true, true);
              }
            },
            internal_units: {value: function (unitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._units.values(), unitsP)) {
                this._units.clear();
                {
                  var tmp$0 = unitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._units.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP));
                }
              }
            }},
            doAddUnits: {value: function (unitsP) {
              var _key_ = (unitsP != null ? unitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._units.containsKey(_key_)) {
                this._units.put(_key_, unitsP);
              }
            }},
            addUnits: {value: function (unitsP) {
              this.internal_addUnits(unitsP, true, true);
            }, writable: true},
            addAllUnits: {value: function (unitsP) {
              this.internal_addAllUnits(unitsP, true, true);
            }, writable: true},
            internal_addUnits: {value: function (unitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddUnits(unitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP));
              }
            }},
            internal_addAllUnits: {value: function (unitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = unitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = unitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP));
              }
            }},
            removeUnits: {value: function (unitsP) {
              this.internal_removeUnits(unitsP, true, true);
            }, writable: true},
            removeAllUnits: {value: function () {
              this.internal_removeAllUnits(true, true);
            }, writable: true},
            internal_removeUnits: {value: function (unitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._units.size() !== 0 && this._units.containsKey((unitsP != null ? unitsP : Kotlin.throwNPE()).internalGetKey())) {
                this._units.remove((unitsP != null ? unitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP));
                }
              }
            }},
            internal_removeAllUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.units) != null ? tmp$0 : Kotlin.throwNPE();
              this._units.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_url) {
                this.internal_url(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_units) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._units.size() !== 0 && this._units.containsKey(value)) {
                    var obj = this._units.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._units.remove(value);
                    this._units.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.url;
            }, writable: true},
            findUnitsByID: {value: function (key) {
              return this._units.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_units) {
                return this.findUnitsByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_units, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._units.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._units.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_units);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_units);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.url, _.org.kevoree.util.Constants.Att_url, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Repository;
            }, writable: true}
          })},
          DictionaryImpl: {value: Kotlin.createClass([classes.cv, classes.c1l], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_values', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllValuesCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.DictionaryImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._values) != null ? tmp$0.clear() : null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            values: {
              get: function () {
                return _.kotlin.toList(this._values.values());
              },
              set: function (valuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (valuesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_values(valuesP, true, true);
              }
            },
            internal_values: {value: function (valuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._values.values(), valuesP)) {
                this._values.clear();
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._values.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_values, el), _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP));
                }
              }
            }},
            doAddValues: {value: function (valuesP) {
              var _key_ = (valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._values.containsKey(_key_)) {
                this._values.put(_key_, valuesP);
                (valuesP != null ? valuesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_values, valuesP), _.org.kevoree.util.Constants.Ref_values);
              }
            }},
            addValues: {value: function (valuesP) {
              this.internal_addValues(valuesP, true, true);
            }, writable: true},
            addAllValues: {value: function (valuesP) {
              this.internal_addAllValues(valuesP, true, true);
            }, writable: true},
            internal_addValues: {value: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddValues(valuesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP));
              }
            }},
            internal_addAllValues: {value: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = valuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP));
              }
            }},
            removeValues: {value: function (valuesP) {
              this.internal_removeValues(valuesP, true, true);
            }, writable: true},
            removeAllValues: {value: function () {
              this.internal_removeAllValues(true, true);
            }, writable: true},
            internal_removeValues: {value: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._values.size() !== 0 && this._values.containsKey((valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey())) {
                this._values.remove((valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey());
                ((valuesP != null ? valuesP : Kotlin.throwNPE()) != null ? valuesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP));
                }
              }
            }},
            internal_removeAllValues: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllValuesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.values) != null ? tmp$0 : Kotlin.throwNPE();
              this._values.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, temp_els));
                this.removeAllValuesCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_values) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllValues();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._values.size() !== 0 && this._values.containsKey(value)) {
                    var obj = this._values.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._values.remove(value);
                    this._values.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findValuesByID: {value: function (key) {
              return this._values.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_values) {
                return this.findValuesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_values, _.org.kevoree.util.Constants.org_kevoree_DictionaryValue);
                {
                  var tmp$0 = this._values.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._values.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_values);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Dictionary;
            }, writable: true}
          })},
          TypeLibraryImpl: {value: Kotlin.createClass([classes.cv, classes.c1i], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '_subTypes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.TypeLibraryImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._subTypes) != null ? tmp$0.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            subTypes: {
              get: function () {
                return _.kotlin.toList(this._subTypes.values());
              },
              set: function (subTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (subTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_subTypes(subTypesP, true, true);
              }
            },
            internal_subTypes: {value: function (subTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._subTypes.values(), subTypesP)) {
                this._subTypes.clear();
                {
                  var tmp$0 = subTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._subTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP));
                }
              }
            }},
            doAddSubTypes: {value: function (subTypesP) {
              var _key_ = (subTypesP != null ? subTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._subTypes.containsKey(_key_)) {
                this._subTypes.put(_key_, subTypesP);
              }
            }},
            addSubTypes: {value: function (subTypesP) {
              this.internal_addSubTypes(subTypesP, true, true);
            }, writable: true},
            addAllSubTypes: {value: function (subTypesP) {
              this.internal_addAllSubTypes(subTypesP, true, true);
            }, writable: true},
            internal_addSubTypes: {value: function (subTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSubTypes(subTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP));
              }
            }},
            internal_addAllSubTypes: {value: function (subTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = subTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSubTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = subTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSubTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP));
              }
            }},
            removeSubTypes: {value: function (subTypesP) {
              this.internal_removeSubTypes(subTypesP, true, true);
            }, writable: true},
            removeAllSubTypes: {value: function () {
              this.internal_removeAllSubTypes(true, true);
            }, writable: true},
            internal_removeSubTypes: {value: function (subTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._subTypes.size() !== 0 && this._subTypes.containsKey((subTypesP != null ? subTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._subTypes.remove((subTypesP != null ? subTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP));
                }
              }
            }},
            internal_removeAllSubTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.subTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._subTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_subTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSubTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSubTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSubTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSubTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._subTypes.size() !== 0 && this._subTypes.containsKey(value)) {
                    var obj = this._subTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._subTypes.remove(value);
                    this._subTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findSubTypesByID: {value: function (key) {
              return this._subTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_subTypes) {
                return this.findSubTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_subTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$0 = this._subTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._subTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_subTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_subTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_TypeLibrary;
            }, writable: true}
          })},
          PortTypeMappingImpl: {value: Kotlin.createClass([classes.cv, classes.c1b], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$beanMethodName', {value: null, writable: true});
            Object.defineProperty(this, '$serviceMethodName', {value: null, writable: true});
            Object.defineProperty(this, '$paramTypes', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
          }, /** @lends _.org.kevoree.impl.PortTypeMappingImpl.prototype */ {
            delete: {value: function () {
            }, writable: true},
            beanMethodName: {
              get: function () {
                return this.$beanMethodName;
              },
              set: function (iP) {
                this.internal_beanMethodName(iP, true);
              }
            },
            internal_beanMethodName: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.beanMethodName)) {
                var oldPath = this.path();
                this.$beanMethodName = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_beanMethodName, this.beanMethodName));
                }
              }
            }},
            serviceMethodName: {
              get: function () {
                return this.$serviceMethodName;
              },
              set: function (iP) {
                this.internal_serviceMethodName(iP, true);
              }
            },
            internal_serviceMethodName: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.serviceMethodName)) {
                var oldPath = this.path();
                this.$serviceMethodName = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_serviceMethodName, this.serviceMethodName));
                }
              }
            }},
            paramTypes: {
              get: function () {
                return this.$paramTypes;
              },
              set: function (iP) {
                this.internal_paramTypes(iP, true);
              }
            },
            internal_paramTypes: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.paramTypes)) {
                var oldPath = this.path();
                this.$paramTypes = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_paramTypes, this.paramTypes));
                }
              }
            }},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_beanMethodName) {
                this.internal_beanMethodName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_serviceMethodName) {
                this.internal_serviceMethodName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_paramTypes) {
                this.internal_paramTypes(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.paramTypes, _.org.kevoree.util.Constants.Att_paramTypes, this);
              visitor.visit(this.serviceMethodName, _.org.kevoree.util.Constants.Att_serviceMethodName, this);
              visitor.visit(this.beanMethodName, _.org.kevoree.util.Constants.Att_beanMethodName, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping;
            }, writable: true}
          })},
          WireImpl: {value: Kotlin.createClass([classes.cv, classes.cm], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_ports', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.WireImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._ports) != null ? tmp$0.clear() : null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            ports: {
              get: function () {
                return _.kotlin.toList(this._ports.values());
              },
              set: function (portsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (portsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_ports(portsP, true, true);
              }
            },
            internal_ports: {value: function (portsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._ports.values(), portsP)) {
                this._ports.clear();
                {
                  var tmp$0 = portsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._ports.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, portsP));
                }
              }
            }},
            doAddPorts: {value: function (portsP) {
              var _key_ = (portsP != null ? portsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._ports.containsKey(_key_)) {
                this._ports.put(_key_, portsP);
              }
            }},
            addPorts: {value: function (portsP) {
              this.internal_addPorts(portsP, true, true);
            }, writable: true},
            addAllPorts: {value: function (portsP) {
              this.internal_addAllPorts(portsP, true, true);
            }, writable: true},
            internal_addPorts: {value: function (portsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddPorts(portsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, portsP));
              }
            }},
            internal_addAllPorts: {value: function (portsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = portsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddPorts(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = portsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddPorts(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, portsP));
              }
            }},
            removePorts: {value: function (portsP) {
              this.internal_removePorts(portsP, true, true);
            }, writable: true},
            removeAllPorts: {value: function () {
              this.internal_removeAllPorts(true, true);
            }, writable: true},
            internal_removePorts: {value: function (portsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._ports) === 2 && this._ports.containsKey((portsP != null ? portsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of portsP must contain at least 2 element. Can not remove sizeof(portsP)=' + _.kotlin.get_size(this._ports));
              }
               else {
                this._ports.remove((portsP != null ? portsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, portsP));
                }
              }
            }},
            internal_removeAllPorts: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.ports) != null ? tmp$0 : Kotlin.throwNPE();
              this._ports.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_ports) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addPorts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllPorts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removePorts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllPorts();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._ports.size() !== 0 && this._ports.containsKey(value)) {
                    var obj = this._ports.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._ports.remove(value);
                    this._ports.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findPortsByID: {value: function (key) {
              return this._ports.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_ports) {
                return this.findPortsByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_ports, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$0 = this._ports.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._ports.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_ports);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_ports);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Wire;
            }, writable: true}
          })},
          MBindingImpl: {value: Kotlin.createClass([classes.cv, classes.c10], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '$port', {value: null, writable: true});
            Object.defineProperty(this, '$hub', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.MBindingImpl.prototype */ {
            delete: {value: function () {
              this.port = null;
              this.hub = null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            port: {
              get: function () {
                return this.$port;
              },
              set: function (portP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_port(portP, true, true);
              }
            },
            internal_port: {value: function (portP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$port, portP)) {
                if (setOpposite) {
                  if (this.$port != null) {
                    var tmp$0;
                    ((tmp$0 = this.$port) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                  if (portP != null) {
                    portP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                }
                this.$port = portP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_port, portP));
                }
              }
            }},
            hub: {
              get: function () {
                return this.$hub;
              },
              set: function (hubP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_hub(hubP, true, true);
              }
            },
            internal_hub: {value: function (hubP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$hub, hubP)) {
                if (setOpposite) {
                  if (this.$hub != null) {
                    var tmp$0;
                    ((tmp$0 = this.$hub) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                  if (hubP != null) {
                    hubP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                }
                this.$hub = hubP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hub, hubP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_port) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_port(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_port(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_port(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_hub) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_hub(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_hub(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_hub(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_port) {
                var objFound = this.port;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_hub) {
                var objFound_0 = this.hub;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_port, _.org.kevoree.util.Constants.org_kevoree_Port);
                this.internal_visit(visitor, this.port, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_port);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_port);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hub, _.org.kevoree.util.Constants.org_kevoree_Channel);
                this.internal_visit(visitor, this.hub, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hub);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hub);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_MBinding;
            }, writable: true}
          })},
          ComponentTypeImpl: {value: Kotlin.createClass([classes.cv, classes.c1g], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$factoryBean', {value: null, writable: true});
            Object.defineProperty(this, '$bean', {value: null, writable: true});
            Object.defineProperty(this, '$abstract', {value: null, writable: true});
            Object.defineProperty(this, '$startMethod', {value: null, writable: true});
            Object.defineProperty(this, '$stopMethod', {value: null, writable: true});
            Object.defineProperty(this, '$updateMethod', {value: null, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$dictionaryType', {value: null, writable: true});
            Object.defineProperty(this, '_superTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '_required', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllRequiredCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_integrationPatterns', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllIntegrationPatternsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '$extraFonctionalProperties', {value: null, writable: true});
            Object.defineProperty(this, '_provided', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllProvidedCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.ComponentTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._required) != null ? tmp$2.clear() : null;
              (tmp$3 = this._integrationPatterns) != null ? tmp$3.clear() : null;
              this.extraFonctionalProperties = null;
              (tmp$4 = this._provided) != null ? tmp$4.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            }},
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            }},
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            }},
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            }},
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            }},
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            }},
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: {value: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            }},
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            doAddSuperTypes: {value: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            }},
            addSuperTypes: {value: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            }, writable: true},
            addAllSuperTypes: {value: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            }, writable: true},
            internal_addSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            internal_addAllSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            removeSuperTypes: {value: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            }, writable: true},
            removeAllSuperTypes: {value: function () {
              this.internal_removeAllSuperTypes(true, true);
            }, writable: true},
            internal_removeSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            internal_removeAllSuperTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            }},
            required: {
              get: function () {
                return _.kotlin.toList(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: {value: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            }},
            doAddRequired: {value: function (requiredP) {
              var _key_ = (requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey(_key_)) {
                this._required.put(_key_, requiredP);
                (requiredP != null ? requiredP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
              }
            }},
            addRequired: {value: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
            }, writable: true},
            addAllRequired: {value: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
            }, writable: true},
            internal_addRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            }},
            internal_addAllRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            }},
            removeRequired: {value: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
            }, writable: true},
            removeAllRequired: {value: function () {
              this.internal_removeAllRequired(true, true);
            }, writable: true},
            internal_removeRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey())) {
                this._required.remove((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey());
                ((requiredP != null ? requiredP : Kotlin.throwNPE()) != null ? requiredP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            }},
            internal_removeAllRequired: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.required) != null ? tmp$0 : Kotlin.throwNPE();
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            }},
            integrationPatterns: {
              get: function () {
                return _.kotlin.toList(this._integrationPatterns.values());
              },
              set: function (integrationPatternsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (integrationPatternsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_integrationPatterns(integrationPatternsP, true, true);
              }
            },
            internal_integrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._integrationPatterns.values(), integrationPatternsP)) {
                this._integrationPatterns.clear();
                {
                  var tmp$0 = integrationPatternsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._integrationPatterns.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_integrationPatterns, el), _.org.kevoree.util.Constants.Ref_integrationPatterns);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
                }
              }
            }},
            doAddIntegrationPatterns: {value: function (integrationPatternsP) {
              var _key_ = (integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._integrationPatterns.containsKey(_key_)) {
                this._integrationPatterns.put(_key_, integrationPatternsP);
                (integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP), _.org.kevoree.util.Constants.Ref_integrationPatterns);
              }
            }},
            addIntegrationPatterns: {value: function (integrationPatternsP) {
              this.internal_addIntegrationPatterns(integrationPatternsP, true, true);
            }, writable: true},
            addAllIntegrationPatterns: {value: function (integrationPatternsP) {
              this.internal_addAllIntegrationPatterns(integrationPatternsP, true, true);
            }, writable: true},
            internal_addIntegrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddIntegrationPatterns(integrationPatternsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
              }
            }},
            internal_addAllIntegrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = integrationPatternsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddIntegrationPatterns(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = integrationPatternsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddIntegrationPatterns(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
              }
            }},
            removeIntegrationPatterns: {value: function (integrationPatternsP) {
              this.internal_removeIntegrationPatterns(integrationPatternsP, true, true);
            }, writable: true},
            removeAllIntegrationPatterns: {value: function () {
              this.internal_removeAllIntegrationPatterns(true, true);
            }, writable: true},
            internal_removeIntegrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._integrationPatterns.size() !== 0 && this._integrationPatterns.containsKey((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey())) {
                this._integrationPatterns.remove((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey());
                ((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()) != null ? integrationPatternsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllIntegrationPatternsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
                }
              }
            }},
            internal_removeAllIntegrationPatterns: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllIntegrationPatternsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.integrationPatterns) != null ? tmp$0 : Kotlin.throwNPE();
              this._integrationPatterns.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, temp_els));
                this.removeAllIntegrationPatternsCurrentlyProcessing = false;
              }
            }},
            extraFonctionalProperties: {
              get: function () {
                return this.$extraFonctionalProperties;
              },
              set: function (extraFonctionalPropertiesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_extraFonctionalProperties(extraFonctionalPropertiesP, true, true);
              }
            },
            internal_extraFonctionalProperties: {value: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$extraFonctionalProperties, extraFonctionalPropertiesP)) {
                if (this.$extraFonctionalProperties != null) {
                  var tmp$0;
                  (((tmp$0 = this.$extraFonctionalProperties) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (extraFonctionalPropertiesP != null) {
                  (extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                }
                this.$extraFonctionalProperties = extraFonctionalPropertiesP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
                }
              }
            }},
            provided: {
              get: function () {
                return _.kotlin.toList(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: {value: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            }},
            doAddProvided: {value: function (providedP) {
              var _key_ = (providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey(_key_)) {
                this._provided.put(_key_, providedP);
                (providedP != null ? providedP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
              }
            }},
            addProvided: {value: function (providedP) {
              this.internal_addProvided(providedP, true, true);
            }, writable: true},
            addAllProvided: {value: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
            }, writable: true},
            internal_addProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            }},
            internal_addAllProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            }},
            removeProvided: {value: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
            }, writable: true},
            removeAllProvided: {value: function () {
              this.internal_removeAllProvided(true, true);
            }, writable: true},
            internal_removeProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey())) {
                this._provided.remove((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey());
                ((providedP != null ? providedP : Kotlin.throwNPE()) != null ? providedP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            }},
            internal_removeAllProvided: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.provided) != null ? tmp$0 : Kotlin.throwNPE();
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRequired();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._required.size() !== 0 && this._required.containsKey(value)) {
                    var obj_1 = this._required.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._required.remove(value);
                    this._required.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_integrationPatterns) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllIntegrationPatterns();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._integrationPatterns.size() !== 0 && this._integrationPatterns.containsKey(value)) {
                    var obj_2 = this._integrationPatterns.get(value);
                    var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_2 == null) {
                      throw new Error('Key newed to null ' + obj_2);
                    }
                    this._integrationPatterns.remove(value);
                    this._integrationPatterns.put(objNewKey_2, obj_2);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_extraFonctionalProperties(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_extraFonctionalProperties(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_extraFonctionalProperties(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllProvided();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._provided.size() !== 0 && this._provided.containsKey(value)) {
                    var obj_3 = this._provided.get(value);
                    var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_3 == null) {
                      throw new Error('Key newed to null ' + obj_3);
                    }
                    this._provided.remove(value);
                    this._provided.put(objNewKey_3, obj_3);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findSuperTypesByID: {value: function (key) {
              return this._superTypes.get(key);
            }, writable: true},
            findRequiredByID: {value: function (key) {
              return this._required.get(key);
            }, writable: true},
            findIntegrationPatternsByID: {value: function (key) {
              return this._integrationPatterns.get(key);
            }, writable: true},
            findProvidedByID: {value: function (key) {
              return this._provided.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                return this.findRequiredByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_integrationPatterns) {
                return this.findIntegrationPatternsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                var objFound_0 = this.extraFonctionalProperties;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                return this.findProvidedByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$0 = this._required.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._required.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_integrationPatterns, _.org.kevoree.util.Constants.org_kevoree_IntegrationPattern);
                {
                  var tmp$1 = this._integrationPatterns.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._integrationPatterns.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_integrationPatterns);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_integrationPatterns);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties, _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty);
                this.internal_visit(visitor, this.extraFonctionalProperties, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$2 = this._provided.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._provided.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$3 = this._deployUnits.keySet().iterator();
                  while (tmp$3.hasNext()) {
                    var KMFLoopEntryKey_2 = tmp$3.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$4 = this._superTypes.keySet().iterator();
                  while (tmp$4.hasNext()) {
                    var KMFLoopEntryKey_3 = tmp$4.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ComponentType;
            }, writable: true}
          })},
          ExtraFonctionalPropertyImpl: {value: Kotlin.createClass([classes.cv, classes.c1d], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_portTypes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.ExtraFonctionalPropertyImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._portTypes) != null ? tmp$0.clear() : null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            portTypes: {
              get: function () {
                return _.kotlin.toList(this._portTypes.values());
              },
              set: function (portTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (portTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_portTypes(portTypesP, true, true);
              }
            },
            internal_portTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._portTypes.values(), portTypesP)) {
                this._portTypes.clear();
                {
                  var tmp$0 = portTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._portTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
                }
              }
            }},
            doAddPortTypes: {value: function (portTypesP) {
              var _key_ = (portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._portTypes.containsKey(_key_)) {
                this._portTypes.put(_key_, portTypesP);
              }
            }},
            addPortTypes: {value: function (portTypesP) {
              this.internal_addPortTypes(portTypesP, true, true);
            }, writable: true},
            addAllPortTypes: {value: function (portTypesP) {
              this.internal_addAllPortTypes(portTypesP, true, true);
            }, writable: true},
            internal_addPortTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddPortTypes(portTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
              }
            }},
            internal_addAllPortTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = portTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddPortTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = portTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddPortTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
              }
            }},
            removePortTypes: {value: function (portTypesP) {
              this.internal_removePortTypes(portTypesP, true, true);
            }, writable: true},
            removeAllPortTypes: {value: function () {
              this.internal_removeAllPortTypes(true, true);
            }, writable: true},
            internal_removePortTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._portTypes.size() !== 0 && this._portTypes.containsKey((portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._portTypes.remove((portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
                }
              }
            }},
            internal_removeAllPortTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.portTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._portTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_portTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addPortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllPortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removePortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllPortTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._portTypes.size() !== 0 && this._portTypes.containsKey(value)) {
                    var obj = this._portTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._portTypes.remove(value);
                    this._portTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findPortTypesByID: {value: function (key) {
              return this._portTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_portTypes) {
                return this.findPortTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_portTypes, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$0 = this._portTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._portTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_portTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_portTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty;
            }, writable: true}
          })},
          PortTypeRefImpl: {value: Kotlin.createClass([classes.cv, classes.c16], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$optional', {value: null, writable: true});
            Object.defineProperty(this, '$noDependency', {value: null, writable: true});
            Object.defineProperty(this, '$ref', {value: null, writable: true});
            Object.defineProperty(this, '_mappings', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllMappingsCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.PortTypeRefImpl.prototype */ {
            delete: {value: function () {
              this.ref = null;
              var tmp$0;
              (tmp$0 = this._mappings) != null ? tmp$0.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            optional: {
              get: function () {
                return this.$optional;
              },
              set: function (iP) {
                this.internal_optional(iP, true);
              }
            },
            internal_optional: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.optional)) {
                var oldPath = this.path();
                this.$optional = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_optional, this.optional));
                }
              }
            }},
            noDependency: {
              get: function () {
                return this.$noDependency;
              },
              set: function (iP) {
                this.internal_noDependency(iP, true);
              }
            },
            internal_noDependency: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.noDependency)) {
                var oldPath = this.path();
                this.$noDependency = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_noDependency, this.noDependency));
                }
              }
            }},
            ref: {
              get: function () {
                return this.$ref;
              },
              set: function (refP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_ref(refP, true, true);
              }
            },
            internal_ref: {value: function (refP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$ref, refP)) {
                this.$ref = refP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ref, refP));
                }
              }
            }},
            mappings: {
              get: function () {
                return _.kotlin.toList(this._mappings.values());
              },
              set: function (mappingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (mappingsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_mappings(mappingsP, true, true);
              }
            },
            internal_mappings: {value: function (mappingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._mappings.values(), mappingsP)) {
                this._mappings.clear();
                {
                  var tmp$0 = mappingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._mappings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_mappings, el), _.org.kevoree.util.Constants.Ref_mappings);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP));
                }
              }
            }},
            doAddMappings: {value: function (mappingsP) {
              var _key_ = (mappingsP != null ? mappingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._mappings.containsKey(_key_)) {
                this._mappings.put(_key_, mappingsP);
                (mappingsP != null ? mappingsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_mappings, mappingsP), _.org.kevoree.util.Constants.Ref_mappings);
              }
            }},
            addMappings: {value: function (mappingsP) {
              this.internal_addMappings(mappingsP, true, true);
            }, writable: true},
            addAllMappings: {value: function (mappingsP) {
              this.internal_addAllMappings(mappingsP, true, true);
            }, writable: true},
            internal_addMappings: {value: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMappings(mappingsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP));
              }
            }},
            internal_addAllMappings: {value: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = mappingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMappings(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = mappingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMappings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP));
              }
            }},
            removeMappings: {value: function (mappingsP) {
              this.internal_removeMappings(mappingsP, true, true);
            }, writable: true},
            removeAllMappings: {value: function () {
              this.internal_removeAllMappings(true, true);
            }, writable: true},
            internal_removeMappings: {value: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._mappings.size() !== 0 && this._mappings.containsKey((mappingsP != null ? mappingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._mappings.remove((mappingsP != null ? mappingsP : Kotlin.throwNPE()).internalGetKey());
                ((mappingsP != null ? mappingsP : Kotlin.throwNPE()) != null ? mappingsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllMappingsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP));
                }
              }
            }},
            internal_removeAllMappings: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMappingsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.mappings) != null ? tmp$0 : Kotlin.throwNPE();
              this._mappings.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, temp_els));
                this.removeAllMappingsCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_optional) {
                this.internal_optional(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_noDependency) {
                this.internal_noDependency(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_ref) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_ref(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_ref(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_ref(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_mappings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllMappings();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._mappings.size() !== 0 && this._mappings.containsKey(value)) {
                    var obj = this._mappings.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._mappings.remove(value);
                    this._mappings.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findMappingsByID: {value: function (key) {
              return this._mappings.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_ref) {
                var objFound = this.ref;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_mappings) {
                return this.findMappingsByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_mappings, _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping);
                {
                  var tmp$0 = this._mappings.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._mappings.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_mappings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_mappings);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_ref, _.org.kevoree.util.Constants.org_kevoree_PortType);
                this.internal_visit(visitor, this.ref, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_ref);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_ref);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.noDependency, _.org.kevoree.util.Constants.Att_noDependency, this);
              visitor.visit(this.optional, _.org.kevoree.util.Constants.Att_optional, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_PortTypeRef;
            }, writable: true}
          })}
        }),
        modeling: Kotlin.definePackage(null, {
          api: Kotlin.definePackage(null, {
            ModelLoader: {value: classes.c4},
            KMFFactory: {value: classes.c5},
            ModelCloner: {value: classes.c8},
            ModelSerializer: {value: classes.ca},
            KMFContainer: {value: classes.ci},
            xmi: Kotlin.definePackage(function () {
              Object.defineProperty(this, 'Token', {value: Kotlin.createObject(null, function () {
                Object.defineProperty(this, 'XML_HEADER', {value: 0});
                Object.defineProperty(this, 'END_DOCUMENT', {value: 1});
                Object.defineProperty(this, 'START_TAG', {value: 2});
                Object.defineProperty(this, 'END_TAG', {value: 3});
                Object.defineProperty(this, 'COMMENT', {value: 4});
                Object.defineProperty(this, 'SINGLETON_TAG', {value: 5});
              })});
            }, {
              XMIModelLoader: {value: classes.c6},
              LoadingContext: {value: Kotlin.createClass(null, function () {
                Object.defineProperty(this, 'xmiReader', {value: null, writable: true});
                Object.defineProperty(this, 'loadedRoots', {value: Kotlin.ArrayList(0), writable: true});
                Object.defineProperty(this, 'map', {value: Kotlin.PrimitiveHashMap(0)});
                Object.defineProperty(this, 'elementsCount', {value: Kotlin.PrimitiveHashMap(0)});
                Object.defineProperty(this, 'resolvers', {value: Kotlin.ArrayList(0)});
                Object.defineProperty(this, 'stats', {value: Kotlin.PrimitiveHashMap(0)});
                Object.defineProperty(this, 'oppositesAlreadySet', {value: Kotlin.PrimitiveHashMap(0)});
              }, /** @lends _.org.kevoree.modeling.api.xmi.LoadingContext.prototype */ {
                isOppositeAlreadySet: {value: function (localRef, oppositeRef) {
                  var res = this.oppositesAlreadySet.get(oppositeRef + '_' + localRef) != null || this.oppositesAlreadySet.get(localRef + '_' + oppositeRef) != null;
                  return res;
                }},
                storeOppositeRelation: {value: function (localRef, oppositeRef) {
                  this.oppositesAlreadySet.put(localRef + '_' + oppositeRef, true);
                }}
              })},
              XMIResolveCommand: {value: Kotlin.createClass(null, function (context, target, mutatorType, refName, ref) {
                Object.defineProperty(this, 'context', {value: context});
                Object.defineProperty(this, 'target', {value: target});
                Object.defineProperty(this, 'mutatorType', {value: mutatorType});
                Object.defineProperty(this, 'refName', {value: refName});
                Object.defineProperty(this, 'ref', {value: ref});
              }, /** @lends _.org.kevoree.modeling.api.xmi.XMIResolveCommand.prototype */ {
                run: {value: function () {
                  var referencedElement = this.context.map.get(this.ref);
                  if (referencedElement != null) {
                    this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                    return;
                  }
                  if (Kotlin.equals(this.ref, '/0/') || Kotlin.equals(this.ref, '/')) {
                    referencedElement = this.context.map.get('/0');
                    if (referencedElement != null) {
                      this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                      return;
                    }
                  }
                  throw new Error('KMF Load error : reference ' + this.ref + ' not found in map when trying to  ' + this.mutatorType + ' ' + this.refName + '  on ' + Kotlin.toString(this.target));
                }}
              })},
              ReferencesVisitor: {value: Kotlin.createClass(classes.cj, function $fun(ostream, addressTable, elementsCount) {
                Object.defineProperty(this, 'ostream', {value: ostream});
                Object.defineProperty(this, 'addressTable', {value: addressTable});
                Object.defineProperty(this, 'elementsCount', {value: elementsCount});
                $fun.baseInitializer.call(this);
                Object.defineProperty(this, 'value', {value: null, writable: true});
              }, /** @lends _.org.kevoree.modeling.api.xmi.ReferencesVisitor.prototype */ {
                beginVisitElem: {value: function (elem) {
                }, writable: true},
                endVisitElem: {value: function (elem) {
                }, writable: true},
                beginVisitRef: {value: function (refName, refType) {
                }, writable: true},
                endVisitRef: {value: function (refName) {
                  if (this.value != null) {
                    this.ostream.print(' ' + refName + '="' + Kotlin.toString(this.value) + '"');
                    this.value = null;
                  }
                }, writable: true},
                visit: {value: function (elem, refNameInParent, parent) {
                  var adjustedAddress = this.addressTable.get(elem);
                  if (this.value == null) {
                    this.value = adjustedAddress;
                  }
                   else {
                    this.value = _.jet.plus(this.value, ' ' + adjustedAddress);
                  }
                }, writable: true}
              })},
              AttributesVisitor: {value: Kotlin.createClass(classes.ck, function (ostream) {
                Object.defineProperty(this, 'ostream', {value: ostream});
              }, /** @lends _.org.kevoree.modeling.api.xmi.AttributesVisitor.prototype */ {
                visit: {value: function (value, name, parent) {
                  if (value != null) {
                    this.ostream.print(' ' + name + '="');
                    this.escapeXml(this.ostream, Kotlin.toString(value));
                    this.ostream.print('"');
                  }
                }, writable: true},
                escapeXml: {value: function (ostream, chain) {
                  if (chain == null) {
                    return;
                  }
                  var i = 0;
                  var max = chain.length;
                  while (i < max) {
                    var c = chain.charAt(i);
                    if (c === '"') {
                      ostream.print('&quot;');
                    }
                     else if (c === '&') {
                      ostream.print('&amp;');
                    }
                     else if (c === "'") {
                      ostream.print('&apos;');
                    }
                     else if (c === '<') {
                      ostream.print('&lt;');
                    }
                     else if (c === '>') {
                      ostream.print('&gt;');
                    }
                     else {
                      ostream.print_0(c);
                    }
                    i = i + 1;
                  }
                }}
              })},
              ModelSerializationVisitor: {value: Kotlin.createClass(classes.cj, function $fun(ostream, addressTable, elementsCount) {
                Object.defineProperty(this, 'ostream', {value: ostream});
                Object.defineProperty(this, 'addressTable', {value: addressTable});
                Object.defineProperty(this, 'elementsCount', {value: elementsCount});
                $fun.baseInitializer.call(this);
                Object.defineProperty(this, 'attributeVisitor', {value: _.org.kevoree.modeling.api.xmi.AttributesVisitor(this.ostream)});
                Object.defineProperty(this, 'referenceVisitor', {value: _.org.kevoree.modeling.api.xmi.ReferencesVisitor(this.ostream, this.addressTable, this.elementsCount)});
              }, /** @lends _.org.kevoree.modeling.api.xmi.ModelSerializationVisitor.prototype */ {
                beginVisitElem: {value: function (elem) {
                }, writable: true},
                endVisitElem: {value: function (elem) {
                }, writable: true},
                beginVisitRef: {value: function (refName, refType) {
                }, writable: true},
                endVisitRef: {value: function (refName) {
                }, writable: true},
                visit: {value: function (elem, refNameInParent, parent) {
                  this.ostream.print_0('<');
                  this.ostream.print(refNameInParent);
                  this.ostream.print(' xsi:type="' + this.formatMetaClassName(elem.metaClassName()) + '"');
                  elem.visitAttributes(this.attributeVisitor);
                  elem.visit(this.referenceVisitor, false, false, true);
                  this.ostream.println_0('>');
                  elem.visit(this, false, true, false);
                  this.ostream.print('<\/');
                  this.ostream.print(refNameInParent);
                  this.ostream.print_0('>');
                  this.ostream.println_1();
                }, writable: true},
                formatMetaClassName: {value: function (metaClassName) {
                  var lastPoint = _.js.lastIndexOf_0(metaClassName, '.');
                  var pack = metaClassName.substring(0, lastPoint);
                  var cls = metaClassName.substring(lastPoint + 1);
                  return pack + ':' + cls;
                }}
              })},
              ModelAddressVisitor: {value: Kotlin.createClass(classes.cj, function $fun(addressTable, elementsCount, packageList) {
                Object.defineProperty(this, 'addressTable', {value: addressTable});
                Object.defineProperty(this, 'elementsCount', {value: elementsCount});
                Object.defineProperty(this, 'packageList', {value: packageList});
                $fun.baseInitializer.call(this);
              }, /** @lends _.org.kevoree.modeling.api.xmi.ModelAddressVisitor.prototype */ {
                beginVisitElem: {value: function (elem) {
                }, writable: true},
                endVisitElem: {value: function (elem) {
                }, writable: true},
                beginVisitRef: {value: function (refName, refType) {
                }, writable: true},
                endVisitRef: {value: function (refName) {
                }, writable: true},
                visit: {value: function (elem, refNameInParent, parent) {
                  var tmp$0;
                  var parentXmiAddress = (tmp$0 = this.addressTable.get(parent)) != null ? tmp$0 : Kotlin.throwNPE();
                  var i = this.elementsCount.get(parentXmiAddress + '/@' + refNameInParent) !== null ? this.elementsCount.get(parentXmiAddress + '/@' + refNameInParent) : 0;
                  this.addressTable.put(elem, parentXmiAddress + '/@' + refNameInParent + '.' + i);
                  this.elementsCount.put(parentXmiAddress + '/@' + refNameInParent, i + 1);
                  var pack = elem.metaClassName().substring(0, _.js.lastIndexOf_0(elem.metaClassName(), '.'));
                  if (!this.packageList.contains(pack))
                    this.packageList.add(pack);
                }, writable: true}
              })},
              XMIModelSerializer: {value: classes.c7},
              XmlParser: {value: Kotlin.createClass(null, function (inputStream) {
                Object.defineProperty(this, 'inputStream', {value: inputStream});
                Object.defineProperty(this, 'bytes', {value: this.inputStream.readBytes()});
                Object.defineProperty(this, 'index', {value: -1, writable: true});
                Object.defineProperty(this, 'currentChar', {value: null, writable: true});
                Object.defineProperty(this, 'xmlVersion', {value: null, writable: true});
                Object.defineProperty(this, 'xmlCharset', {value: null, writable: true});
                Object.defineProperty(this, 'tagName', {value: '', writable: true});
                Object.defineProperty(this, 'tagPrefix', {value: null, writable: true});
                Object.defineProperty(this, 'attributesNames', {value: Kotlin.ArrayList(0), writable: true});
                Object.defineProperty(this, 'attributesPrefixes', {value: Kotlin.ArrayList(0), writable: true});
                Object.defineProperty(this, 'attributesValues', {value: Kotlin.ArrayList(0), writable: true});
                Object.defineProperty(this, 'attributeName', {value: _.java.lang.StringBuilder(), writable: true});
                Object.defineProperty(this, 'attributePrefix', {value: null, writable: true});
                Object.defineProperty(this, 'attributeValue', {value: _.java.lang.StringBuilder(), writable: true});
                Object.defineProperty(this, 'readSingleton', {value: false, writable: true});
              }, /** @lends _.org.kevoree.modeling.api.xmi.XmlParser.prototype */ {
                hasNext: {value: function () {
                  return this.bytes.length - this.index > 2;
                }},
                getLocalName: {value: function () {
                  return this.tagName;
                }},
                getAttributeCount: {value: function () {
                  return this.attributesNames.size();
                }},
                getAttributeLocalName: {value: function (i) {
                  return this.attributesNames.get(i);
                }},
                getAttributePrefix: {value: function (i) {
                  return this.attributesPrefixes.get(i);
                }},
                getAttributeValue: {value: function (i) {
                  return this.attributesValues.get(i);
                }},
                readChar: {value: function () {
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[this.index = this.index + 1, this.index]);
                }},
                next: {value: function () {
                  if (this.readSingleton) {
                    this.readSingleton = false;
                    return _.org.kevoree.modeling.api.xmi.Token.END_TAG;
                  }
                  if (!this.hasNext()) {
                    return _.org.kevoree.modeling.api.xmi.Token.END_DOCUMENT;
                  }
                  this.attributesNames.clear();
                  this.attributesPrefixes.clear();
                  this.attributesValues.clear();
                  this.read_lessThan();
                  this.currentChar = this.readChar();
                  if (this.currentChar === '?') {
                    this.currentChar = this.readChar();
                    this.read_xmlHeader();
                    return _.org.kevoree.modeling.api.xmi.Token.XML_HEADER;
                  }
                   else if (this.currentChar === '!') {
                    do {
                      this.currentChar = this.readChar();
                    }
                     while (this.currentChar !== '>');
                    return _.org.kevoree.modeling.api.xmi.Token.COMMENT;
                  }
                   else if (this.currentChar === '/') {
                    this.currentChar = this.readChar();
                    this.read_closingTag();
                    return _.org.kevoree.modeling.api.xmi.Token.END_TAG;
                  }
                   else {
                    this.read_openTag();
                    if (this.currentChar === '/') {
                      this.read_upperThan();
                      this.readSingleton = true;
                    }
                    return _.org.kevoree.modeling.api.xmi.Token.START_TAG;
                  }
                }},
                read_lessThan: {value: function () {
                  do {
                    this.currentChar = this.readChar();
                  }
                   while (this.currentChar !== '<');
                }},
                read_upperThan: {value: function () {
                  while (this.currentChar !== '>') {
                    this.currentChar = this.readChar();
                  }
                }},
                read_xmlHeader: {value: function () {
                  this.read_tagName();
                  this.read_attributes();
                  this.read_upperThan();
                }},
                read_closingTag: {value: function () {
                  this.read_tagName();
                  this.read_upperThan();
                }},
                read_openTag: {value: function () {
                  this.read_tagName();
                  if (this.currentChar !== '>') {
                    this.read_attributes();
                  }
                }},
                read_tagName: {value: function () {
                  this.tagName = '' + this.currentChar;
                  this.tagPrefix = null;
                  this.currentChar = this.readChar();
                  while (this.currentChar !== ' ' && this.currentChar !== '>') {
                    if (this.currentChar === ':') {
                      this.tagPrefix = this.tagName;
                      this.tagName = '';
                    }
                     else {
                      this.tagName = this.tagName + this.currentChar;
                    }
                    this.currentChar = this.readChar();
                  }
                }},
                read_attributes: {value: function () {
                  var end_of_tag = false;
                  while (this.currentChar === ' ') {
                    this.currentChar = this.readChar();
                  }
                  while (!end_of_tag) {
                    while (this.currentChar !== '=') {
                      if (this.currentChar === ':') {
                        this.attributePrefix = this.attributeName.toString();
                        this.attributeName.delete(0, this.attributeName.length());
                      }
                       else {
                        var tmp$0;
                        this.attributeName.append_0((tmp$0 = this.currentChar) != null ? tmp$0 : Kotlin.throwNPE());
                      }
                      this.currentChar = this.readChar();
                    }
                    do {
                      this.currentChar = this.readChar();
                    }
                     while (this.currentChar !== '"');
                    this.currentChar = this.readChar();
                    while (this.currentChar !== '"') {
                      var tmp$1;
                      this.attributeValue.append_0((tmp$1 = this.currentChar) != null ? tmp$1 : Kotlin.throwNPE());
                      this.currentChar = this.readChar();
                    }
                    this.attributesNames.add(this.attributeName.toString());
                    this.attributesPrefixes.add(this.attributePrefix);
                    this.attributesValues.add(this.attributeValue.toString());
                    this.attributeName.delete(0, this.attributeName.length());
                    this.attributePrefix = null;
                    this.attributeValue.delete(0, this.attributeValue.length());
                    do {
                      this.currentChar = this.readChar();
                      if (this.currentChar === '?' || this.currentChar === '/' || this.currentChar === '-' || this.currentChar === '>') {
                        end_of_tag = true;
                      }
                    }
                     while (!end_of_tag && this.currentChar === ' ');
                  }
                }}
              })}
            }),
            compare: Kotlin.definePackage(null, {
              ModelCompare: {value: classes.c9}
            }),
            json: Kotlin.definePackage(function () {
              Object.defineProperty(this, 'Type', {value: Kotlin.createObject(null, function () {
                Object.defineProperty(this, 'VALUE', {value: 0});
                Object.defineProperty(this, 'LEFT_BRACE', {value: 1});
                Object.defineProperty(this, 'RIGHT_BRACE', {value: 2});
                Object.defineProperty(this, 'LEFT_BRACKET', {value: 3});
                Object.defineProperty(this, 'RIGHT_BRACKET', {value: 4});
                Object.defineProperty(this, 'COMMA', {value: 5});
                Object.defineProperty(this, 'COLON', {value: 6});
                Object.defineProperty(this, 'EOF', {value: 42});
              })});
            }, {
              Token: {value: Kotlin.createClass(null, function (tokenType, value) {
                Object.defineProperty(this, 'tokenType', {value: tokenType});
                Object.defineProperty(this, 'value', {value: value});
              }, /** @lends _.org.kevoree.modeling.api.json.Token.prototype */ {
                toString: {value: function () {
                  var tmp$0;
                  if (this.value != null) {
                    tmp$0 = ' (' + this.value + ')';
                  }
                   else {
                    tmp$0 = '';
                  }
                  var v = tmp$0;
                  var result = Kotlin.toString(this.tokenType) + v;
                  return result;
                }}
              })},
              Lexer: {value: Kotlin.createClass(null, function (inputStream) {
                Object.defineProperty(this, 'inputStream', {value: inputStream});
                Object.defineProperty(this, 'bytes', {value: this.inputStream.readBytes()});
                Object.defineProperty(this, 'EOF', {value: _.org.kevoree.modeling.api.json.Token(_.org.kevoree.modeling.api.json.Type.EOF, null)});
                Object.defineProperty(this, 'index', {value: 0, writable: true});
                Object.defineProperty(this, 'BOOLEAN_LETTERS', {value: null, writable: true});
                Object.defineProperty(this, 'DIGIT', {value: null, writable: true});
              }, /** @lends _.org.kevoree.modeling.api.json.Lexer.prototype */ {
                isSpace: {value: function (c) {
                  return c === ' ' || c === '\r' || c === '\n' || c === '\t';
                }},
                nextChar: {value: function () {
                  var tmp$0, tmp$1;
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[tmp$0 = this.index, tmp$1 = tmp$0, this.index = tmp$0 + 1, tmp$1]);
                }},
                peekChar: {value: function () {
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[this.index]);
                }},
                isDone: {value: function () {
                  return this.index >= this.bytes.length;
                }},
                isBooleanLetter: {value: function (c) {
                  if (this.BOOLEAN_LETTERS == null) {
                    this.BOOLEAN_LETTERS = Kotlin.PrimitiveHashSet();
                    var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7;
                    ((tmp$0 = this.BOOLEAN_LETTERS) != null ? tmp$0 : Kotlin.throwNPE()).add('f');
                    ((tmp$1 = this.BOOLEAN_LETTERS) != null ? tmp$1 : Kotlin.throwNPE()).add('a');
                    ((tmp$2 = this.BOOLEAN_LETTERS) != null ? tmp$2 : Kotlin.throwNPE()).add('l');
                    ((tmp$3 = this.BOOLEAN_LETTERS) != null ? tmp$3 : Kotlin.throwNPE()).add('s');
                    ((tmp$4 = this.BOOLEAN_LETTERS) != null ? tmp$4 : Kotlin.throwNPE()).add('e');
                    ((tmp$5 = this.BOOLEAN_LETTERS) != null ? tmp$5 : Kotlin.throwNPE()).add('t');
                    ((tmp$6 = this.BOOLEAN_LETTERS) != null ? tmp$6 : Kotlin.throwNPE()).add('r');
                    ((tmp$7 = this.BOOLEAN_LETTERS) != null ? tmp$7 : Kotlin.throwNPE()).add('u');
                  }
                  var tmp$8;
                  return ((tmp$8 = this.BOOLEAN_LETTERS) != null ? tmp$8 : Kotlin.throwNPE()).contains(c);
                }},
                isDigit: {value: function (c) {
                  if (this.DIGIT == null) {
                    this.DIGIT = Kotlin.PrimitiveHashSet();
                    var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7, tmp$8, tmp$9;
                    ((tmp$0 = this.DIGIT) != null ? tmp$0 : Kotlin.throwNPE()).add('0');
                    ((tmp$1 = this.DIGIT) != null ? tmp$1 : Kotlin.throwNPE()).add('1');
                    ((tmp$2 = this.DIGIT) != null ? tmp$2 : Kotlin.throwNPE()).add('2');
                    ((tmp$3 = this.DIGIT) != null ? tmp$3 : Kotlin.throwNPE()).add('3');
                    ((tmp$4 = this.DIGIT) != null ? tmp$4 : Kotlin.throwNPE()).add('4');
                    ((tmp$5 = this.DIGIT) != null ? tmp$5 : Kotlin.throwNPE()).add('5');
                    ((tmp$6 = this.DIGIT) != null ? tmp$6 : Kotlin.throwNPE()).add('6');
                    ((tmp$7 = this.DIGIT) != null ? tmp$7 : Kotlin.throwNPE()).add('7');
                    ((tmp$8 = this.DIGIT) != null ? tmp$8 : Kotlin.throwNPE()).add('8');
                    ((tmp$9 = this.DIGIT) != null ? tmp$9 : Kotlin.throwNPE()).add('9');
                  }
                  var tmp$10;
                  return ((tmp$10 = this.DIGIT) != null ? tmp$10 : Kotlin.throwNPE()).contains(c);
                }},
                isValueLetter: {value: function (c) {
                  return c === '-' || c === '+' || c === '.' || this.isDigit(c) || this.isBooleanLetter(c);
                }},
                nextToken: {value: function () {
                  if (this.isDone()) {
                    return this.EOF;
                  }
                  var tokenType = _.org.kevoree.modeling.api.json.Type.EOF;
                  var c = this.nextChar();
                  var currentValue = _.java.lang.StringBuilder();
                  var jsonValue = null;
                  while (!this.isDone() && this.isSpace(c)) {
                    c = this.nextChar();
                  }
                  if ('"' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.VALUE;
                    if (!this.isDone()) {
                      c = this.nextChar();
                      while (this.index < this.bytes.length && c !== '"') {
                        currentValue.append_0(c);
                        if (c === '\\' && this.index < this.bytes.length) {
                          c = this.nextChar();
                          currentValue.append_0(c);
                        }
                        c = this.nextChar();
                      }
                      jsonValue = currentValue.toString();
                    }
                     else {
                      throw Kotlin.RuntimeException('Unterminated string');
                    }
                  }
                   else if ('{' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.LEFT_BRACE;
                  }
                   else if ('}' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE;
                  }
                   else if ('[' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET;
                  }
                   else if (']' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET;
                  }
                   else if (':' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.COLON;
                  }
                   else if (',' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.COMMA;
                  }
                   else if (!this.isDone()) {
                    while (this.isValueLetter(c)) {
                      currentValue.append_0(c);
                      if (!this.isValueLetter(this.peekChar())) {
                        break;
                      }
                       else {
                        c = this.nextChar();
                      }
                    }
                    var v = currentValue.toString();
                    if (Kotlin.equals('true', v.toLowerCase())) {
                      jsonValue = true;
                    }
                     else if (Kotlin.equals('false', v.toLowerCase())) {
                      jsonValue = false;
                    }
                     else {
                      jsonValue = v.toLowerCase();
                    }
                    tokenType = _.org.kevoree.modeling.api.json.Type.VALUE;
                  }
                   else {
                    tokenType = _.org.kevoree.modeling.api.json.Type.EOF;
                  }
                  return _.org.kevoree.modeling.api.json.Token(tokenType, jsonValue);
                }}
              })},
              JSONModelLoader: {value: classes.cb},
              ResolveCommand: {value: Kotlin.createClass(null, function (roots, ref, currentRootElem, refName) {
                Object.defineProperty(this, 'roots', {value: roots});
                Object.defineProperty(this, 'ref', {value: ref});
                Object.defineProperty(this, 'currentRootElem', {value: currentRootElem});
                Object.defineProperty(this, 'refName', {value: refName});
              }, /** @lends _.org.kevoree.modeling.api.json.ResolveCommand.prototype */ {
                run: {value: function () {
                  var referencedElement = null;
                  var i = 0;
                  while (referencedElement == null && i < this.roots.size()) {
                    referencedElement = this.roots.get(i++).findByPath(this.ref);
                  }
                  if (referencedElement != null) {
                    this.currentRootElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, this.refName, referencedElement, false, false);
                  }
                   else {
                    throw new Error('Unresolved ' + this.ref);
                  }
                }}
              })},
              ModelReferenceVisitor: {value: Kotlin.createClass(classes.cj, function $fun(out) {
                Object.defineProperty(this, 'out', {value: out});
                $fun.baseInitializer.call(this);
                Object.defineProperty(this, 'isFirst', {value: true, writable: true});
              }, /** @lends _.org.kevoree.modeling.api.json.ModelReferenceVisitor.prototype */ {
                beginVisitRef: {value: function (refName, refType) {
                  this.out.print(',"' + refName + '":[');
                  this.isFirst = true;
                }, writable: true},
                endVisitRef: {value: function (refName) {
                  this.out.print(']');
                }, writable: true},
                visit: {value: function (elem, refNameInParent, parent) {
                  if (!this.isFirst) {
                    this.out.print(',');
                  }
                   else {
                    this.isFirst = false;
                  }
                  this.out.print('"' + elem.path() + '"');
                }, writable: true}
              })},
              JSONModelSerializer: {value: classes.cc}
            }),
            events: Kotlin.definePackage(null, {
              ModelElementListener: {value: classes.cd},
              ModelEvent: {value: Kotlin.createClass(null, function (internal_sourcePath, internal_etype, internal_elementAttributeType, internal_elementAttributeName, internal_value) {
                Object.defineProperty(this, 'internal_sourcePath', {value: internal_sourcePath});
                Object.defineProperty(this, 'internal_etype', {value: internal_etype});
                Object.defineProperty(this, 'internal_elementAttributeType', {value: internal_elementAttributeType});
                Object.defineProperty(this, 'internal_elementAttributeName', {value: internal_elementAttributeName});
                Object.defineProperty(this, 'internal_value', {value: internal_value});
              }, /** @lends _.org.kevoree.modeling.api.events.ModelEvent.prototype */ {
                getSourcePath: {value: function () {
                  return this.internal_sourcePath;
                }},
                getType: {value: function () {
                  return this.internal_etype;
                }},
                getElementAttributeType: {value: function () {
                  return this.internal_elementAttributeType;
                }},
                getElementAttributeName: {value: function () {
                  return this.internal_elementAttributeName;
                }},
                getValue: {value: function () {
                  return this.internal_value;
                }},
                toString: {value: function () {
                  return 'ModelEvent[src:' + this.getSourcePath() + ', type:' + this.getType() + ', elementAttributeType:' + this.getElementAttributeType() + ', elementAttributeName:' + this.getElementAttributeName() + ', value:' + this.getValue() + ']';
                }}
              })},
              ModelTreeListener: {value: classes.ce}
            }),
            trace: Kotlin.definePackage(null, {
              TraceConverter: {value: classes.cf},
              ModelTrace: {value: classes.cg},
              ModelAddTrace: {value: Kotlin.createClass(classes.cg, function (srcPath, refName, previousPath, typeName) {
                Object.defineProperty(this, 'srcPath', {value: srcPath});
                Object.defineProperty(this, 'refName', {value: refName});
                Object.defineProperty(this, 'previousPath', {value: previousPath});
                Object.defineProperty(this, 'typeName', {value: typeName});
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelAddTrace.prototype */ {
                toString: {value: function () {
                  var buffer = _.java.lang.StringBuilder();
                  buffer.append('{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.ADD + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '"');
                  if (this.previousPath != null) {
                    buffer.append(', "previouspath" : "' + this.previousPath + '"');
                  }
                  if (this.typeName != null) {
                    buffer.append(', "typename" : "' + this.typeName + '"');
                  }
                  buffer.append('}');
                  return buffer.toString();
                }, writable: true}
              })},
              ModelAddAllTrace: {value: Kotlin.createClass(classes.cg, function (srcPath, refName, previousPath, typeName) {
                Object.defineProperty(this, 'srcPath', {value: srcPath});
                Object.defineProperty(this, 'refName', {value: refName});
                Object.defineProperty(this, 'previousPath', {value: previousPath});
                Object.defineProperty(this, 'typeName', {value: typeName});
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelAddAllTrace.prototype */ {
                mkString: {value: function (ss) {
                  if (ss == null) {
                    return null;
                  }
                  var buffer = _.java.lang.StringBuilder();
                  var isFirst = true;
                  {
                    var tmp$0 = ss.iterator();
                    while (tmp$0.hasNext()) {
                      var s = tmp$0.next();
                      if (!isFirst) {
                        buffer.append(',');
                      }
                      buffer.append(s);
                      isFirst = false;
                    }
                  }
                  return buffer.toString();
                }},
                toString: {value: function () {
                  var buffer = _.java.lang.StringBuilder();
                  buffer.append('{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.ADD_ALL + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '"');
                  if (this.previousPath != null) {
                    buffer.append(', "previouspath" : "' + this.mkString(this.previousPath) + '"');
                  }
                  if (this.typeName != null) {
                    buffer.append(', "typename" : "' + this.mkString(this.typeName) + '"');
                  }
                  buffer.append('}');
                  return buffer.toString();
                }, writable: true}
              })},
              ModelRemoveTrace: {value: Kotlin.createClass(classes.cg, function (srcPath, refName, objPath) {
                Object.defineProperty(this, 'srcPath', {value: srcPath});
                Object.defineProperty(this, 'refName', {value: refName});
                Object.defineProperty(this, 'objPath', {value: objPath});
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelRemoveTrace.prototype */ {
                toString: {value: function () {
                  return '{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.REMOVE + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '", "objpath" : "' + this.objPath + '" }';
                }, writable: true}
              })},
              ModelRemoveAllTrace: {value: Kotlin.createClass(classes.cg, function (srcPath, refName) {
                Object.defineProperty(this, 'srcPath', {value: srcPath});
                Object.defineProperty(this, 'refName', {value: refName});
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace.prototype */ {
                toString: {value: function () {
                  return '{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '" }';
                }, writable: true}
              })},
              ModelSetTrace: {value: Kotlin.createClass(classes.cg, function (srcPath, refName, objPath, content, typeName) {
                Object.defineProperty(this, 'srcPath', {value: srcPath});
                Object.defineProperty(this, 'refName', {value: refName});
                Object.defineProperty(this, 'objPath', {value: objPath});
                Object.defineProperty(this, 'content', {value: content});
                Object.defineProperty(this, 'typeName', {value: typeName});
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelSetTrace.prototype */ {
                toString: {value: function () {
                  var buffer = _.java.lang.StringBuilder();
                  buffer.append('{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.SET + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '"');
                  if (this.objPath != null) {
                    buffer.append(', "objpath" : "' + this.objPath + '"');
                  }
                  if (this.content != null) {
                    buffer.append(', "content" : "' + this.content + '"');
                  }
                  if (this.typeName != null) {
                    buffer.append(', "typename" : "' + this.typeName + '"');
                  }
                  buffer.append('}');
                  return buffer.toString();
                }, writable: true}
              })},
              DefaultTraceConverter: {value: Kotlin.createClass(classes.cf, function () {
                Object.defineProperty(this, 'metaClassNameEquivalence_1', {value: Kotlin.PrimitiveHashMap(0), writable: true});
                Object.defineProperty(this, 'metaClassNameEquivalence_2', {value: Kotlin.PrimitiveHashMap(0), writable: true});
                Object.defineProperty(this, 'attNameEquivalence_1', {value: Kotlin.PrimitiveHashMap(0), writable: true});
                Object.defineProperty(this, 'attNameEquivalence_2', {value: Kotlin.PrimitiveHashMap(0), writable: true});
              }, /** @lends _.org.kevoree.modeling.api.trace.DefaultTraceConverter.prototype */ {
                addMetaClassEquivalence: {value: function (name1, name2) {
                  this.metaClassNameEquivalence_1.put(name1, name2);
                  this.metaClassNameEquivalence_2.put(name2, name2);
                }},
                addAttEquivalence: {value: function (name1, name2) {
                  var fqnArray_1 = Kotlin.splitString(name1, '#');
                  var fqnArray_2 = Kotlin.splitString(name1, '#');
                  this.attNameEquivalence_1.put(name1, name2);
                  this.attNameEquivalence_2.put(name2, name2);
                }},
                convert: {value: function (trace) {
                  if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddTrace)) {
                    var addTrace = trace != null ? trace : Kotlin.throwNPE();
                    var newTrace = _.org.kevoree.modeling.api.trace.ModelAddTrace(addTrace.srcPath, addTrace.refName, addTrace.previousPath, this.tryConvertClassName(addTrace.typeName));
                    return newTrace;
                  }
                   else if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelSetTrace)) {
                    var setTrace = trace != null ? trace : Kotlin.throwNPE();
                    var newTrace_0 = _.org.kevoree.modeling.api.trace.ModelSetTrace(setTrace.srcPath, setTrace.refName, setTrace.objPath, setTrace.content, this.tryConvertClassName(setTrace.typeName));
                    return newTrace_0;
                  }
                   else {
                    return trace;
                  }
                }, writable: true},
                tryConvertPath: {value: function (previousPath) {
                  if (previousPath == null) {
                    return null;
                  }
                  return previousPath;
                }},
                tryConvertClassName: {value: function (previousClassName) {
                  if (previousClassName == null) {
                    return null;
                  }
                  if (this.metaClassNameEquivalence_1.containsKey(previousClassName)) {
                    var tmp$0;
                    return (tmp$0 = this.metaClassNameEquivalence_1.get(previousClassName)) != null ? tmp$0 : Kotlin.throwNPE();
                  }
                  if (this.metaClassNameEquivalence_2.containsKey(previousClassName)) {
                    var tmp$1;
                    return (tmp$1 = this.metaClassNameEquivalence_2.get(previousClassName)) != null ? tmp$1 : Kotlin.throwNPE();
                  }
                  return previousClassName;
                }},
                tryConvertAttName: {value: function (previousAttName) {
                  if (previousAttName == null) {
                    return null;
                  }
                  var FQNattName = previousAttName;
                  if (this.attNameEquivalence_1.containsKey(FQNattName)) {
                    var tmp$0;
                    return (tmp$0 = this.attNameEquivalence_1.get(FQNattName)) != null ? tmp$0 : Kotlin.throwNPE();
                  }
                  if (this.attNameEquivalence_2.containsKey(FQNattName)) {
                    var tmp$1;
                    return (tmp$1 = this.attNameEquivalence_2.get(FQNattName)) != null ? tmp$1 : Kotlin.throwNPE();
                  }
                  return previousAttName;
                }}
              })},
              ModelTraceApplicator: {value: Kotlin.createClass(null, function (targetModel, factory) {
                Object.defineProperty(this, 'targetModel', {value: targetModel});
                Object.defineProperty(this, 'factory', {value: factory});
                Object.defineProperty(this, 'pendingObj', {value: null, writable: true});
                Object.defineProperty(this, 'pendingParent', {value: null, writable: true});
                Object.defineProperty(this, 'pendingParentRefName', {value: null, writable: true});
                Object.defineProperty(this, 'pendingObjPath', {value: null, writable: true});
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelTraceApplicator.prototype */ {
                tryClosePending: {value: function (srcPath) {
                  if (this.pendingObj != null && !Kotlin.equals(this.pendingObjPath, srcPath)) {
                    var tmp$0, tmp$1;
                    ((tmp$0 = this.pendingParent) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, (tmp$1 = this.pendingParentRefName) != null ? tmp$1 : Kotlin.throwNPE(), this.pendingObj, true, true);
                    this.pendingObj = null;
                    this.pendingObjPath = null;
                    this.pendingParentRefName = null;
                    this.pendingParent = null;
                  }
                }},
                createOrAdd: {value: function (previousPath, target, refName, potentialTypeName) {
                  var tmp$0;
                  if (previousPath != null) {
                    tmp$0 = this.targetModel.findByPath(previousPath);
                  }
                   else {
                    tmp$0 = null;
                  }
                  var targetElem = tmp$0;
                  if (targetElem != null) {
                    target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, refName, targetElem, true, true);
                  }
                   else {
                    this.pendingObj = this.factory.create(potentialTypeName != null ? potentialTypeName : Kotlin.throwNPE());
                    this.pendingObjPath = previousPath;
                    this.pendingParentRefName = refName;
                    this.pendingParent = target;
                  }
                }},
                applyTraceOnModel: {value: function (traceSeq) {
                  {
                    var tmp$0 = traceSeq.traces.iterator();
                    while (tmp$0.hasNext()) {
                      var trace = tmp$0.next();
                      var target = this.targetModel;
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddTrace)) {
                        var castedTrace = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(null);
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          var tmp$1;
                          target = (tmp$1 = this.targetModel.findByPath(castedTrace.srcPath)) != null ? tmp$1 : Kotlin.throwNPE();
                        }
                        this.createOrAdd(castedTrace.previousPath, target, castedTrace.refName, castedTrace.typeName);
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddAllTrace)) {
                        var castedTrace_0 = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(null);
                        var i = 0;
                        var tmp$2;
                        {
                          var tmp$3 = ((tmp$2 = castedTrace_0.previousPath) != null ? tmp$2 : Kotlin.throwNPE()).iterator();
                          while (tmp$3.hasNext()) {
                            var path = tmp$3.next();
                            var tmp$4;
                            this.createOrAdd(path, target, castedTrace_0.refName, ((tmp$4 = castedTrace_0.typeName) != null ? tmp$4 : Kotlin.throwNPE()).get(i));
                            i++;
                          }
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelRemoveTrace)) {
                        var castedTrace_1 = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(trace.srcPath);
                        var tempTarget = this.targetModel;
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          tempTarget = this.targetModel.findByPath(castedTrace_1.srcPath);
                        }
                        if (tempTarget != null) {
                          (tempTarget != null ? tempTarget : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE, castedTrace_1.refName, this.targetModel.findByPath(castedTrace_1.objPath), true, true);
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace)) {
                        var castedTrace_2 = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(trace.srcPath);
                        var tempTarget_0 = this.targetModel;
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          tempTarget_0 = this.targetModel.findByPath(castedTrace_2.srcPath);
                        }
                        if (tempTarget_0 != null) {
                          (tempTarget_0 != null ? tempTarget_0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, castedTrace_2.refName, null, true, true);
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelSetTrace)) {
                        var castedTrace_3 = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(trace.srcPath);
                        if (!Kotlin.equals(trace.srcPath, '') && !Kotlin.equals(castedTrace_3.srcPath, this.pendingObjPath)) {
                          var tempObject = this.targetModel.findByPath(castedTrace_3.srcPath);
                          if (tempObject == null) {
                            throw new Error('Set Trace source not found for path : ' + castedTrace_3.srcPath + '/ pending ' + this.pendingObjPath + '\n' + trace.toString());
                          }
                          target = tempObject != null ? tempObject : Kotlin.throwNPE();
                        }
                         else {
                          if (Kotlin.equals(castedTrace_3.srcPath, this.pendingObjPath) && this.pendingObj != null) {
                            var tmp$5;
                            target = (tmp$5 = this.pendingObj) != null ? tmp$5 : Kotlin.throwNPE();
                          }
                        }
                        if (castedTrace_3.content != null) {
                          target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, castedTrace_3.refName, castedTrace_3.content, true, true);
                        }
                         else {
                          var tmp$7;
                          if (castedTrace_3.objPath != null) {
                            var tmp$6;
                            tmp$7 = this.targetModel.findByPath((tmp$6 = castedTrace_3.objPath) != null ? tmp$6 : Kotlin.throwNPE());
                          }
                           else {
                            tmp$7 = null;
                          }
                          var targetContentPath = tmp$7;
                          if (targetContentPath != null) {
                            target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, castedTrace_3.refName, targetContentPath, true, true);
                          }
                           else {
                            if (castedTrace_3.typeName != null && !Kotlin.equals(castedTrace_3.typeName, '')) {
                              this.createOrAdd(castedTrace_3.objPath, target, castedTrace_3.refName, castedTrace_3.typeName);
                            }
                             else {
                              target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, castedTrace_3.refName, targetContentPath, true, true);
                            }
                          }
                        }
                      }
                    }
                  }
                  this.tryClosePending(null);
                }}
              })},
              Event2Trace: {value: Kotlin.createClass(null, function (compare) {
                Object.defineProperty(this, 'compare', {value: compare});
              }, /** @lends _.org.kevoree.modeling.api.trace.Event2Trace.prototype */ {
                convert: {value: function (event) {
                  var result = Kotlin.ArrayList(0);
                  var tmp$0 = event.getType();
                  if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                    var tmp$1, tmp$2, tmp$3, tmp$4;
                    result.add(_.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$1 = event.getSourcePath()) != null ? tmp$1 : Kotlin.throwNPE(), (tmp$2 = event.getElementAttributeName()) != null ? tmp$2 : Kotlin.throwNPE(), (tmp$4 = ((tmp$3 = event.getValue()) != null ? tmp$3 : Kotlin.throwNPE()).path()) != null ? tmp$4 : Kotlin.throwNPE()));
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                    var tmp$5, tmp$6;
                    result.add(_.org.kevoree.modeling.api.trace.ModelRemoveAllTrace((tmp$5 = event.getSourcePath()) != null ? tmp$5 : Kotlin.throwNPE(), (tmp$6 = event.getElementAttributeName()) != null ? tmp$6 : Kotlin.throwNPE()));
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                    var tmp$7, tmp$8, tmp$9;
                    var casted = (tmp$7 = event.getValue()) != null ? tmp$7 : Kotlin.throwNPE();
                    var traces = this.compare.inter(casted, casted);
                    result.add(_.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$8 = event.getSourcePath()) != null ? tmp$8 : Kotlin.throwNPE(), (tmp$9 = event.getElementAttributeName()) != null ? tmp$9 : Kotlin.throwNPE(), casted.path(), casted.metaClassName()));
                    result.addAll(traces.traces);
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                    var tmp$10;
                    var casted_0 = (tmp$10 = event.getValue()) != null ? tmp$10 : Kotlin.throwNPE();
                    {
                      var tmp$11 = (casted_0 != null ? casted_0 : Kotlin.throwNPE()).iterator();
                      while (tmp$11.hasNext()) {
                        var elem = tmp$11.next();
                        var elemCasted = elem != null ? elem : Kotlin.throwNPE();
                        var traces_0 = this.compare.inter(elemCasted, elemCasted);
                        var tmp$12, tmp$13;
                        result.add(_.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$12 = event.getSourcePath()) != null ? tmp$12 : Kotlin.throwNPE(), (tmp$13 = event.getElementAttributeName()) != null ? tmp$13 : Kotlin.throwNPE(), elemCasted.path(), elemCasted.metaClassName()));
                        result.addAll(traces_0.traces);
                      }
                    }
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.SET) {
                    if (event.getElementAttributeType() === _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE) {
                      var tmp$14, tmp$15;
                      result.add(_.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$14 = event.getSourcePath()) != null ? tmp$14 : Kotlin.throwNPE(), (tmp$15 = event.getElementAttributeName()) != null ? tmp$15 : Kotlin.throwNPE(), null, Kotlin.toString(event.getValue()), null));
                    }
                     else {
                      var tmp$16, tmp$17, tmp$18;
                      result.add(_.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$16 = event.getSourcePath()) != null ? tmp$16 : Kotlin.throwNPE(), (tmp$17 = event.getElementAttributeName()) != null ? tmp$17 : Kotlin.throwNPE(), ((tmp$18 = event.getValue()) != null ? tmp$18 : Kotlin.throwNPE()).path(), null, null));
                    }
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  }
                   else {
                    throw new Error("Can't convert event : " + event);
                  }
                  return this.compare.createSequence().populate(result);
                }}
              })},
              TraceSequence: {value: classes.ch}
            }),
            util: Kotlin.definePackage(function () {
              Object.defineProperty(this, 'ElementAttributeType', {value: Kotlin.createObject(null, function () {
                Object.defineProperty(this, 'ATTRIBUTE', {value: 0});
                Object.defineProperty(this, 'REFERENCE', {value: 1});
                Object.defineProperty(this, 'CONTAINMENT', {value: 2});
              })});
              Object.defineProperty(this, 'ActionType', {value: Kotlin.createObject(null, function () {
                Object.defineProperty(this, 'SET', {value: 0});
                Object.defineProperty(this, 'ADD', {value: 1});
                Object.defineProperty(this, 'REMOVE', {value: 2});
                Object.defineProperty(this, 'ADD_ALL', {value: 3});
                Object.defineProperty(this, 'REMOVE_ALL', {value: 4});
                Object.defineProperty(this, 'RENEW_INDEX', {value: 5});
              })});
              Object.defineProperty(this, 'ByteConverter', {value: Kotlin.createObject(null, null, {
                toChar: {value: function (b) {
                  return b != null ? b : Kotlin.throwNPE();
                }},
                fromChar: {value: function (b) {
                  return b != null ? b : Kotlin.throwNPE();
                }},
                byteArrayInputStreamFromString: {value: function (str) {
                  var bytes = Kotlin.numberArrayOfSize(str.length);
                  var i = 0;
                  while (i < str.length) {
                    var tmp$0;
                    bytes[i] = (tmp$0 = str.charAt(i)) != null ? tmp$0 : Kotlin.throwNPE();
                    i = i + 1;
                  }
                  return _.java.io.ByteArrayInputStream(bytes);
                }}
              })});
            }, {
              ModelVisitor: {value: classes.cj},
              ModelAttributeVisitor: {value: classes.ck}
            })
          })
        }),
        log: Kotlin.definePackage(function () {
          Object.defineProperty(this, 'Log', {value: Kotlin.createObject(null, function () {
            Object.defineProperty(this, 'LEVEL_NONE', {value: 6});
            Object.defineProperty(this, 'LEVEL_ERROR', {value: 5});
            Object.defineProperty(this, 'LEVEL_WARN', {value: 4});
            Object.defineProperty(this, 'LEVEL_INFO', {value: 3});
            Object.defineProperty(this, 'LEVEL_DEBUG', {value: 2});
            Object.defineProperty(this, 'LEVEL_TRACE', {value: 1});
            Object.defineProperty(this, 'level', {value: this.LEVEL_INFO, writable: true});
            Object.defineProperty(this, 'ERROR', {value: this.level <= this.LEVEL_ERROR, writable: true});
            Object.defineProperty(this, 'WARN', {value: this.level <= this.LEVEL_WARN, writable: true});
            Object.defineProperty(this, 'INFO', {value: this.level <= this.LEVEL_INFO, writable: true});
            Object.defineProperty(this, 'DEBUG', {value: this.level <= this.LEVEL_DEBUG, writable: true});
            Object.defineProperty(this, 'TRACE', {value: this.level <= this.LEVEL_TRACE, writable: true});
            Object.defineProperty(this, 'logger', {value: _.org.kevoree.log.Logger(), writable: true});
            Object.defineProperty(this, 'beginParam', {value: '{'});
            Object.defineProperty(this, 'endParam', {value: '}'});
          }, {
            set: {value: function (level) {
              _.org.kevoree.log.Log.level = level;
              this.ERROR = level <= this.LEVEL_ERROR;
              this.WARN = level <= this.LEVEL_WARN;
              this.INFO = level <= this.LEVEL_INFO;
              this.DEBUG = level <= this.LEVEL_DEBUG;
              this.TRACE = level <= this.LEVEL_TRACE;
            }},
            NONE: {value: function () {
              this.set(this.LEVEL_NONE);
            }},
            ERROR_0: {value: function () {
              this.set(this.LEVEL_ERROR);
            }},
            WARN_0: {value: function () {
              this.set(this.LEVEL_WARN);
            }},
            INFO_0: {value: function () {
              this.set(this.LEVEL_INFO);
            }},
            DEBUG_0: {value: function () {
              this.set(this.LEVEL_DEBUG);
            }},
            TRACE_0: {value: function () {
              this.set(this.LEVEL_TRACE);
            }},
            setLogger: {value: function (logger) {
              _.org.kevoree.log.Log.logger = logger;
            }},
            processMessage: {value: function (message, p1, p2, p3, p4, p5) {
              if (p1 == null) {
                return message;
              }
              var buffer = _.java.lang.StringBuilder();
              var previousCharfound = false;
              var param = 0;
              var i = 0;
              while (i < message.length) {
                var currentChar = message.charAt(i);
                if (previousCharfound) {
                  if (currentChar === this.endParam) {
                    param++;
                    if (param === 1) {
                      buffer = _.java.lang.StringBuilder();
                      buffer.append(message.substring(0, i - 1));
                      buffer.append(Kotlin.toString(p1 != null ? p1 : Kotlin.throwNPE()));
                    }
                     else if (param === 2) {
                      buffer.append(Kotlin.toString(p2 != null ? p2 : Kotlin.throwNPE()));
                    }
                     else if (param === 3) {
                      buffer.append(Kotlin.toString(p3 != null ? p3 : Kotlin.throwNPE()));
                    }
                     else if (param === 4) {
                      buffer.append(Kotlin.toString(p4 != null ? p4 : Kotlin.throwNPE()));
                    }
                     else if (param === 5) {
                      buffer.append(Kotlin.toString(p5 != null ? p5 : Kotlin.throwNPE()));
                    }
                     else {
                    }
                    previousCharfound = false;
                  }
                   else {
                    if (buffer != null) {
                      message.charAt(i - 1);
                      buffer.append_0(currentChar);
                    }
                    previousCharfound = false;
                  }
                }
                 else {
                  if (currentChar === this.beginParam) {
                    previousCharfound = true;
                  }
                   else {
                    if (buffer != null) {
                      buffer.append_0(currentChar);
                    }
                  }
                }
                i = i + 1;
              }
              if (buffer != null) {
                return buffer.toString();
              }
               else {
                return message;
              }
            }},
            error: {value: function (message, ex, p1, p2, p3, p4, p5) {
              if (this.ERROR) {
                this.internal_error(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            }},
            error_0: {value: function (message, p1, p2, p3, p4, p5) {
              if (this.ERROR) {
                this.internal_error(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            }},
            internal_error: {value: function (message, ex) {
              this.logger.log(this.LEVEL_ERROR, message, ex);
            }},
            warn: {value: function (message, ex, p1, p2, p3, p4, p5) {
              if (this.WARN) {
                this.internal_warn(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            }},
            warn_0: {value: function (message, p1, p2, p3, p4, p5) {
              if (this.WARN) {
                this.internal_warn(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            }},
            internal_warn: {value: function (message, ex) {
              this.logger.log(this.LEVEL_WARN, message, ex);
            }},
            info: {value: function (message, ex, p1, p2, p3, p4, p5) {
              if (this.INFO) {
                this.internal_info(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            }},
            info_0: {value: function (message, p1, p2, p3, p4, p5) {
              if (this.INFO) {
                this.internal_info(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            }},
            internal_info: {value: function (message, ex) {
              this.logger.log(this.LEVEL_INFO, message, ex);
            }},
            debug: {value: function (message, ex, p1, p2, p3, p4, p5) {
              if (this.DEBUG) {
                this.internal_debug(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            }},
            debug_0: {value: function (message, p1, p2, p3, p4, p5) {
              if (this.DEBUG) {
                this.internal_debug(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            }},
            internal_debug: {value: function (message, ex) {
              this.logger.log(this.LEVEL_DEBUG, message, ex);
            }},
            trace: {value: function (message, ex, p1, p2, p3, p4, p5) {
              if (this.TRACE) {
                this.internal_trace(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            }},
            trace_0: {value: function (message, p1, p2, p3, p4, p5) {
              if (this.TRACE) {
                this.internal_trace(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            }},
            internal_trace: {value: function (message, ex) {
              this.logger.log(this.LEVEL_TRACE, message, ex);
            }}
          })});
        }, {
          Logger: {value: Kotlin.createClass(null, function () {
            Object.defineProperty(this, 'firstLogTime', {value: (new Date()).getTime()});
            Object.defineProperty(this, 'error_msg', {value: ' ERROR: '});
            Object.defineProperty(this, 'warn_msg', {value: ' WARN: '});
            Object.defineProperty(this, 'info_msg', {value: ' INFO: '});
            Object.defineProperty(this, 'debug_msg', {value: ' DEBUG: '});
            Object.defineProperty(this, 'trace_msg', {value: ' TRACE: '});
            Object.defineProperty(this, 'category', {value: null, writable: true});
          }, /** @lends _.org.kevoree.log.Logger.prototype */ {
            setCategory: {value: function (category) {
              this.category = category;
            }},
            log: {value: function (level, message, ex) {
              var builder = _.java.lang.StringBuilder();
              var time = (new Date()).getTime() - this.firstLogTime;
              var minutes = time / (1000 * 60) | 0;
              var seconds = (time / 1000 | 0) % 60;
              if (minutes <= 9)
                builder.append_0('0');
              builder.append(Kotlin.toString(minutes));
              builder.append_0(':');
              if (seconds <= 9)
                builder.append_0('0');
              builder.append(Kotlin.toString(seconds));
              if (level === _.org.kevoree.log.Log.LEVEL_ERROR) {
                builder.append(this.error_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_WARN) {
                builder.append(this.warn_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_INFO) {
                builder.append(this.info_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_DEBUG) {
                builder.append(this.debug_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_TRACE) {
                builder.append(this.trace_msg);
              }
               else {
              }
              if (this.category != null) {
                builder.append_0('[');
                var tmp$0;
                builder.append(((tmp$0 = this.category) != null ? tmp$0 : Kotlin.throwNPE()).toString());
                builder.append('] ');
              }
              builder.append(message);
              if (ex != null) {
                builder.append(Kotlin.toString(ex.getMessage()));
              }
              this.print(builder.toString());
            }},
            print: {value: function (message) {
              Kotlin.println(message);
            }}
          })}
        }),
        container: Kotlin.definePackage(null, {
          KMFContainerImpl: {value: classes.cv},
          RemoveFromContainerCommand: {value: Kotlin.createClass(null, function (target, mutatorType, refName, element) {
            Object.defineProperty(this, 'target', {value: target});
            Object.defineProperty(this, 'mutatorType', {value: mutatorType});
            Object.defineProperty(this, 'refName', {value: refName});
            Object.defineProperty(this, 'element', {value: element});
          }, /** @lends _.org.kevoree.container.RemoveFromContainerCommand.prototype */ {
            run: {value: function () {
              this.target.reflexiveMutator(this.mutatorType, this.refName, this.element, true, true);
            }}
          })}
        }),
        serializer: Kotlin.definePackage(null, {
          XMIModelSerializer: {value: Kotlin.createClass(classes.c7, function $fun() {
            $fun.baseInitializer.call(this);
          })},
          JSONModelSerializer: {value: Kotlin.createClass(classes.cc, function $fun() {
            $fun.baseInitializer.call(this);
          })}
        }),
        cloner: Kotlin.definePackage(null, {
          DefaultModelCloner: {value: Kotlin.createClass(classes.c8, function () {
            Object.defineProperty(this, 'mainFactory', {value: _.org.kevoree.factory.MainFactory(), writable: true});
          }, /** @lends _.org.kevoree.cloner.DefaultModelCloner.prototype */ {
            createContext: {value: function () {
              return Kotlin.ComplexHashMap(0);
            }, writable: true}
          })}
        }),
        compare: Kotlin.definePackage(null, {
          DefaultModelCompare: {value: Kotlin.createClass(classes.c9, null, /** @lends _.org.kevoree.compare.DefaultModelCompare.prototype */ {
            createSequence: {value: function () {
              return _.org.kevoree.trace.DefaultTraceSequence();
            }, writable: true}
          })}
        }),
        factory: Kotlin.definePackage(function () {
          Object.defineProperty(this, 'Package', {value: Kotlin.createObject(null, function () {
            Object.defineProperty(this, 'ORG_KEVOREE', {value: 0});
          }, {
            getPackageForName: {value: function (metaClassName) {
              if (metaClassName.startsWith('org.kevoree')) {
                return 0;
              }
              return -1;
            }}
          })});
        }, {
          MainFactory: {value: Kotlin.createClass(classes.c5, function () {
            Object.defineProperty(this, 'factories', {value: Kotlin.arrayFromFun(1, function (i) {
              return null;
            }), writable: true});
            this.factories[_.org.kevoree.factory.Package.ORG_KEVOREE] = _.org.kevoree.impl.DefaultKevoreeFactory();
          }, /** @lends _.org.kevoree.factory.MainFactory.prototype */ {
            getFactoryForPackage: {value: function (pack) {
              return this.factories[pack];
            }},
            getKevoreeFactory: {value: function () {
              var tmp$0;
              return (tmp$0 = this.factories[_.org.kevoree.factory.Package.ORG_KEVOREE]) != null ? tmp$0 : Kotlin.throwNPE();
            }},
            setKevoreeFactory: {value: function (fct) {
              this.factories[_.org.kevoree.factory.Package.ORG_KEVOREE] = fct;
            }},
            create: {value: function (metaClassName) {
              var pack = _.org.kevoree.factory.Package.getPackageForName(metaClassName);
              if (pack !== -1) {
                var tmp$0;
                return (tmp$0 = this.getFactoryForPackage(pack)) != null ? tmp$0.create(metaClassName) : null;
              }
               else {
                var tmp$1, tmp$2, tmp$3, tmp$4;
                {
                  tmp$1 = Kotlin.arrayIndices(this.factories), tmp$2 = tmp$1.get_start(), tmp$3 = tmp$1.get_end(), tmp$4 = tmp$1.get_increment();
                  for (var i = tmp$2; i <= tmp$3; i += tmp$4) {
                    var tmp$5;
                    var obj = ((tmp$5 = this.factories[i]) != null ? tmp$5 : Kotlin.throwNPE()).create(metaClassName);
                    if (obj != null) {
                      return obj;
                    }
                  }
                }
                return null;
              }
            }, writable: true}
          })}
        }),
        trace: Kotlin.definePackage(null, {
          DefaultTraceSequence: {value: Kotlin.createClass(classes.ch, function () {
            Object.defineProperty(this, 'traces', {value: Kotlin.ArrayList(0), writable: true});
            Object.defineProperty(this, 'factory', {value: _.org.kevoree.factory.MainFactory(), writable: true});
          })}
        }),
        util: Kotlin.definePackage(function () {
          Object.defineProperty(this, 'Constants', {value: Kotlin.createObject(null, function () {
            Object.defineProperty(this, 'UNKNOWN_MUTATION_TYPE_EXCEPTION', {value: 'Unknown mutation type: '});
            Object.defineProperty(this, 'READ_ONLY_EXCEPTION', {value: 'This model is ReadOnly. Elements are not modifiable.'});
            Object.defineProperty(this, 'LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION', {value: 'The list in parameter of the setter cannot be null. Use removeAll to empty a collection.'});
            Object.defineProperty(this, 'ELEMENT_HAS_NO_KEY_IN_COLLECTION', {value: 'Cannot set the collection, because at least one element of it has no key!'});
            Object.defineProperty(this, 'EMPTY_KEY', {value: 'Key empty : please set the attribute key before adding the object.'});
            Object.defineProperty(this, 'KMFQL_CONTAINED', {value: 'contained'});
            Object.defineProperty(this, 'org_kevoree_Instance', {value: 'org.kevoree.Instance'});
            Object.defineProperty(this, 'Ref_superTypes', {value: 'superTypes'});
            Object.defineProperty(this, 'Ref_ports', {value: 'ports'});
            Object.defineProperty(this, 'Att_started', {value: 'started'});
            Object.defineProperty(this, 'org_kevoree_NodeNetwork', {value: 'org.kevoree.NodeNetwork'});
            Object.defineProperty(this, 'org_kevoree_TypedElement', {value: 'org.kevoree.TypedElement'});
            Object.defineProperty(this, 'Ref_hub', {value: 'hub'});
            Object.defineProperty(this, 'Ref_defaultValues', {value: 'defaultValues'});
            Object.defineProperty(this, 'Ref_dataTypes', {value: 'dataTypes'});
            Object.defineProperty(this, 'Att_factoryBean', {value: 'factoryBean'});
            Object.defineProperty(this, 'Ref_port', {value: 'port'});
            Object.defineProperty(this, 'Ref_returnType', {value: 'returnType'});
            Object.defineProperty(this, 'CN_AdaptationPrimitiveType', {value: 'AdaptationPrimitiveType'});
            Object.defineProperty(this, 'CN_Dictionary', {value: 'Dictionary'});
            Object.defineProperty(this, 'Ref_portTypeRef', {value: 'portTypeRef'});
            Object.defineProperty(this, 'CN_ContainerRoot', {value: 'ContainerRoot'});
            Object.defineProperty(this, 'CN_Operation', {value: 'Operation'});
            Object.defineProperty(this, 'CN_PortType', {value: 'PortType'});
            Object.defineProperty(this, 'Att_networkType', {value: 'networkType'});
            Object.defineProperty(this, 'Ref_values', {value: 'values'});
            Object.defineProperty(this, 'Ref_initBy', {value: 'initBy'});
            Object.defineProperty(this, 'Ref_link', {value: 'link'});
            Object.defineProperty(this, 'org_kevoree_ContainerRoot', {value: 'org.kevoree.ContainerRoot'});
            Object.defineProperty(this, 'CN_Group', {value: 'Group'});
            Object.defineProperty(this, 'Ref_hosts', {value: 'hosts'});
            Object.defineProperty(this, 'Att_interface', {value: 'interface'});
            Object.defineProperty(this, 'org_kevoree_MBinding', {value: 'org.kevoree.MBinding'});
            Object.defineProperty(this, 'Ref_subTypes', {value: 'subTypes'});
            Object.defineProperty(this, 'Ref_groups', {value: 'groups'});
            Object.defineProperty(this, 'org_kevoree_Group', {value: 'org.kevoree.Group'});
            Object.defineProperty(this, 'Att_type', {value: 'type'});
            Object.defineProperty(this, 'CN_TypedElement', {value: 'TypedElement'});
            Object.defineProperty(this, 'Ref_dictionary', {value: 'dictionary'});
            Object.defineProperty(this, 'Att_updateMethod', {value: 'updateMethod'});
            Object.defineProperty(this, 'Ref_integrationPatterns', {value: 'integrationPatterns'});
            Object.defineProperty(this, 'org_kevoree_DeployUnit', {value: 'org.kevoree.DeployUnit'});
            Object.defineProperty(this, 'Att_unitName', {value: 'unitName'});
            Object.defineProperty(this, 'Ref_hubs', {value: 'hubs'});
            Object.defineProperty(this, 'Ref_parent', {value: 'parent'});
            Object.defineProperty(this, 'Ref_mappings', {value: 'mappings'});
            Object.defineProperty(this, 'Ref_attributes', {value: 'attributes'});
            Object.defineProperty(this, 'Att_hashcode', {value: 'hashcode'});
            Object.defineProperty(this, 'Att_lowerFragments', {value: 'lowerFragments'});
            Object.defineProperty(this, 'Ref_targetNodeType', {value: 'targetNodeType'});
            Object.defineProperty(this, 'Att_datatype', {value: 'datatype'});
            Object.defineProperty(this, 'Ref_type', {value: 'type'});
            Object.defineProperty(this, 'org_kevoree_LifeCycleTypeDefinition', {value: 'org.kevoree.LifeCycleTypeDefinition'});
            Object.defineProperty(this, 'Att_abstract', {value: 'abstract'});
            Object.defineProperty(this, 'org_kevoree_AdaptationPrimitiveType', {value: 'org.kevoree.AdaptationPrimitiveType'});
            Object.defineProperty(this, 'Att_version', {value: 'version'});
            Object.defineProperty(this, 'CN_Namespace', {value: 'Namespace'});
            Object.defineProperty(this, 'org_kevoree_ContainerNode', {value: 'org.kevoree.ContainerNode'});
            Object.defineProperty(this, 'Ref_components', {value: 'components'});
            Object.defineProperty(this, 'org_kevoree_AdaptationPrimitiveTypeRef', {value: 'org.kevoree.AdaptationPrimitiveTypeRef'});
            Object.defineProperty(this, 'Att_stopMethod', {value: 'stopMethod'});
            Object.defineProperty(this, 'CN_ExtraFonctionalProperty', {value: 'ExtraFonctionalProperty'});
            Object.defineProperty(this, 'Ref_childs', {value: 'childs'});
            Object.defineProperty(this, 'CN_ChannelType', {value: 'ChannelType'});
            Object.defineProperty(this, 'CN_GroupType', {value: 'GroupType'});
            Object.defineProperty(this, 'Ref_typeDefinitions', {value: 'typeDefinitions'});
            Object.defineProperty(this, 'Ref_genericTypes', {value: 'genericTypes'});
            Object.defineProperty(this, 'CN_CompositeType', {value: 'CompositeType'});
            Object.defineProperty(this, 'Ref_requiredLibs', {value: 'requiredLibs'});
            Object.defineProperty(this, 'CN_PortTypeRef', {value: 'PortTypeRef'});
            Object.defineProperty(this, 'Att_maxTime', {value: 'maxTime'});
            Object.defineProperty(this, 'org_kevoree_DictionaryValue', {value: 'org.kevoree.DictionaryValue'});
            Object.defineProperty(this, 'Ref_units', {value: 'units'});
            Object.defineProperty(this, 'CN_DeployUnit', {value: 'DeployUnit'});
            Object.defineProperty(this, 'org_kevoree_NodeLink', {value: 'org.kevoree.NodeLink'});
            Object.defineProperty(this, 'org_kevoree_Parameter', {value: 'org.kevoree.Parameter'});
            Object.defineProperty(this, 'org_kevoree_Repository', {value: 'org.kevoree.Repository'});
            Object.defineProperty(this, 'CN_NamedElement', {value: 'NamedElement'});
            Object.defineProperty(this, 'Att_serviceMethodName', {value: 'serviceMethodName'});
            Object.defineProperty(this, 'CN_Instance', {value: 'Instance'});
            Object.defineProperty(this, 'Ref_networkProperties', {value: 'networkProperties'});
            Object.defineProperty(this, 'CN_AdaptationPrimitiveTypeRef', {value: 'AdaptationPrimitiveTypeRef'});
            Object.defineProperty(this, 'Att_name', {value: 'name'});
            Object.defineProperty(this, 'CN_Repository', {value: 'Repository'});
            Object.defineProperty(this, 'CN_ComponentType', {value: 'ComponentType'});
            Object.defineProperty(this, 'Att_order', {value: 'order'});
            Object.defineProperty(this, 'Att_startMethod', {value: 'startMethod'});
            Object.defineProperty(this, 'Att_lowerBindings', {value: 'lowerBindings'});
            Object.defineProperty(this, 'org_kevoree_CompositeType', {value: 'org.kevoree.CompositeType'});
            Object.defineProperty(this, 'org_kevoree_GroupType', {value: 'org.kevoree.GroupType'});
            Object.defineProperty(this, 'org_kevoree_Operation', {value: 'org.kevoree.Operation'});
            Object.defineProperty(this, 'CN_Port', {value: 'Port'});
            Object.defineProperty(this, 'Att_optional', {value: 'optional'});
            Object.defineProperty(this, 'Ref_targetNode', {value: 'targetNode'});
            Object.defineProperty(this, 'Ref_attribute', {value: 'attribute'});
            Object.defineProperty(this, 'Att_metaData', {value: 'metaData'});
            Object.defineProperty(this, 'Att_beanMethodName', {value: 'beanMethodName'});
            Object.defineProperty(this, 'org_kevoree_TypeDefinition', {value: 'org.kevoree.TypeDefinition'});
            Object.defineProperty(this, 'Ref_target', {value: 'target'});
            Object.defineProperty(this, 'org_kevoree_TypeLibrary', {value: 'org.kevoree.TypeLibrary'});
            Object.defineProperty(this, 'Att_paramTypes', {value: 'paramTypes'});
            Object.defineProperty(this, 'CN_MBinding', {value: 'MBinding'});
            Object.defineProperty(this, 'Att_noDependency', {value: 'noDependency'});
            Object.defineProperty(this, 'CN_NodeLink', {value: 'NodeLink'});
            Object.defineProperty(this, 'CN_PortTypeMapping', {value: 'PortTypeMapping'});
            Object.defineProperty(this, 'Ref_provided', {value: 'provided'});
            Object.defineProperty(this, 'org_kevoree_PortTypeMapping', {value: 'org.kevoree.PortTypeMapping'});
            Object.defineProperty(this, 'Ref_dictionaryType', {value: 'dictionaryType'});
            Object.defineProperty(this, 'CN_ComponentInstance', {value: 'ComponentInstance'});
            Object.defineProperty(this, 'Att_zoneID', {value: 'zoneID'});
            Object.defineProperty(this, 'Att_upperBindings', {value: 'upperBindings'});
            Object.defineProperty(this, 'Ref_host', {value: 'host'});
            Object.defineProperty(this, 'CN_TypeLibrary', {value: 'TypeLibrary'});
            Object.defineProperty(this, 'Ref_adaptationPrimitiveTypes', {value: 'adaptationPrimitiveTypes'});
            Object.defineProperty(this, 'Att_url', {value: 'url'});
            Object.defineProperty(this, 'Ref_namespace', {value: 'namespace'});
            Object.defineProperty(this, 'org_kevoree_NodeType', {value: 'org.kevoree.NodeType'});
            Object.defineProperty(this, 'Ref_managedPrimitiveTypes', {value: 'managedPrimitiveTypes'});
            Object.defineProperty(this, 'CN_LifeCycleTypeDefinition', {value: 'LifeCycleTypeDefinition'});
            Object.defineProperty(this, 'CN_ServicePortType', {value: 'ServicePortType'});
            Object.defineProperty(this, 'CN_NodeNetwork', {value: 'NodeNetwork'});
            Object.defineProperty(this, 'Att_state', {value: 'state'});
            Object.defineProperty(this, 'Att_fragmentDependant', {value: 'fragmentDependant'});
            Object.defineProperty(this, 'org_kevoree_ServicePortType', {value: 'org.kevoree.ServicePortType'});
            Object.defineProperty(this, 'org_kevoree_PortType', {value: 'org.kevoree.PortType'});
            Object.defineProperty(this, 'CN_MessagePortType', {value: 'MessagePortType'});
            Object.defineProperty(this, 'Ref_operations', {value: 'operations'});
            Object.defineProperty(this, 'CN_DictionaryAttribute', {value: 'DictionaryAttribute'});
            Object.defineProperty(this, 'Att_generated_KMF_ID', {value: 'generated_KMF_ID'});
            Object.defineProperty(this, 'org_kevoree_NamedElement', {value: 'org.kevoree.NamedElement'});
            Object.defineProperty(this, 'CN_TypeDefinition', {value: 'TypeDefinition'});
            Object.defineProperty(this, 'org_kevoree_ComponentType', {value: 'org.kevoree.ComponentType'});
            Object.defineProperty(this, 'Ref_mBindings', {value: 'mBindings'});
            Object.defineProperty(this, 'Ref_subNodes', {value: 'subNodes'});
            Object.defineProperty(this, 'Ref_nodes', {value: 'nodes'});
            Object.defineProperty(this, 'org_kevoree_ChannelType', {value: 'org.kevoree.ChannelType'});
            Object.defineProperty(this, 'Ref_nodeNetworks', {value: 'nodeNetworks'});
            Object.defineProperty(this, 'Ref_parameters', {value: 'parameters'});
            Object.defineProperty(this, 'Ref_portTypes', {value: 'portTypes'});
            Object.defineProperty(this, 'Att_estimatedRate', {value: 'estimatedRate'});
            Object.defineProperty(this, 'Att_value', {value: 'value'});
            Object.defineProperty(this, 'org_kevoree_NetworkProperty', {value: 'org.kevoree.NetworkProperty'});
            Object.defineProperty(this, 'org_kevoree_Port', {value: 'org.kevoree.Port'});
            Object.defineProperty(this, 'Ref_managedPrimitiveTypeRefs', {value: 'managedPrimitiveTypeRefs'});
            Object.defineProperty(this, 'org_kevoree_ComponentInstance', {value: 'org.kevoree.ComponentInstance'});
            Object.defineProperty(this, 'org_kevoree_IntegrationPattern', {value: 'org.kevoree.IntegrationPattern'});
            Object.defineProperty(this, 'org_kevoree_DictionaryAttribute', {value: 'org.kevoree.DictionaryAttribute'});
            Object.defineProperty(this, 'Ref_wires', {value: 'wires'});
            Object.defineProperty(this, 'org_kevoree_Namespace', {value: 'org.kevoree.Namespace'});
            Object.defineProperty(this, 'Ref_typeDefinition', {value: 'typeDefinition'});
            Object.defineProperty(this, 'org_kevoree_Channel', {value: 'org.kevoree.Channel'});
            Object.defineProperty(this, 'Ref_deployUnits', {value: 'deployUnits'});
            Object.defineProperty(this, 'org_kevoree_Wire', {value: 'org.kevoree.Wire'});
            Object.defineProperty(this, 'org_kevoree_Dictionary', {value: 'org.kevoree.Dictionary'});
            Object.defineProperty(this, 'Att_synchrone', {value: 'synchrone'});
            Object.defineProperty(this, 'CN_Wire', {value: 'Wire'});
            Object.defineProperty(this, 'Ref_repositories', {value: 'repositories'});
            Object.defineProperty(this, 'Ref_required', {value: 'required'});
            Object.defineProperty(this, 'org_kevoree_ExtraFonctionalProperty', {value: 'org.kevoree.ExtraFonctionalProperty'});
            Object.defineProperty(this, 'Att_lastCheck', {value: 'lastCheck'});
            Object.defineProperty(this, 'Ref_libraries', {value: 'libraries'});
            Object.defineProperty(this, 'Att_upperFragments', {value: 'upperFragments'});
            Object.defineProperty(this, 'CN_IntegrationPattern', {value: 'IntegrationPattern'});
            Object.defineProperty(this, 'CN_ContainerNode', {value: 'ContainerNode'});
            Object.defineProperty(this, 'Att_groupName', {value: 'groupName'});
            Object.defineProperty(this, 'CN_Parameter', {value: 'Parameter'});
            Object.defineProperty(this, 'CN_DictionaryValue', {value: 'DictionaryValue'});
            Object.defineProperty(this, 'org_kevoree_PortTypeRef', {value: 'org.kevoree.PortTypeRef'});
            Object.defineProperty(this, 'Ref_filters', {value: 'filters'});
            Object.defineProperty(this, 'CN_NetworkProperty', {value: 'NetworkProperty'});
            Object.defineProperty(this, 'org_kevoree_DictionaryType', {value: 'org.kevoree.DictionaryType'});
            Object.defineProperty(this, 'CN_NodeType', {value: 'NodeType'});
            Object.defineProperty(this, 'Att_bean', {value: 'bean'});
            Object.defineProperty(this, 'CN_Channel', {value: 'Channel'});
            Object.defineProperty(this, 'Ref_bindings', {value: 'bindings'});
            Object.defineProperty(this, 'Ref_ref', {value: 'ref'});
            Object.defineProperty(this, 'CN_DictionaryType', {value: 'DictionaryType'});
            Object.defineProperty(this, 'Ref_extraFonctionalProperties', {value: 'extraFonctionalProperties'});
            Object.defineProperty(this, 'org_kevoree_MessagePortType', {value: 'org.kevoree.MessagePortType'});
          })});
        }, {
        })
      }),
      w3c: Kotlin.definePackage(null, {
        dom: Kotlin.definePackage(null, {
          events: Kotlin.definePackage(null, {
            EventListener: {value: classes.c1p}
          })
        })
      })
    }),
    js: Kotlin.definePackage(null, {
      toChar: {value: function ($receiver) {
        return $receiver != null ? $receiver : Kotlin.throwNPE();
      }},
      lastIndexOf: {value: function ($receiver, ch, fromIndex) {
        return $receiver.lastIndexOf(Kotlin.toString(ch), fromIndex);
      }},
      lastIndexOf_0: {value: function ($receiver, ch) {
        return $receiver.lastIndexOf(Kotlin.toString(ch));
      }},
      indexOf: {value: function ($receiver, ch) {
        return $receiver.indexOf(Kotlin.toString(ch));
      }},
      indexOf_0: {value: function ($receiver, ch, fromIndex) {
        return $receiver.indexOf(Kotlin.toString(ch), fromIndex);
      }},
      matches: {value: function ($receiver, regex) {
        var result = $receiver.match(regex);
        return result != null && result.length > 0;
      }},
      capitalize: {value: function ($receiver) {
        return _.kotlin.isNotEmpty($receiver) ? $receiver.substring(0, 1).toUpperCase() + $receiver.substring(1) : $receiver;
      }},
      decapitalize: {value: function ($receiver) {
        return _.kotlin.isNotEmpty($receiver) ? $receiver.substring(0, 1).toLowerCase() + $receiver.substring(1) : $receiver;
      }}
    }),
    java: Kotlin.definePackage(null, {
      lang: Kotlin.definePackage(null, {
        StringBuilder: {value: Kotlin.createClass(null, function () {
          Object.defineProperty(this, 'content', {value: '', writable: true});
        }, /** @lends _.java.lang.StringBuilder.prototype */ {
          append: {value: function (sub) {
            this.content = this.content + sub;
          }},
          append_0: {value: function (sub) {
            this.content = this.content + sub;
          }},
          delete: {value: function (startIndex, endIndex) {
            this.content = '';
          }},
          length: {value: function () {
            return this.content.length;
          }},
          toString: {value: function () {
            return this.content;
          }}
        })}
      }),
      io: Kotlin.definePackage(null, {
        InputStream: {value: classes.c1n},
        OutputStream: {value: classes.c1o},
        BufferedOutputStream: {value: Kotlin.createClass(classes.c1o, function (oo) {
          Object.defineProperty(this, 'oo', {value: oo});
        }, /** @lends _.java.io.BufferedOutputStream.prototype */ {
          write: {value: function (s) {
            var tmp$0;
            ((tmp$0 = this.oo) != null ? tmp$0 : Kotlin.throwNPE()).result = s;
          }}
        })},
        ByteArrayInputStream: {value: Kotlin.createClass(classes.c1n, function (inputBytes) {
          Object.defineProperty(this, 'inputBytes', {value: inputBytes});
        }, /** @lends _.java.io.ByteArrayInputStream.prototype */ {
          readBytes: {value: function () {
            return this.inputBytes;
          }, writable: true}
        })},
        ByteArrayOutputStream: {value: Kotlin.createClass(classes.c1o, function () {
          Object.defineProperty(this, 'result', {value: '', writable: true});
        }, /** @lends _.java.io.ByteArrayOutputStream.prototype */ {
          flush: {value: function () {
          }},
          close: {value: function () {
          }},
          toString: {value: function () {
            return this.result;
          }}
        })},
        PrintStream: {value: Kotlin.createClass(null, function (oo, autoflush) {
          Object.defineProperty(this, 'oo', {value: oo});
          Object.defineProperty(this, 'result', {value: '', writable: true});
        }, /** @lends _.java.io.PrintStream.prototype */ {
          println_1: {value: function () {
            this.result = this.result + '\n';
          }},
          print: {value: function (s) {
            this.result = this.result + s;
          }},
          println: {value: function (s) {
            this.print(s);
            this.println_1();
          }},
          print_0: {value: function (s) {
            this.result = this.result + s;
          }},
          print_1: {value: function (s) {
            this.result = this.result + s;
          }},
          print_2: {value: function (s) {
            this.result = this.result + s;
          }},
          print_3: {value: function (s) {
            if (s) {
              this.result = this.result + 'true';
            }
             else {
              this.result = this.result + 'false';
            }
          }},
          println_0: {value: function (s) {
            this.print_0(s);
            this.println_1();
          }},
          flush: {value: function () {
            var tmp$0;
            ((tmp$0 = this.oo) != null ? tmp$0 : Kotlin.throwNPE()).write(this.result);
          }},
          close: {value: function () {
          }}
        })}
      }),
      util: Kotlin.definePackage(null, {
        Collections: Kotlin.definePackage(null, {
        })
      })
    })
  });
  Kotlin.defineModule('org.kevoree.model.js', _);
}());
if (typeof(module) != 'undefined') {
    module.exports = Kotlin.modules['org.kevoree.model.js'];
}
