var kevoree      = require('kevoree-library').org.kevoree,
    getJSONModel = require('kevoree-model-sync').getJSONModel,
    async        = require('async');

var factory = new kevoree.impl.DefaultKevoreeFactory();
var cloner  = new kevoree.cloner.DefaultModelCloner();
var compare = new kevoree.compare.DefaultModelCompare();

/**
 *
 * @param parsedModel
 * @param ctxModel
 * @param callback
 */
var generator = function generator(parsedModel, ctxModel, callback) {
  var model = null;
  // if we have a context model, clone it and use it has a base
  if (ctxModel) model = cloner.clone(ctxModel, false);
  // otherwise start from a brand new model
  else model = factory.createContainerRoot();

  // merge models
  mergeModels(model, parsedModel.deployUnits, function (err) {
    if (err) return callback(err);

    // merging models succeed
    processNodes(model, parsedModel.nodes, callback);
    processGroups(model, parsedModel.groups, callback);
    processChans(model, parsedModel.chans, callback);
    processBindings(model, parsedModel.bindings, callback);

    return callback(null, model);
  });
}

/**
 *
 * @param model
 * @param deployUnits this is not a DeployUnit class object from 'kevoree-library',
 *        this is a representation of a deployUnit generated by the KevScript parser
 * @param callback
 */
var mergeModels = function mergeModels(model, deployUnits, callback) {
  // array of tasks to execute in series with 'async' lib
  var tasks = [];

  for (var i in deployUnits) {
    (function (du) {
      tasks.push(function (cb) {
        if (du.type == 'npm') {
          getJSONModel(du.name, du.version, function (err, model) {
            if (err) return cb(err);
            return cb(null, model);
          });
        } else {
          // other type are not handled yet
          console.log('KevScript model generator does not handle "'+du.type+'" for DeployUnit resolving yet.');
          return cb();
        }
      });
    })(deployUnits[i]);
  }

  // execute tasks in series
  async.series(tasks, function (err, models) {
    if (err) return callback(err);

    // each task execution ended well: merge every model
    for (var i in models) {
      var mergeSeq = compare.merge(model, models[i]);
      // apply merge on 'model' so it modifies its state
      mergeSeq.applyOn(model);
    }

    // good to go
    callback();
  });
}

var processNodes = function processNodes(model, nodes, callback) {
  // processNodes
  for (var name in nodes) {
    try {
      var node = factory.createContainerNode();
      node.name = name;
      node.typeDefinition = model.findTypeDefinitionsByID(nodes[name].type);
      // process components
      for (var compName in nodes[name].components) {
        var comp = factory.createComponentInstance();
        comp.name = compName;
        comp.typeDefinition = model.findTypeDefinitionsByID(nodes[name].components[compName].type);
        processDictionary(model, comp, nodes[name].components[compName].dictionary, callback);
        node.addComponents(comp);
      }
      processDictionary(model, node, nodes[name].dictionary, callback);
      model.addNodes(node);

    } catch (err) {
      return callback(err);
    }
  }
}

var processGroups = function processGroups(model, groups, callback) {
  for (var name in groups) {
    try {
      var grp = factory.createGroup();
      grp.name = name;
      grp.typeDefinition = model.findTypeDefinitionsByID(groups[name].type);

      // add subnodes
      for (var i in groups[name].subnodes) {
        var node = model.findNodesByID(groups[name].subnodes[i]);
        grp.addSubNodes(node);
        node.addGroups(grp);
      }

      processDictionary(model, grp, groups[name].dictionary, callback);
      model.addGroups(grp);

    } catch (err) {
      return callback(err);
    }
  }
}

var processChans = function processChans(model, chans, callback) {
  for (var name in chans) {
    try {
      var chan = factory.createChannel();
      chan.name = name;
      chan.typeDefinition = model.findTypeDefinitionsByID(chans[name].type);
      processDictionary(model, chan, chans[name].dictionary, callback);
      model.addHubs(chan);

    } catch (err) {
      return callback(err);
    }
  }
}

var processBindings = function processBindings(model, bindings, callback) {
  for (var i in bindings) {
    try {
      var binding = factory.createMBinding();
      // process port
      var port = factory.createPort();
      port.name = bindings[i].from.port;
      // lets try to find the component in the model
      var nodes = model.nodes.iterator();
      while (nodes.hasNext()) {
        var node = nodes.next();
        var comps = node.components.iterator();
        while (comps.hasNext()) {
          var comp = comps.next();
          if (comp.name == bindings[i].from.comp) {
            // this is the component we are looking for
            // now determine if the port we want to add is a "required" or a "provided"
            var provided = comp.typeDefinition.provided.iterator();
            while (provided.hasNext()) {
              var providedPort = provided.next();
              if (providedPort.name == port.name) {
                // this is the port ref we are looking for
                port.portTypeRef = providedPort;
                comp.addProvided(port);
                break;
              }
            }

            if (!port.portTypeRef) {
              // not a provided apparently, check if it is a required
              var required = comp.typeDefinition.required.iterator();
              while (required.hasNext()) {
                var requiredPort = required.next();
                if (requiredPort.name == port.name) {
                  // this is the port ref we are looking for
                  port.portTypeRef = requiredPort;
                  comp.addRequired(port);
                  break;
                }
              }
            }

            if (!port.portTypeRef) {
              return callback(new Error('Unable to find "'+port.name+'" in "'+comp.typeDefinition.name+'" typeDef ports'));
            }

            // if we reach this point, it means that we have found the port and set it properly
            port.addBindings(binding);
          }
        }
      }

      binding.hub = model.findHubsByID(bindings[i].to);
      model.addMBindings(binding);
    } catch (err) {
      return callback(err);
    }
  }
}

var processDictionary = function processDictionary(model, entity, dictionary, callback) {
  try {
    var dic = entity.dictionary || factory.createDictionary();
    var attrs = entity.typeDefinition.dictionaryType.attributes;

    function getDictionaryAttributeFromName(name) {
      for (var i=0; i < attrs.size(); i++) {
        if (attrs.get(i).name == name) return attrs.get(i);
      }
      return callback(new Error('Unable to find "'+name+'" in "'+entity.typeDefinition.name+'" typeDef dictionary.'));
    }

    for (var name in dictionary) {
      var val = factory.createDictionaryValue();
      val.attribute = getDictionaryAttributeFromName(name);
      val.value = dictionary[name].value;
      if (typeof(dictionary[name].targetNodeName) != 'undefined') {
        val.targetNode = model.findNodesByID(dictionary[name].targetNodeName);
      }
      dic.addValues(val);
    }

    entity.dictionary = dic;
  } catch (err) {
    return callback(err);
  }
}

module.exports = generator;