var kevoree      = require('kevoree-library').org.kevoree,
    getJSONModel = require('kevoree-model-sync').getJSONModel,
    async        = require('async');

var factory = new kevoree.impl.DefaultKevoreeFactory();
var cloner  = new kevoree.cloner.DefaultModelCloner();
var compare = new kevoree.compare.DefaultModelCompare();

/**
 *
 * @param parsedModel
 * @param ctxModel
 * @param callback
 */
var generator = function generator(parsedModel, ctxModel, callback) {
  var model = null;
  // if we have a context model, clone it and use it has a base
  if (ctxModel) model = cloner.clone(ctxModel, false);
  // otherwise start from a brand new model
  else model = factory.createContainerRoot();

  // merge models
  mergeModels(model, parsedModel.deployUnits, function (err) {
    if (err) return callback(err);

    // merging models succeed
    return callback(null, model);
  });
}

/**
 *
 * @param model
 * @param deployUnits this is not a DeployUnit class object from 'kevoree-library',
 *        this is a representation of a deployUnit generated by the KevScript parser
 * @param callback
 */
var mergeModels = function mergeModels(model, deployUnits, callback) {
  // array of tasks to execute in series with 'async' lib
  var tasks = [];

  for (var i in deployUnits) {
    (function (du) {
      tasks.push(function (cb) {
        if (du.type == 'npm') {
          getJSONModel(du.name, du.version, function (err, model) {
            if (err) return cb(err);
            return cb(null, model);
          });
        } else {
          // other type are not handled yet
          console.log('KevScript model generator does not handle "'+du.type+'" for DeployUnit resolving yet.');
          cb();
        }
      });
    })(deployUnits[i]);
  }

  // execute tasks in series
  async.series(tasks, function (err, models) {
    if (err) return callback(err);

    // each task execution ended well: merge every model
    for (var i in models) {
      var mergeSeq = compare.merge(model, models[i]);
      // apply merge on 'model' so it modifies its state
      mergeSeq.applyOn(model);
    }

    // good to go
    callback();
  });
}

module.exports = generator;