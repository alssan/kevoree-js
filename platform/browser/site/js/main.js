;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var __dirname="/";var Core                    = require('kevoree-core'),
    JSONModelLoader         = require('kevoree-library').org.kevoree.loader.JSONModelLoader,
    KevoreeBrowserLogger    = require('./lib/KevoreeBrowserLogger'),
    HTTPBootstrapper        = require('./lib/HTTPBootstrapper');

var log = new KevoreeBrowserLogger('Runtime');

// init core objects
var kevoreeCore     = new Core(__dirname, log),
    jsonLoader      = new JSONModelLoader(),
    model           = jsonLoader.loadModelFromString(JSON.stringify(require('./model.json'))).get(0),
    bootstrapper    = new HTTPBootstrapper(__dirname);

// init DOM objects
var startBtn    = document.getElementById('start-btn'),
    deployBtn   = document.getElementById('deploy-btn'),
    started     = false;

kevoreeCore.on('started', function () {
    log.info("KevoreeCore started");
    started = true;
    startBtn.className += " disabled";
});

kevoreeCore.on('deployed', function (err, model) {
    log.info("KevoreeCore deployed");
});

kevoreeCore.on('stopped', function (err, model) {
    log.info("KevoreeCore stopped");
    started = false;
});

kevoreeCore.on('error', function (err) {
    log.error("KevoreeCore "+err.message);
    try {
        // try to stop Kevoree Core on error
        kevoreeCore.stop();
    } catch (err) {
        started = false;
    }
});

//set Kevoree bootstrapper
kevoreeCore.setBootstrapper(bootstrapper);

// start Kevoree Core
startBtn.addEventListener('click', function () {
    if (!started) {
        try {
            kevoreeCore.start('node0');
        } catch (err) {
            log.error(err.message);
        }

    } else log.warn();
});

deployBtn.addEventListener('click', function () {
    if (started) {
        try {
            kevoreeCore.deploy(model);
        } catch (err) {
            log.error(err.message);
        }

    } else log.warn("Can't deploy model: you must start Kevoree Runtime first.");
});

},{"./lib/HTTPBootstrapper":2,"./lib/KevoreeBrowserLogger":3,"./model.json":4,"kevoree-core":5,"kevoree-library":7}],2:[function(require,module,exports){
var Class   = require('pseudoclass'),
    zlib    = require('zlib'),
    http    = require('http'),
    url     = require('url');
//    tar     = require('tar');

var HTTPBootstrapper = Class({
    toString: 'HTTPBootstrapper',

    construct: function (modulesPath) {
        this.modulesPath = modulesPath;
//        this.extracter = tar.Extract({ path: modulesPath});
    },

    bootstrapNodeType: function (nodeName, model, callback) {
        var scope = this;
        var options = {
            host: 'registry.npmjs.org',
            path: '/kevoree-node/-/kevoree-node-0.0.6.tgz',
            port: 80,
            headers: { 'accept-encoding': 'gzip,deflate' }
        };

        var req = new XMLHttpRequest();
        req.open('GET', 'http://registry.npmjs.org/kevoree-node/-/kevoree-node-0.0.6.tgz', false);
        req.send(null);
        if (req.status == 200) {
            console.log(req.responseText);
            callback();
        }

//        gunzip.on('error', callback);
//        this.extracter.on('error', callback);
//        this.extracter.on('end', onTarballExtracted);

//        var req = http.get(options);
//        if (!req) callback(new Error('Unable to create request to server'));
//
//        req.on('error', function (err) {
//            callback(err);
//        });
//
//        req.on('close', function (err) {
//            callback(new Error("Something went wrong while downloading taball"));
//        });
//
//        req.on('response', function (res) {
//            if (res.statusCode !== 200) {
//                callback(new Error(res.statusCode + ' downloading tarball'))
//                return;
//            }
//
//            res.pipe(zlib.deflate).pipe(process.stdout);
//        });
//
//        function onTarballExtracted() {
//            console.log("tarball successfully extracted");
//            callback();
//        }
    }
});

module.exports = HTTPBootstrapper;
},{"http":28,"pseudoclass":10,"url":23,"zlib":32}],3:[function(require,module,exports){
var KevoreeLogger = require('kevoree-utils').KevoreeLogger;

var logDOM  = document.getElementById('log-console'),
    ERROR   = 0,
    WARN    = 1,
    DEBUG   = 2,
    INFO    = 3;

var KevoreeBrowserLogger = KevoreeLogger.extend({
    toString: 'KevoreeBrowserLogger',

    info: function (_super, msg) {
        addLogToDOM(INFO, this.tag+': '+msg);
    },

    warn: function (_super, msg) {
        addLogToDOM(WARN, this.tag+': '+msg);
    },

    debug: function (_super, msg) {
        addLogToDOM(DEBUG, this.tag+': '+msg);
    },

    error: function (_super, msg) {
        addLogToDOM(ERROR, this.tag+': '+msg);
    }
});

var addLogToDOM = function (level, msg) {
    var li = document.createElement('li');

    switch (level) {
        // TODO add level
        case DEBUG:
            li.className += ' text-primary';
            break;

        case INFO:
            li.className += ' text-success';
            break;

        case ERROR:
            li.className += ' text-danger';
            break;

        case WARN:
            li.className += ' text-warning';
            break;
    }

    li.innerHTML = msg;
    logDOM.appendChild(li);
}

module.exports = KevoreeBrowserLogger;
},{"kevoree-utils":8}],4:[function(require,module,exports){
module.exports={
    "eClass": "org.kevoree.ContainerRoot",
    "generated_KMF_ID": "101205821378461125909",
    "nodes": [
        {
            "eClass": "org.kevoree.ContainerNode",
            "name": "node0",
            "started": "true",
            "metaData": "x=445,y=139",
            "typeDefinition": [
                "typeDefinitions[JavascriptNode]"
            ],
            "dictionary": [
                {
                    "eClass": "org.kevoree.Dictionary",
                    "generated_KMF_ID": "0.18917581019923091378806544366",
                    "values": [
                        {
                            "eClass": "org.kevoree.DictionaryValue",
                            "generated_KMF_ID": "0.004802942508831621378806544366",
                            "value": "WARN",
                            "attribute": [
                                "typeDefinitions[JavascriptNode]/dictionaryType[313116901378461125995]/attributes[coreLogLevel]"
                            ]
                        },
                        {
                            "eClass": "org.kevoree.DictionaryValue",
                            "generated_KMF_ID": "0.254928551381453871378806544366",
                            "value": "INFO",
                            "attribute": [
                                "typeDefinitions[JavascriptNode]/dictionaryType[313116901378461125995]/attributes[logLevel]"
                            ]
                        }
                    ]
                }
            ],
            "components": [
                {
                    "eClass": "org.kevoree.ComponentInstance",
                    "name": "comp0",
                    "started": "true",
                    "metaData": "x=266,y=52",
                    "typeDefinition": [
                        "typeDefinitions[HelloWorld]"
                    ],
                    "dictionary": [
                        {
                            "eClass": "org.kevoree.Dictionary",
                            "generated_KMF_ID": "0.86965738283470271378980404483"
                        }
                    ],
                    "provided": [
                        {
                            "eClass": "org.kevoree.Port",
                            "generated_KMF_ID": "0.65337726869620381379498678145",
                            "bindings": [
                                "mBindings[0.72222582343965771379498684478]"
                            ],
                            "portTypeRef": [
                                "typeDefinitions[HelloWorld]/provided[fake]"
                            ]
                        }
                    ],
                    "required": [
                        {
                            "eClass": "org.kevoree.Port",
                            "generated_KMF_ID": "0.8331616653595121379665329022",
                            "bindings": [
                                "mBindings[0.95117838773876431379665330884]"
                            ],
                            "portTypeRef": [
                                "typeDefinitions[HelloWorld]/required[sendText]"
                            ]
                        }
                    ]
                }
            ]
        }
    ],
    "typeDefinitions": [
        {
            "eClass": "org.kevoree.NodeType",
            "abstract": "false",
            "bean": "kevoree-node",
            "name": "JavascriptNode",
            "factoryBean": "org.kevoree.library.defaultNodeTypes.JavascriptNodeFactory",
            "deployUnits": [
                "deployUnits[142023381378461125966]"
            ],
            "dictionaryType": [
                {
                    "eClass": "org.kevoree.DictionaryType",
                    "generated_KMF_ID": "313116901378461125995",
                    "attributes": [
                        {
                            "eClass": "org.kevoree.DictionaryAttribute",
                            "fragmentDependant": "false",
                            "optional": "true",
                            "name": "coreLogLevel",
                            "state": "false",
                            "datatype": "enum=INFO,WARN,DEBUG,ERROR,FINE"
                        },
                        {
                            "eClass": "org.kevoree.DictionaryAttribute",
                            "fragmentDependant": "false",
                            "optional": "true",
                            "name": "logLevel",
                            "state": "false",
                            "datatype": "enum=INFO,WARN,DEBUG,ERROR,FINE"
                        }
                    ],
                    "defaultValues": [
                        {
                            "eClass": "org.kevoree.DictionaryValue",
                            "generated_KMF_ID": "235633931378461125995",
                            "value": "WARN",
                            "attribute": [
                                "typeDefinitions[JavascriptNode]/dictionaryType[313116901378461125995]/attributes[coreLogLevel]"
                            ]
                        },
                        {
                            "eClass": "org.kevoree.DictionaryValue",
                            "generated_KMF_ID": "214293611378461125995",
                            "value": "INFO",
                            "attribute": [
                                "typeDefinitions[JavascriptNode]/dictionaryType[313116901378461125995]/attributes[logLevel]"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "eClass": "org.kevoree.GroupType",
            "abstract": "false",
            "bean": "kevoree-group-websocket",
            "name": "WebSocketGroup",
            "factoryBean": "org.kevoree.library.WebSocketGroupFactory",
            "deployUnits": [
                "deployUnits[89918001378813344621]"
            ],
            "dictionaryType": [
                {
                    "eClass": "org.kevoree.DictionaryType",
                    "generated_KMF_ID": "267671911378812807634",
                    "attributes": [
                        {
                            "eClass": "org.kevoree.DictionaryAttribute",
                            "fragmentDependant": "true",
                            "optional": "true",
                            "name": "port",
                            "state": "false"
                        },
                        {
                            "eClass": "org.kevoree.DictionaryAttribute",
                            "fragmentDependant": "false",
                            "optional": "false",
                            "name": "ssl",
                            "state": "false",
                            "datatype": "enum=true,false"
                        },
                        {
                            "eClass": "org.kevoree.DictionaryAttribute",
                            "fragmentDependant": "true",
                            "optional": "true",
                            "name": "ip",
                            "state": "false"
                        }
                    ],
                    "defaultValues": [
                        {
                            "eClass": "org.kevoree.DictionaryValue",
                            "generated_KMF_ID": "119116231378812807634",
                            "value": "8000",
                            "attribute": [
                                "typeDefinitions[WebSocketGroup]/dictionaryType[267671911378812807634]/attributes[port]"
                            ]
                        },
                        {
                            "eClass": "org.kevoree.DictionaryValue",
                            "generated_KMF_ID": "252579701378812807634",
                            "value": "false",
                            "attribute": [
                                "typeDefinitions[WebSocketGroup]/dictionaryType[267671911378812807634]/attributes[ssl]"
                            ]
                        },
                        {
                            "eClass": "org.kevoree.DictionaryValue",
                            "generated_KMF_ID": "129125821378812807634",
                            "value": "0.0.0.0",
                            "attribute": [
                                "typeDefinitions[WebSocketGroup]/dictionaryType[267671911378812807634]/attributes[ip]"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "eClass": "org.kevoree.ComponentType",
            "abstract": "false",
            "bean": "kevoree-comp-helloworld",
            "name": "HelloWorld",
            "factoryBean": "org.kevoree.library.HelloWorldFactory",
            "deployUnits": [
                "deployUnits[142023381378461125333]"
            ],
            "dictionaryType": [
                {
                    "eClass": "org.kevoree.DictionaryType",
                    "generated_KMF_ID": "313116901378461125442",
                    "attributes": [],
                    "defaultValues": []
                }
            ],
            "provided": [
                {
                    "eClass": "org.kevoree.PortTypeRef",
                    "noDependency": "false",
                    "optional": "false",
                    "name": "fake",
                    "ref": [
                        "typeDefinitions[org.kevoree.framework.MessagePort]"
                    ],
                    "mappings": [
                        {
                            "eClass": "org.kevoree.PortTypeMapping",
                            "generated_KMF_ID": "7277176861376380213846",
                            "serviceMethodName": "process",
                            "beanMethodName": "appendIncoming"
                        }
                    ]
                }
            ],
            "required": [
                {
                    "eClass": "org.kevoree.PortTypeRef",
                    "noDependency": "true",
                    "optional": "true",
                    "name": "sendText",
                    "ref": [
                        "typeDefinitions[org.kevoree.framework.MessagePort]"
                    ]
                }
            ]
        },
        {
            "eClass": "org.kevoree.MessagePortType",
            "abstract": "false",
            "synchrone": "false",
            "name": "org.kevoree.framework.MessagePort"
        },
        {
            "eClass": "org.kevoree.ChannelType",
            "upperFragments": "0",
            "abstract": "false",
            "upperBindings": "0",
            "lowerBindings": "0",
            "bean": "kevoree-chan-local",
            "lowerFragments": "0",
            "name": "LocalChannel",
            "factoryBean": "org.kevoree.library.javase.basicGossiper.channel.LocalChannelFactory",
            "deployUnits": [
                "deployUnits[2755465601376380901387]"
            ],
            "dictionaryType": [
                {
                    "eClass": "org.kevoree.DictionaryType",
                    "generated_KMF_ID": "16177067681376380901373",
                    "attributes": [],
                    "defaultValues": []
                }
            ]
        }
    ],
    "repositories": [],
    "libraries": [
        {
            "eClass": "org.kevoree.TypeLibrary",
            "name": "Javascript",
            "subTypes": [
                "typeDefinitions[JavascriptNode]",
                "typeDefinitions[WebSocketGroup]",
                "typeDefinitions[HelloWorld]"
            ]
        }
    ],
    "deployUnits": [
        {
            "eClass": "org.kevoree.DeployUnit",
            "groupName": "",
            "unitName": "kevoree-group-websocket",
            "generated_KMF_ID": "89918001378813344621",
            "hashcode": "201309101342309",
            "type": "npm",
            "version": "0.0.2",
            "targetNodeType": [
                "typeDefinitions[JavascriptNode]"
            ]
        },
        {
            "eClass": "org.kevoree.DeployUnit",
            "groupName": "",
            "unitName": "kevoree-node",
            "generated_KMF_ID": "142023381378461125966",
            "hashcode": "201309061152488",
            "type": "npm",
            "version": "0.0.6",
            "targetNodeType": [
                "typeDefinitions[JavascriptNode]"
            ]
        },
        {
            "eClass": "org.kevoree.DeployUnit",
            "groupName": "",
            "unitName": "kevoree-comp-helloworld",
            "generated_KMF_ID": "142023381378461125333",
            "hashcode": "201309061152442",
            "type": "npm",
            "version": "0.0.2",
            "targetNodeType": [
                "typeDefinitions[JavascriptNode]"
            ]
        },
        {
            "eClass": "org.kevoree.DeployUnit",
            "groupName": "",
            "unitName": "kevoree-chan-local",
            "generated_KMF_ID": "2755465601376380901387",
            "hashcode": "201308131001248",
            "type": "npm",
            "version": "0.0.1",
            "targetNodeType": [
                "typeDefinitions[JavascriptNode]"
            ]
        }
    ],
    "hubs": [
        {
            "eClass": "org.kevoree.Channel",
            "name": "chan0",
            "started": "true",
            "metaData": "x=363,y=418",
            "typeDefinition": [
                "typeDefinitions[LocalChannel]"
            ],
            "bindings": [
                "mBindings[0.72222582343965771379498684478]",
                "mBindings[0.95117838773876431379665330884]"
            ]
        }
    ],
    "mBindings": [
        {
            "eClass": "org.kevoree.MBinding",
            "generated_KMF_ID": "0.72222582343965771379498684478",
            "port": [
                "nodes[node0]/components[comp0]/provided[0.65337726869620381379498678145]"
            ],
            "hub": [
                "hubs[chan0]"
            ]
        },
        {
            "eClass": "org.kevoree.MBinding",
            "generated_KMF_ID": "0.95117838773876431379665330884",
            "port": [
                "nodes[node0]/components[comp0]/required[0.8331616653595121379665329022]"
            ],
            "hub": [
                "hubs[chan0]"
            ]
        }
    ],
    "groups": [
        {
            "eClass": "org.kevoree.Group",
            "name": "sync",
            "started": "true",
            "metaData": "x=138,y=109",
            "typeDefinition": [
                "typeDefinitions[WebSocketGroup]"
            ],
            "subNodes": [
                "nodes[node0]"
            ],
            "dictionary": [
                {
                    "eClass": "org.kevoree.Dictionary",
                    "generated_KMF_ID": "0.22895467001944781378909271335",
                    "values": [
                        {
                            "eClass": "org.kevoree.DictionaryValue",
                            "generated_KMF_ID": "0.58561423048377041378909273197",
                            "value": "false",
                            "attribute": [
                                "typeDefinitions[WebSocketGroup]/dictionaryType[267671911378812807634]/attributes[ssl]"
                            ]
                        },
                        {
                            "eClass": "org.kevoree.DictionaryValue",
                            "generated_KMF_ID": "0.33476619888097051378909273197",
                            "value": "8000",
                            "attribute": [
                                "typeDefinitions[WebSocketGroup]/dictionaryType[267671911378812807634]/attributes[port]"
                            ],
                            "targetNode": [
                                "nodes[node0]"
                            ]
                        },
                        {
                            "eClass": "org.kevoree.DictionaryValue",
                            "generated_KMF_ID": "0.26305797277018431378909273198",
                            "value": "0.0.0.0",
                            "attribute": [
                                "typeDefinitions[WebSocketGroup]/dictionaryType[267671911378812807634]/attributes[ip]"
                            ],
                            "targetNode": [
                                "nodes[node0]"
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}
},{}],5:[function(require,module,exports){
var Class           = require('pseudoclass'),
    kLib            = require('kevoree-library'),
    KevoreeLogger   = require('kevoree-utils').KevoreeLogger,
    async           = require('async'),
    EventEmitter    = require('events').EventEmitter;

/**
 * Kevoree Core
 *
 * @type {*}
 */
module.exports = Class({
    toString: 'KevoreeCore',

    /**
     * Core constructor
     */
    construct: function(modulesPath, logger) {
        this.log = (logger != undefined) ? logger : new KevoreeLogger(this.toString());

        this.factory = new kLib.org.kevoree.impl.DefaultKevoreeFactory();
        this.loader  = new kLib.org.kevoree.loader.JSONModelLoader();
        this.compare = new kLib.org.kevoree.compare.DefaultModelCompare();

        this.currentModel   = null;
        this.models         = [];
        this.nodeName       = null;
        this.nodeInstance   = null;
        this.modulesPath    = modulesPath;
        this.bootstrapper   = null;
        this.intervalId     = null;

        this.emitter = new EventEmitter();
    },

    /**
     * Destruct core instance
     */
    destruct: function() {
        this.log.debug('Destructing...');
    },

    /**
     * Starts Kevoree Core
     * @param nodeName
     */
    start: function (nodeName) {
        if (nodeName == undefined || nodeName.length == 0) nodeName = "node0";

        this.nodeName = nodeName;
        this.currentModel = this.factory.createContainerRoot();

        // starting loop function
        this.intervalId = setInterval(function () {}, 1e8);

        this.log.info("Platform started: '%s'", nodeName);

        this.emitter.emit('started');
    },

    setBootstrapper: function (bootstrapper) {
        this.bootstrapper = bootstrapper;
    },

    getBootstrapper: function () {
        return this.bootstrapper;
    },

    /**
     * Stops Kevoree Core
     */
    stop: function () {
        if (this.intervalId != undefined && this.intervalId != null) {
            if (this.nodeInstance != null) {
                this.nodeInstance.stop();
            }
            clearInterval(this.intervalId);
            this.intervalId = null;
            this.currentModel = null;
            this.log.debug('Stopped');
        }
    },

    /**
     * Save model to hdd
     */
    saveModel: function () {
        // TODO
    },

    /**
     * Compare current with model
     * Get traces and call command (that can be redefined)
     *
     * @param model
     */
    deploy: function (model) {
        if (model.findNodesByID(this.nodeName) == null) {
            this.emitter.emit('error', new Error('Deploy model failure: unable to find %s in given model', this.nodeName));
            return;

        } else {
            this.log.info('Deploy process started...');
            if (model != undefined && model != null) {
                // check if there is an instance currently running
                // if not, it will try to run it
                var core = this;
                this.checkBootstrapNode(model, function (err) {
                    if (err) {
                        core.emitter.emit('error', err);
                        return;
                    }

                    if (core.nodeInstance != undefined && core.nodeInstance != null) {
                        // given model is defined and not null
                        var diffSeq = core.compare.diff(core.currentModel, model);
                        var adaptations = core.nodeInstance.processTraces(diffSeq.traces, model);

                        // list of adaptation commands retrieved
                        var cmdStack = [];

                        // executeCommand: function that save cmd to stack and executes it
                        var executeCommand = function executeCommand(cmd, iteratorCallback) {
                            // save the cmd to be processed in a stack using unshift
                            // in order to add the last processed cmd at the beginning of the array
                            // => cmdStack[0] = more recently executed cmd
                            cmdStack.unshift(cmd);

                            // execute cmd
                            cmd.execute(function (err) {
                                if (err) {
                                    iteratorCallback(err);
                                    return;
                                }

                                // adaptation succeed
                                iteratorCallback();
                            });
                        };

                        // rollbackCommand: function that calls undo() on cmds in the stack
                        var rollbackCommand = function rollbackCommand(cmd, iteratorCallback) {
                            cmd.undo(function (err) {
                                if (err) {
                                    iteratorCallback(err);
                                    return;
                                }

                                // undo succeed
                                iteratorCallback();
                            });
                        };

                        // execute each command synchronously
                        async.eachSeries(adaptations, executeCommand, function (err) {
                            if (err) {
                                // something went wrong while processing adaptations
                                core.log.error(err.stack);

                                // rollback process
                                async.eachSeries(cmdStack, rollbackCommand, function (er) {
                                    if (er) {
                                        // something went wrong while rollbacking
                                        core.log.error(er.stack);
                                        core.emitter.emit('error', new Error("Something went wrong while rollbacking..."));
                                        return;
                                    }

                                    // rollback succeed
                                    core.emitter.emit('rollback');
                                    return;
                                });

                                core.emitter.emit('error', new Error("Something went wrong while processing adaptations. Rollback"));
                                return;
                            }

                            // adaptations succeed : woot
                            core.log.debug("Model deployed successfully.");
                            // save old model
                            pushInArray(core.models, core.currentModel);
                            // set new model to be the current one
                            core.currentModel = model;
                            // all good :)
                            core.emitter.emit('deployed', core.currentModel);
                            return;
                        });

                    } else {
                        core.emitter.emit('error', new Error("There is no instance to bootstrap on"));
                        return;
                    }
                });
            } else {
                this.emitter.emit('error', new Error("model is not defined or null. Deploy aborted."));
                return;
            }
        }
    },

    checkBootstrapNode: function (model, callback) {
        callback = callback || function () {};

        if (this.nodeInstance == undefined || this.nodeInstance == null) {
            this.log.info("Start '%s' bootstrapping...", this.nodeName);
            var core = this;
            this.bootstrapper.bootstrapNodeType(this.nodeName, model, function (err, AbstractNode) {
                if (err) {
                    core.log.error(err.stack);
                    callback.call(core, new Error("Unable to bootstrap '"+core.nodeName+"'! Start process aborted."));
                    return;
                }

                core.nodeInstance = new AbstractNode();
                core.nodeInstance.setKevoreeCore(core);
                core.nodeInstance.setName(core.nodeName);
                core.nodeInstance.start();

                core.log.info("'%s' instance started successfully", core.nodeName);

                callback.call(core, null);
                return
            });

        } else {
            callback.call(this, null);
            return;
        }
    },

    /**
     * Put core in readonly mode
     */
    lock: function() {
        // TODO
    },

    /**
     * Put core in read/write mode
     */
    unlock: function() {
        // TODO
    },

    getCurrentModel: function () {
        return this.currentModel;
    },

    getPreviousModel: function () {
        var model = null;
        if (this.models.length > 0) model = this.models[this.models.length-1];
        return model;
    },

    getPreviousModels: function () {
        return this.models;
    },

    getModulesPath: function () {
        return this.modulesPath;
    },

    on: function (event, callback) {
        this.emitter.addListener(event, callback);
    }
});

// utility function to ensure cached model list won't go over 10 items
var pushInArray = function pushInArray(array, model) {
    if (array.length == 10) this.shift();
    array.push(model);
}

// utility function to know if a model is currently already in the array
var containsModel = function containsModel(array, model) {
    return (array.indexOf(model) > -1);
}
},{"async":6,"events":18,"kevoree-library":7,"kevoree-utils":8,"pseudoclass":10}],6:[function(require,module,exports){
var process=require("__browserify_process");/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = setImmediate;
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

},{"__browserify_process":49}],7:[function(require,module,exports){
// Be aware — Google Chrome has serious issue — you can rewrite READ-ONLY property (if it is defined in prototype). Firefox and Safari work correct.
// Always test property access issues in Firefox, but not in Chrome.
var Kotlin = Object.create(null);

(function () {
    

    Kotlin.keys = Object.keys;

    Kotlin.isType = function (object, type) {
        if (object === null || object === undefined) {
            return false;
        }

        var proto = Object.getPrototypeOf(object);
        // todo test nested class
        //noinspection RedundantIfStatementJS
        if (proto == type.proto) {
            return true;
        }

        return false;
    };

    // as separated function to reduce scope
    function createConstructor() {
        return function $fun() {
            var o = Object.create($fun.proto);
            var initializer = $fun.initializer;
            if (initializer != null) {
                if (initializer.length == 0) {
                    initializer.call(o);
                }
                else {
                    initializer.apply(o, arguments);
                }
            }

            Object.seal(o);
            return o;
        };
    }

    function computeProto(bases, properties) {
        var proto = null;
        for (var i = 0, n = bases.length; i < n; i++) {
            var base = bases[i];
            var baseProto = base.proto;
            if (baseProto === null || base.properties === null) {
                continue;
            }

            if (proto === null) {
                proto = Object.create(baseProto, properties || undefined);
                continue;
            }
            Object.defineProperties(proto, base.properties);
            // todo test A -> B, C(->D) *properties from D is not yet added to proto*
        }

        return proto;
    }

    Kotlin.createTrait = function (bases, properties, staticProperties) {
        return createClass(bases, null, properties, staticProperties, false);
    };

    Kotlin.createClass = function (bases, initializer, properties, staticProperties) {
        // proto must be created for class even if it is not needed (requires for is operator)
        return createClass(bases, initializer === null ? function () {} : initializer, properties, staticProperties, true);
    };

    function computeProto2(bases, properties) {
        if (bases === null) {
            return Object.prototype;
        }
        return Array.isArray(bases) ? computeProto(bases, properties) : bases.proto;
    }

    Kotlin.createObject = function (bases, initializer, properties) {
        var o = Object.create(computeProto2(bases, properties), properties || undefined);
        if (initializer !== null) {
            if (bases !== null) {
                Object.defineProperty(initializer, "baseInitializer", {value: Array.isArray(bases) ? bases[0].initializer : bases.initializer});
            }
            initializer.call(o);
        }
        Object.seal(o);
        return o;
    };

    function class_object$() {
        if (typeof this.$object$ === "undefined") {
            this.$object$ = this.object_initializer$();
        }

        return this.$object$;
    }

    function createClass(bases, initializer, properties, staticProperties, isClass) {
        var proto;
        var baseInitializer;
        if (bases === null) {
            baseInitializer = null;
            proto = !isClass && properties === null ? null : Object.create(null, properties || undefined);
        }
        else if (!Array.isArray(bases)) {
            baseInitializer = bases.initializer;
            proto = !isClass && properties === null ? bases.proto : Object.create(bases.proto, properties || undefined);
        }
        else {
            // first is superclass, other are traits
            baseInitializer = bases[0].initializer;
            proto = computeProto(bases, properties);
            // all bases are traits without properties
            if (proto === null && isClass) {
                proto = Object.create(null, properties || undefined);
            }
        }

        var constructor = createConstructor();
        Object.defineProperty(constructor, "object$", {value: class_object$});
        Object.defineProperty(constructor, "$object$", {value: undefined, writable: true});

        Object.defineProperty(constructor, "proto", {value: proto});
        Object.defineProperty(constructor, "properties", {value: properties || null});
        if (isClass) {
            Object.defineProperty(constructor, "initializer", {value: initializer});

            Object.defineProperty(initializer, "baseInitializer", {value: baseInitializer});
            Object.freeze(initializer);
        }

        if (staticProperties !== null && staticProperties !== undefined) {
            Object.defineProperties(constructor, staticProperties);
        }

        Object.seal(constructor);
        return constructor;
    }

    Kotlin.definePackage = function (initializer, members) {
        var definition = Object.create(null, members === null ? undefined : members);
        if (initializer === null) {
            return {value: definition};
        }
        else {
            var getter = createPackageGetter(definition, initializer);
            Object.freeze(getter);
            return {get: getter};
        }
    };

    function createPackageGetter(instance, initializer) {
        return function () {
            if (initializer !== null) {
                var tmp = initializer;
                initializer = null;
                tmp.call(instance);
                Object.seal(instance);
            }

            return instance;
        };
    }

    Kotlin.$new = function (f) {
        return f;
    };

    Kotlin.$createClass = function (parent, properties) {
        if (parent !== null && typeof (parent) != "function") {
            properties = parent;
            parent = null;
        }

        var initializer = null;
        var descriptors = properties ? {} : null;
        if (descriptors != null) {
            var ownPropertyNames = Object.getOwnPropertyNames(properties);
            for (var i = 0, n = ownPropertyNames.length; i < n; i++) {
                var name = ownPropertyNames[i];
                var value = properties[name];
                if (name == "initialize") {
                    initializer = value;
                }
                else if (name.indexOf("get_") === 0) {
                    descriptors[name.substring(4)] = {get: value};
                    // std lib code can refers to
                    descriptors[name] = {value: value};
                }
                else if (name.indexOf("set_") === 0) {
                    descriptors[name.substring(4)] = {set: value};
                    // std lib code can refers to
                    descriptors[name] = {value: value};
                }
                else {
                    // we assume all our std lib functions are open
                    descriptors[name] = {value: value, writable: true};
                }
            }
        }

        return Kotlin.createClass(parent || null, initializer, descriptors);
    };

    Kotlin.defineModule = function (id, module) {
        if (id in Kotlin.modules) {
            throw Kotlin.$new(Kotlin.IllegalArgumentException)();
        }

        Object.freeze(module);
        Object.defineProperty(Kotlin.modules, id, {value: module});
    };
})();
/**
 * Copyright 2010 Tim Down.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



// todo inlined
String.prototype.startsWith = function (s) {
  return this.indexOf(s) === 0;
};

String.prototype.endsWith = function (s) {
  return this.indexOf(s, this.length - s.length) !== -1;
};

String.prototype.contains = function (s) {
  return this.indexOf(s) !== -1;
};

(function () {
    Kotlin.equals = function (obj1, obj2) {
        if (obj1 == null) {
            return obj2 == null;
        }

        if (Array.isArray(obj1)) {
            return Kotlin.arrayEquals(obj1, obj2);
        }

        if (typeof obj1 == "object" && obj1.equals !== undefined) {
            return obj1.equals(obj2);
        }

        return obj1 === obj2;
    };

    Kotlin.toString = function (o) {
        if (o == null) {
            return "null";
        }
        else if (Array.isArray(o)) {
            return Kotlin.arrayToString(o);
        }
        else {
            return o.toString();
        }
    };
    
    Kotlin.arrayToString = function(a) {
        return "[" + a.join(", ") + "]";
    };

    Kotlin.intUpto = function (from, to) {
        return Kotlin.$new(Kotlin.NumberRange)(from, to);
    };

    Kotlin.intDownto = function (from, to) {
        return Kotlin.$new(Kotlin.Progression)(from, to, -1);
    };

    Kotlin.modules = {};

    Kotlin.RuntimeException = Kotlin.$createClass();
    Kotlin.NullPointerException = Kotlin.$createClass();
    Kotlin.NoSuchElementException = Kotlin.$createClass();
    Kotlin.IllegalArgumentException = Kotlin.$createClass();
    Kotlin.IllegalStateException = Kotlin.$createClass();
    Kotlin.UnsupportedOperationException = Kotlin.$createClass();
    Kotlin.IOException = Kotlin.$createClass();

    Kotlin.throwNPE = function () {
        throw Kotlin.$new(Kotlin.NullPointerException)();
    };

    function throwAbstractFunctionInvocationError(funName) {
        return function() {
            var message;
            if (funName !== undefined) {
                message = "Function " + funName + " is abstract";
            } else {
                message = "Function is abstract";
            }
            throw new TypeError(message);
        };
    }

    Kotlin.Iterator = Kotlin.$createClass({
        initialize: function () {
        },
        next: throwAbstractFunctionInvocationError("Iterator#next"),
        hasNext: throwAbstractFunctionInvocationError("Iterator#hasNext")
    });

    var ArrayIterator = Kotlin.$createClass(Kotlin.Iterator, {
        initialize: function (array) {
            this.array = array;
            this.size = array.length;
            this.index = 0;
        },
        next: function () {
            return this.array[this.index++];
        },
        hasNext: function () {
            return this.index < this.size;
        }
    });

    var ListIterator = Kotlin.$createClass(ArrayIterator, {
        initialize: function (list) {
            this.list = list;
            this.size = list.size();
            this.index = 0;
        },
        next: function () {
            return this.list.get(this.index++);
        }
    });

    Kotlin.Collection = Kotlin.$createClass();

    Kotlin.Enum = Kotlin.$createClass(null, {
        initialize: function () {
            this.name$ = undefined;
            this.ordinal$ = undefined;
        },
        name: function () {
            return this.name$;
        },
        ordinal: function () {
            return this.ordinal$;
        },
        toString: function () {
            return this.name();
        }
    });
    (function (){
        function valueOf(name) {
            return this[name];
        }
        function getValues() {
            return this.values$;
        }

        Kotlin.createEnumEntries = function(enumEntryList) {
            var i = 0;
            var values = [];
            for (var entryName in enumEntryList) {
                if (enumEntryList.hasOwnProperty(entryName)) {
                    var entryObject = enumEntryList[entryName];
                    values[i] = entryObject;
                    entryObject.ordinal$ = i;
                    entryObject.name$ = entryName;
                    i++;
                }
            }
            enumEntryList.values$ = values;
            enumEntryList.valueOf = valueOf;
            enumEntryList.values = getValues;
            return enumEntryList;
        };
    })();

    Kotlin.PropertyMetadata = Kotlin.$createClass(null, {
        initialize: function(name) {
            this.$name = name;
        },
        get_name: function () {
            return this.$name;
        }
    });

    Kotlin.AbstractCollection = Kotlin.$createClass(Kotlin.Collection, {
        size: function () {
            return this.$size;
        },
        addAll: function (collection) {
            var it = collection.iterator();
            var i = this.size();
            while (i-- > 0) {
                this.add(it.next());
            }
        },
        isEmpty: function () {
            return this.size() === 0;
        },
        iterator: function () {
            return Kotlin.$new(ArrayIterator)(this.toArray());
        },
        equals: function (o) {
            if (this.size() !== o.size()) return false;

            var iterator1 = this.iterator();
            var iterator2 = o.iterator();
            var i = this.size();
            while (i-- > 0) {
                if (!Kotlin.equals(iterator1.next(), iterator2.next())) {
                    return false;
                }
            }

            return true;
        },
        toString: function () {
            var builder = "[";
            var iterator = this.iterator();
            var first = true;
            var i = this.$size;
            while (i-- > 0) {
                if (first) {
                    first = false;
                }
                else {
                    builder += ", ";
                }
                builder += iterator.next();
            }
            builder += "]";
            return builder;
        },
        toJSON: function () {
            return this.toArray();
        }
    });

    Kotlin.AbstractList = Kotlin.$createClass(Kotlin.AbstractCollection, {
        iterator: function () {
            return Kotlin.$new(ListIterator)(this);
        },
        remove: function (o) {
            var index = this.indexOf(o);
            if (index !== -1) {
                this.removeAt(index);
            }
        },
        contains: function (o) {
            return this.indexOf(o) !== -1;
        }
    });

    //TODO: should be JS Array-like (https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Predefined_Core_Objects#Working_with_Array-like_objects)
    Kotlin.ArrayList = Kotlin.$createClass(Kotlin.AbstractList, {
        initialize: function () {
            this.array = [];
            this.$size = 0;
        },
        get: function (index) {
            this.checkRange(index);
            return this.array[index];
        },
        set: function (index, value) {
            this.checkRange(index);
            this.array[index] = value;
        },
        size: function () {
            return this.$size;
        },
        iterator: function () {
            return Kotlin.arrayIterator(this.array);
        },
        add: function (element) {
            this.array[this.$size++] = element;
        },
        addAt: function (index, element) {
            this.array.splice(index, 0, element);
            this.$size++;
        },
        addAll: function (collection) {
            var it = collection.iterator();
            for (var i = this.$size, n = collection.size(); n-- > 0;) {
                this.array[i++] = it.next();
            }

            this.$size += collection.size();
        },
        removeAt: function (index) {
            this.checkRange(index);
            this.$size--;
            return this.array.splice(index, 1)[0];
        },
        clear: function () {
            this.array.length = 0;
            this.$size = 0;
        },
        indexOf: function (o) {
            for (var i = 0, n = this.$size; i < n; ++i) {
                if (Kotlin.equals(this.array[i], o)) {
                    return i;
                }
            }
            return -1;
        },
        toArray: function () {
            return this.array.slice(0, this.$size);
        },
        toString: function () {
            return "[" + this.array.join(", ") + "]";
        },
        toJSON: function () {
            return this.array;
        },
        checkRange: function(index) {
            if (index < 0 || index >= this.$size) {
                throw new RangeError();
            }
        }
    });

    Kotlin.Runnable = Kotlin.$createClass({
        initialize: function () {
        },
        run: throwAbstractFunctionInvocationError("Runnable#run")
    });

    Kotlin.Comparable = Kotlin.$createClass({
        initialize: function () {
        },
        compareTo: throwAbstractFunctionInvocationError("Comparable#compareTo")
    });

    Kotlin.Appendable = Kotlin.$createClass({
        initialize: function () {
        },
        append: throwAbstractFunctionInvocationError("Appendable#append")
    });

    Kotlin.Closeable = Kotlin.$createClass({
        initialize: function () {
        },
        close: throwAbstractFunctionInvocationError("Closeable#close")
    });

    Kotlin.safeParseInt = function(str) {
        var r = parseInt(str, 10);
        return isNaN(r) ? null : r;
    };

    Kotlin.safeParseDouble = function(str) {
        var r = parseFloat(str);
        return isNaN(r) ? null : r;
    };

    Kotlin.arrayEquals = function (a, b) {
        if (a === b) {
            return true;
        }
        if (!Array.isArray(b) || a.length !== b.length) {
            return false;
        }

        for (var i = 0, n = a.length; i < n; i++) {
            if (!Kotlin.equals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    };

    Kotlin.System = function () {
        var output = "";

        var print = function (obj) {
            if (obj !== undefined) {
                if (obj === null || typeof obj !== "object") {
                    output += obj;
                }
                else {
                    output += obj.toString();
                }
            }
        };
        var println = function (obj) {
            this.print(obj);
            output += "\n";
        };

        return {
            out: function () {
                return {
                    print: print,
                    println: println
                };
            },
            output: function () {
                return output;
            },
            flush: function () {
                output = "";
            }
        };
    }();

    Kotlin.println = function (s) {
        Kotlin.System.out().println(s);
    };

    Kotlin.print = function (s) {
        Kotlin.System.out().print(s);
    };

    Kotlin.RangeIterator = Kotlin.$createClass(Kotlin.Iterator, {
        initialize: function (start, end, increment) {
            this.$start = start;
            this.$end = end;
            this.$increment = increment;
            this.$i = start;
        },
        get_start: function () {
            return this.$start;
        },
        get_end: function () {
            return this.$end;
        },
        get_i: function () {
            return this.$i;
        },
        set_i: function (tmp$0) {
            this.$i = tmp$0;
        },
        next: function () {
            var value = this.$i;
            this.set_i(this.$i + this.$increment);
            return value;
        },
        hasNext: function () {
            return this.get_count() > 0;
        }
    });

    Kotlin.NumberRange = Kotlin.$createClass({
        initialize: function (start, end) {
            this.$start = start;
            this.$end = end;
        },
        get_start: function () {
            return this.$start;
        },
        get_end: function () {
            return this.$end;
        },
        get_increment: function () {
            return 1;
        },
        contains: function (number) {
            return this.$start <= number && number <= this.$end;
        },
        iterator: function () {
            return Kotlin.$new(Kotlin.RangeIterator)(this.get_start(), this.get_end());
        }
    });

    Kotlin.Progression = Kotlin.$createClass({
        initialize: function (start, end, increment) {
            this.$start = start;
            this.$end = end;
            this.$increment = increment;
        },
        get_start: function () {
            return this.$start;
        },
        get_end: function () {
            return this.$end;
        },
        get_increment: function () {
            return this.$increment;
        },
        iterator: function () {
            return Kotlin.$new(Kotlin.RangeIterator)(this.get_start(), this.get_end(), this.get_increment());
        }
    });

    Kotlin.Comparator = Kotlin.$createClass({
        initialize: function () {
        },
        compare: throwAbstractFunctionInvocationError("Comparator#compare")
    });

    var ComparatorImpl = Kotlin.$createClass(Kotlin.Comparator, {
        initialize: function (comparator) {
            this.compare = comparator;
        }
    });

    Kotlin.comparator = function (f) {
        return Kotlin.$new(ComparatorImpl)(f);
    };

    Kotlin.collectionsMax = function (c, comp) {
        if (c.isEmpty()) {
            //TODO: which exception?
            throw new Error();
        }
        var it = c.iterator();
        var max = it.next();
        while (it.hasNext()) {
            var el = it.next();
            if (comp.compare(max, el) < 0) {
                max = el;
            }
        }
        return max;
    };

    Kotlin.collectionsSort = function (mutableList, comparator) {
        var boundComparator = undefined;
        if (comparator !== undefined) {
            boundComparator = comparator.compare.bind(comparator);
        }

        if (mutableList instanceof Array) {
            mutableList.sort(boundComparator);
        }

        //TODO: should be deleted when List will be JS Array-like (https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Predefined_Core_Objects#Working_with_Array-like_objects)
        var array = [];
        var it = mutableList.iterator();
        while (it.hasNext()) {
            array.push(it.next());
        }

        array.sort(boundComparator);

        for (var i = 0, n = array.length; i < n; i++) {
            mutableList.set(i, array[i]);
        }
    };


    Kotlin.StringBuilder = Kotlin.$createClass(
            {
                initialize:function () {
                    this.string = "";
                },
                append:function (obj) {
                    this.string = this.string + obj.toString();
                },
                toString:function () {
                    return this.string;
                }
            }
    );

    Kotlin.splitString = function (str, regex, limit) {
        return str.split(new RegExp(regex), limit);
    };

    Kotlin.nullArray = function (size) {
        var res = [];
        var i = size;
        while (i > 0) {
            res[--i] = null;
        }
        return res;
    };

    Kotlin.numberArrayOfSize = function (size) {
        return Kotlin.arrayFromFun(size, function(){ return 0; });
    };

    Kotlin.charArrayOfSize = function (size) {
        return Kotlin.arrayFromFun(size, function(){ return '\0'; });
    };

    Kotlin.booleanArrayOfSize = function (size) {
        return Kotlin.arrayFromFun(size, function(){ return false; });
    };

    Kotlin.arrayFromFun = function (size, initFun) {
        var result = new Array(size);
        for (var i = 0; i < size; i++) {
            result[i] = initFun(i);
        }
        return result;
    };

    Kotlin.arrayIndices = function (arr) {
        return Kotlin.$new(Kotlin.NumberRange)(0, arr.length - 1);
    };

    Kotlin.arrayIterator = function (array) {
        return Kotlin.$new(ArrayIterator)(array);
    };

    Kotlin.jsonFromTuples = function (pairArr) {
        var i = pairArr.length;
        var res = {};
        while (i > 0) {
            --i;
            res[pairArr[i][0]] = pairArr[i][1];
        }
        return res;
    };

    Kotlin.jsonAddProperties = function (obj1, obj2) {
        for (var p in obj2) {
            if (obj2.hasOwnProperty(p)) {
                obj1[p] = obj2[p];
            }
        }
        return obj1;
    };
})();

Kotlin.assignOwner = function(f, o) {
  f.o = o;
  return f;
};
/*
 * Copyright 2010-2013 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


(function () {
    var FUNCTION = "function";
    var arrayRemoveAt = (typeof Array.prototype.splice == FUNCTION) ?
                        function (arr, idx) {
                            arr.splice(idx, 1);
                        } :

                        function (arr, idx) {
                            var itemsAfterDeleted, i, len;
                            if (idx === arr.length - 1) {
                                arr.length = idx;
                            }
                            else {
                                itemsAfterDeleted = arr.slice(idx + 1);
                                arr.length = idx;
                                for (i = 0, len = itemsAfterDeleted.length; i < len; ++i) {
                                    arr[idx + i] = itemsAfterDeleted[i];
                                }
                            }
                        };

    function hashObject(obj) {
        var hashCode;
        if (typeof obj == "string") {
            return obj;
        }
        else if (typeof obj.hashCode == FUNCTION) {
            // Check the hashCode method really has returned a string
            hashCode = obj.hashCode();
            return (typeof hashCode == "string") ? hashCode : hashObject(hashCode);
        }
        else if (typeof obj.toString == FUNCTION) {
            return obj.toString();
        }
        else {
            try {
                return String(obj);
            }
            catch (ex) {
                // For host objects (such as ActiveObjects in IE) that have no toString() method and throw an error when
                // passed to String()
                return Object.prototype.toString.call(obj);
            }
        }
    }

    function equals_fixedValueHasEquals(fixedValue, variableValue) {
        return fixedValue.equals(variableValue);
    }

    function equals_fixedValueNoEquals(fixedValue, variableValue) {
        return (typeof variableValue.equals == FUNCTION) ?
               variableValue.equals(fixedValue) : (fixedValue === variableValue);
    }

    function createKeyValCheck(kvStr) {
        return function (kv) {
            if (kv === null) {
                throw new Error("null is not a valid " + kvStr);
            }
            else if (typeof kv == "undefined") {
                throw new Error(kvStr + " must not be undefined");
            }
        };
    }

    var checkKey = createKeyValCheck("key"), checkValue = createKeyValCheck("value");

    function Bucket(hash, firstKey, firstValue, equalityFunction) {
        this[0] = hash;
        this.entries = [];
        this.addEntry(firstKey, firstValue);

        if (equalityFunction !== null) {
            this.getEqualityFunction = function () {
                return equalityFunction;
            };
        }
    }

    var EXISTENCE = 0, ENTRY = 1, ENTRY_INDEX_AND_VALUE = 2;

    function createBucketSearcher(mode) {
        return function (key) {
            var i = this.entries.length, entry, equals = this.getEqualityFunction(key);
            while (i--) {
                entry = this.entries[i];
                if (equals(key, entry[0])) {
                    switch (mode) {
                        case EXISTENCE:
                            return true;
                        case ENTRY:
                            return entry;
                        case ENTRY_INDEX_AND_VALUE:
                            return [ i, entry[1] ];
                    }
                }
            }
            return false;
        };
    }

    function createBucketLister(entryProperty) {
        return function (aggregatedArr) {
            var startIndex = aggregatedArr.length;
            for (var i = 0, len = this.entries.length; i < len; ++i) {
                aggregatedArr[startIndex + i] = this.entries[i][entryProperty];
            }
        };
    }

    Bucket.prototype = {
        getEqualityFunction: function (searchValue) {
            return (typeof searchValue.equals == FUNCTION) ? equals_fixedValueHasEquals : equals_fixedValueNoEquals;
        },

        getEntryForKey: createBucketSearcher(ENTRY),

        getEntryAndIndexForKey: createBucketSearcher(ENTRY_INDEX_AND_VALUE),

        removeEntryForKey: function (key) {
            var result = this.getEntryAndIndexForKey(key);
            if (result) {
                arrayRemoveAt(this.entries, result[0]);
                return result[1];
            }
            return null;
        },

        addEntry: function (key, value) {
            this.entries[this.entries.length] = [key, value];
        },

        keys: createBucketLister(0),

        values: createBucketLister(1),

        getEntries: function (entries) {
            var startIndex = entries.length;
            for (var i = 0, len = this.entries.length; i < len; ++i) {
                // Clone the entry stored in the bucket before adding to array
                entries[startIndex + i] = this.entries[i].slice(0);
            }
        },

        containsKey: createBucketSearcher(EXISTENCE),

        containsValue: function (value) {
            var i = this.entries.length;
            while (i--) {
                if (value === this.entries[i][1]) {
                    return true;
                }
            }
            return false;
        }
    };

    /*----------------------------------------------------------------------------------------------------------------*/

    // Supporting functions for searching hashtable buckets

    function searchBuckets(buckets, hash) {
        var i = buckets.length, bucket;
        while (i--) {
            bucket = buckets[i];
            if (hash === bucket[0]) {
                return i;
            }
        }
        return null;
    }

    function getBucketForHash(bucketsByHash, hash) {
        var bucket = bucketsByHash[hash];

        // Check that this is a genuine bucket and not something inherited from the bucketsByHash's prototype
        return ( bucket && (bucket instanceof Bucket) ) ? bucket : null;
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    var Hashtable = function (hashingFunctionParam, equalityFunctionParam) {
        var that = this;
        var buckets = [];
        var bucketsByHash = {};

        var hashingFunction = (typeof hashingFunctionParam == FUNCTION) ? hashingFunctionParam : hashObject;
        var equalityFunction = (typeof equalityFunctionParam == FUNCTION) ? equalityFunctionParam : null;

        this.put = function (key, value) {
            checkKey(key);
            checkValue(value);
            var hash = hashingFunction(key), bucket, bucketEntry, oldValue = null;

            // Check if a bucket exists for the bucket key
            bucket = getBucketForHash(bucketsByHash, hash);
            if (bucket) {
                // Check this bucket to see if it already contains this key
                bucketEntry = bucket.getEntryForKey(key);
                if (bucketEntry) {
                    // This bucket entry is the current mapping of key to value, so replace old value and we're done.
                    oldValue = bucketEntry[1];
                    bucketEntry[1] = value;
                }
                else {
                    // The bucket does not contain an entry for this key, so add one
                    bucket.addEntry(key, value);
                }
            }
            else {
                // No bucket exists for the key, so create one and put our key/value mapping in
                bucket = new Bucket(hash, key, value, equalityFunction);
                buckets[buckets.length] = bucket;
                bucketsByHash[hash] = bucket;
            }
            return oldValue;
        };

        this.get = function (key) {
            checkKey(key);

            var hash = hashingFunction(key);

            // Check if a bucket exists for the bucket key
            var bucket = getBucketForHash(bucketsByHash, hash);
            if (bucket) {
                // Check this bucket to see if it contains this key
                var bucketEntry = bucket.getEntryForKey(key);
                if (bucketEntry) {
                    // This bucket entry is the current mapping of key to value, so return the value.
                    return bucketEntry[1];
                }
            }
            return null;
        };

        this.containsKey = function (key) {
            checkKey(key);
            var bucketKey = hashingFunction(key);

            // Check if a bucket exists for the bucket key
            var bucket = getBucketForHash(bucketsByHash, bucketKey);

            return bucket ? bucket.containsKey(key) : false;
        };

        this.containsValue = function (value) {
            checkValue(value);
            var i = buckets.length;
            while (i--) {
                if (buckets[i].containsValue(value)) {
                    return true;
                }
            }
            return false;
        };

        this.clear = function () {
            buckets.length = 0;
            bucketsByHash = {};
        };

        this.isEmpty = function () {
            return !buckets.length;
        };

        var createBucketAggregator = function (bucketFuncName) {
            return function () {
                var aggregated = [], i = buckets.length;
                while (i--) {
                    buckets[i][bucketFuncName](aggregated);
                }
                return aggregated;
            };
        };

        this._keys = createBucketAggregator("keys");
        this._values = createBucketAggregator("values");
        this._entries = createBucketAggregator("getEntries");

        this.values = function () {
            var values = this._values();
            var i = values.length;
            var result = Kotlin.$new(Kotlin.ArrayList)();
            while (i--) {
                result.add(values[i]);
            }
            return result;
        };

        this.remove = function (key) {
            checkKey(key);

            var hash = hashingFunction(key), bucketIndex, oldValue = null;

            // Check if a bucket exists for the bucket key
            var bucket = getBucketForHash(bucketsByHash, hash);

            if (bucket) {
                // Remove entry from this bucket for this key
                oldValue = bucket.removeEntryForKey(key);
                if (oldValue !== null) {
                    // Entry was removed, so check if bucket is empty
                    if (!bucket.entries.length) {
                        // Bucket is empty, so remove it from the bucket collections
                        bucketIndex = searchBuckets(buckets, hash);
                        arrayRemoveAt(buckets, bucketIndex);
                        delete bucketsByHash[hash];
                    }
                }
            }
            return oldValue;
        };

        this.size = function () {
            var total = 0, i = buckets.length;
            while (i--) {
                total += buckets[i].entries.length;
            }
            return total;
        };

        this.each = function (callback) {
            var entries = that._entries(), i = entries.length, entry;
            while (i--) {
                entry = entries[i];
                callback(entry[0], entry[1]);
            }
        };


        this.putAll = function (hashtable, conflictCallback) {
            var entries = hashtable._entries();
            var entry, key, value, thisValue, i = entries.length;
            var hasConflictCallback = (typeof conflictCallback == FUNCTION);
            while (i--) {
                entry = entries[i];
                key = entry[0];
                value = entry[1];

                // Check for a conflict. The default behaviour is to overwrite the value for an existing key
                if (hasConflictCallback && (thisValue = that.get(key))) {
                    value = conflictCallback(key, thisValue, value);
                }
                that.put(key, value);
            }
        };

        this.clone = function () {
            var clone = new Hashtable(hashingFunctionParam, equalityFunctionParam);
            clone.putAll(that);
            return clone;
        };

        this.keySet = function () {
            var res = Kotlin.$new(Kotlin.ComplexHashSet)();
            var keys = this._keys();
            var i = keys.length;
            while (i--) {
                res.add(keys[i]);
            }
            return res;
        };
    };


    Kotlin.HashTable = Hashtable;
})();

Kotlin.Map = Kotlin.$createClass();

Kotlin.HashMap = Kotlin.$createClass(Kotlin.Map, {initialize: function () {
    Kotlin.HashTable.call(this);
}});

Kotlin.ComplexHashMap = Kotlin.HashMap;

(function () {
    var PrimitiveHashMapValuesIterator = Kotlin.$createClass(Kotlin.Iterator, {
        initialize: function (map, keys) {
            this.map = map;
            this.keys = keys;
            this.size = keys.length;
            this.index = 0;
        },
        next: function () {
            return this.map[this.keys[this.index++]];
        },
        hasNext: function () {
            return this.index < this.size;
        }
    });

    var PrimitiveHashMapValues = Kotlin.$createClass(Kotlin.Collection, {
        initialize: function (map) {
            this.map = map;
        },
        iterator: function () {
            return Kotlin.$new(PrimitiveHashMapValuesIterator)(this.map.map, Kotlin.keys(this.map.map));
        },
        isEmpty: function () {
            return this.map.$size === 0;
        },
        contains: function (o) {
            return this.map.containsValue(o);
        }
    });

    Kotlin.PrimitiveHashMap = Kotlin.$createClass(Kotlin.Map, {
        initialize: function () {
            this.$size = 0;
            this.map = {};
        },
        size: function () {
            return this.$size;
        },
        isEmpty: function () {
            return this.$size === 0;
        },
        containsKey: function (key) {
            return this.map[key] !== undefined;
        },
        containsValue: function (value) {
            var map = this.map;
            for (var key in map) {
                if (map.hasOwnProperty(key) && map[key] === value) {
                    return true;
                }
            }

            return false;
        },
        get: function (key) {
            return this.map[key];
        },
        put: function (key, value) {
            var prevValue = this.map[key];
            this.map[key] = value === undefined ? null : value;
            if (prevValue === undefined) {
                this.$size++;
            }
            return prevValue;
        },
        remove: function (key) {
            var prevValue = this.map[key];
            if (prevValue !== undefined) {
                delete this.map[key];
                this.$size--;
            }
            return prevValue;
        },
        clear: function () {
            this.$size = 0;
            this.map = {};
        },
        putAll: function (fromMap) {
            var map = fromMap.map;
            for (var key in map) {
                if (map.hasOwnProperty(key)) {
                    this.map[key] = map[key];
                    this.$size++;
                }
            }
        },
        keySet: function () {
            var result = Kotlin.$new(Kotlin.PrimitiveHashSet)();
            var map = this.map;
            for (var key in map) {
                if (map.hasOwnProperty(key)) {
                    result.add(key);
                }
            }

            return result;
        },
        values: function () {
            return Kotlin.$new(PrimitiveHashMapValues)(this);
        },
        toJSON: function () {
            return this.map;
        }
    });
}());

Kotlin.Set = Kotlin.$createClass(Kotlin.Collection);

Kotlin.PrimitiveHashSet = Kotlin.$createClass(Kotlin.AbstractCollection, {
    initialize: function () {
        this.$size = 0;
        this.map = {};
    },
    contains: function (key) {
        return this.map[key] === true;
    },
    add: function (element) {
        var prevElement = this.map[element];
        this.map[element] = true;
        if (prevElement === true) {
            return false;
        }
        else {
            this.$size++;
            return true;
        }
    },
    remove: function (element) {
        if (this.map[element] === true) {
            delete this.map[element];
            this.$size--;
            return true;
        }
        else {
            return false;
        }
    },
    clear: function () {
        this.$size = 0;
        this.map = {};
    },
    toArray: function () {
        return Kotlin.keys(this.map);
    }
});

(function () {
    function HashSet(hashingFunction, equalityFunction) {
        var hashTable = new Kotlin.HashTable(hashingFunction, equalityFunction);

        this.add = function (o) {
            hashTable.put(o, true);
        };

        this.addAll = function (arr) {
            var i = arr.length;
            while (i--) {
                hashTable.put(arr[i], true);
            }
        };

        this.values = function () {
            return hashTable._keys();
        };

        this.iterator = function () {
            return Kotlin.arrayIterator(this.values());
        };

        this.remove = function (o) {
            return hashTable.remove(o) ? o : null;
        };

        this.contains = function (o) {
            return hashTable.containsKey(o);
        };

        this.clear = function () {
            hashTable.clear();
        };

        this.size = function () {
            return hashTable.size();
        };

        this.isEmpty = function () {
            return hashTable.isEmpty();
        };

        this.clone = function () {
            var h = new HashSet(hashingFunction, equalityFunction);
            h.addAll(hashTable.keys());
            return h;
        };

        this.equals = function (o) {
            if (o === null || o === undefined) return false;
            if (this.size() === o.size()) {
                var iter1 = this.iterator();
                var iter2 = o.iterator();
                while (true) {
                    var hn1 = iter1.hasNext();
                    var hn2 = iter2.hasNext();
                    if (hn1 != hn2) return false;
                    if (!hn2)
                        return true;
                    else {
                        var o1 = iter1.next();
                        var o2 = iter2.next();
                        if (!Kotlin.equals(o1, o2)) return false;
                    }
                }
            }
            return false;
        };

        this.toString = function() {
            var builder = "[";
            var iter = this.iterator();
            var first = true;
            while (iter.hasNext()) {
                if (first)
                    first = false;
                else
                    builder += ", ";
                builder += iter.next();
            }
            builder += "]";
            return builder;
        };

        this.intersection = function (hashSet) {
            var intersection = new HashSet(hashingFunction, equalityFunction);
            var values = hashSet.values(), i = values.length, val;
            while (i--) {
                val = values[i];
                if (hashTable.containsKey(val)) {
                    intersection.add(val);
                }
            }
            return intersection;
        };

        this.union = function (hashSet) {
            var union = this.clone();
            var values = hashSet.values(), i = values.length, val;
            while (i--) {
                val = values[i];
                if (!hashTable.containsKey(val)) {
                    union.add(val);
                }
            }
            return union;
        };

        this.isSubsetOf = function (hashSet) {
            var values = hashTable.keys(), i = values.length;
            while (i--) {
                if (!hashSet.contains(values[i])) {
                    return false;
                }
            }
            return true;
        };
    }

    Kotlin.HashSet = Kotlin.$createClass(Kotlin.Set, {initialize: function () {
        HashSet.call(this);
    }});

    Kotlin.ComplexHashSet = Kotlin.HashSet;
}());
(function () {
  
  var classes = function () {
    var ci = Kotlin.createTrait(null)
    , c0 = Kotlin.createTrait(ci)
    , cl = Kotlin.createTrait(ci)
    , c13 = Kotlin.createTrait([ci, cl])
    , c1 = Kotlin.createTrait([ci, cl, c13])
    , c15 = Kotlin.createTrait([ci, cl])
    , c11 = Kotlin.createTrait([ci, c15])
    , c2 = Kotlin.createTrait([ci, c11])
    , cn = Kotlin.createTrait([ci, c15])
    , c3 = Kotlin.createTrait([ci, cn])
    , c4 = Kotlin.createTrait(null)
    , c5 = Kotlin.createTrait(null)
    , c6 = Kotlin.createClass(c4, function () {
      Object.defineProperty(this, 'LOADER_XMI_LOCAL_NAME', {value: 'type'});
      Object.defineProperty(this, 'LOADER_XMI_XSI', {value: 'xsi'});
      Object.defineProperty(this, 'factory', {value: null, writable: true});
      Object.defineProperty(this, 'attributesHashmap', {value: Kotlin.PrimitiveHashMap(0)});
      Object.defineProperty(this, 'referencesHashmap', {value: Kotlin.PrimitiveHashMap(0)});
      Object.defineProperty(this, 'attributeVisitor', {value: _.org.kevoree.modeling.api.xmi.XMIModelLoader.f1(this)});
      Object.defineProperty(this, 'referencesVisitor', {value: _.org.kevoree.modeling.api.xmi.XMIModelLoader.f3(this)});
    }, /** @lends _.org.kevoree.modeling.api.xmi.XMIModelLoader.prototype */ {
      unescapeXml: {value: function (src) {
        var builder = null;
        var i = 0;
        while (i < src.length) {
          var c = src.charAt(i);
          if (c === '&') {
            if (builder == null) {
              builder = _.java.lang.StringBuilder();
              (builder != null ? builder : Kotlin.throwNPE()).append(src.substring(0, i));
            }
            if (src.charAt(i + 1) === 'a') {
              if (src.charAt(i + 2) === 'm') {
                builder != null ? builder.append('&') : null;
                i = i + 5;
              }
               else if (src.charAt(i + 2) === 'p') {
                builder != null ? builder.append("'") : null;
                i = i + 6;
              }
               else {
                Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1) + src.charAt(i + 2));
              }
            }
             else if (src.charAt(i + 1) === 'q') {
              builder != null ? builder.append('"') : null;
              i = i + 6;
            }
             else if (src.charAt(i + 1) === 'l') {
              builder != null ? builder.append('<') : null;
              i = i + 4;
            }
             else if (src.charAt(i + 1) === 'g') {
              builder != null ? builder.append('>') : null;
              i = i + 4;
            }
             else {
              Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1));
            }
          }
           else {
            if (builder != null) {
              builder != null ? builder.append_0(c) : null;
            }
            i++;
          }
        }
        if (builder != null) {
          return Kotlin.toString(builder);
        }
         else {
          return src;
        }
      }},
      loadModelFromString: {value: function (str) {
        var reader = _.org.kevoree.modeling.api.xmi.XmlParser(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(str));
        if (reader.hasNext()) {
          return this.deserialize(reader);
        }
         else {
          Kotlin.println('Loader::Noting in the String !');
          return null;
        }
      }, writable: true},
      loadModelFromStream: {value: function (inputStream) {
        var reader = _.org.kevoree.modeling.api.xmi.XmlParser(inputStream);
        if (reader.hasNext()) {
          return this.deserialize(reader);
        }
         else {
          Kotlin.println('Loader::Noting in the file !');
          return null;
        }
      }, writable: true},
      loadObject: {value: function (ctx, xmiAddress, objectType) {
        var tmp$0, tmp$12, tmp$13, tmp$14, tmp$15, tmp$16, tmp$17, tmp$18;
        var elementTagName = ((tmp$0 = ctx.xmiReader) != null ? tmp$0 : Kotlin.throwNPE()).getLocalName();
        var modelElem;
        if (objectType != null) {
          var tmp$1;
          modelElem = (tmp$1 = this.factory) != null ? tmp$1.create(objectType) : null;
          if (modelElem == null) {
            var xsiType = null;
            var tmp$2, tmp$3, tmp$4, tmp$5, tmp$6;
            {
              tmp$3 = Kotlin.NumberRange(0, ((tmp$2 = ctx.xmiReader) != null ? tmp$2 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$4 = tmp$3.get_start(), tmp$5 = tmp$3.get_end(), tmp$6 = tmp$3.get_increment();
              for (var i = tmp$4; i <= tmp$5; i += tmp$6) {
                var tmp$7, tmp$8;
                var localName = ((tmp$7 = ctx.xmiReader) != null ? tmp$7 : Kotlin.throwNPE()).getAttributeLocalName(i);
                var xsi = ((tmp$8 = ctx.xmiReader) != null ? tmp$8 : Kotlin.throwNPE()).getAttributePrefix(i);
                if (Kotlin.equals(localName, this.LOADER_XMI_LOCAL_NAME) && Kotlin.equals(xsi, this.LOADER_XMI_XSI)) {
                  var tmp$9;
                  xsiType = ((tmp$9 = ctx.xmiReader) != null ? tmp$9 : Kotlin.throwNPE()).getAttributeValue(i);
                  break;
                }
              }
            }
            if (xsiType != null) {
              var tmp$10;
              modelElem = (tmp$10 = this.factory) != null ? tmp$10.create((xsiType != null ? xsiType : Kotlin.throwNPE()).substring((xsiType != null ? xsiType : Kotlin.throwNPE()).lastIndexOf(':') + 1, (xsiType != null ? xsiType : Kotlin.throwNPE()).length)) : null;
            }
          }
        }
         else {
          var tmp$11;
          modelElem = (tmp$11 = this.factory) != null ? tmp$11.create(elementTagName != null ? elementTagName : Kotlin.throwNPE()) : null;
        }
        if (modelElem == null) {
          Kotlin.println('Could not create an object for local name ' + elementTagName);
        }
        ctx.map.put(xmiAddress, modelElem != null ? modelElem : Kotlin.throwNPE());
        if (!this.attributesHashmap.containsKey((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) {
          modelElem != null ? modelElem.visitAttributes(this.attributeVisitor) : null;
        }
        var elemAttributesMap = (tmp$12 = this.attributesHashmap.get((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) != null ? tmp$12 : Kotlin.throwNPE();
        if (!this.referencesHashmap.containsKey((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) {
          modelElem != null ? modelElem.visit(this.referencesVisitor, false, true, false) : null;
        }
        var elemReferencesMap = (tmp$13 = this.referencesHashmap.get((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) != null ? tmp$13 : Kotlin.throwNPE();
        {
          tmp$15 = Kotlin.NumberRange(0, ((tmp$14 = ctx.xmiReader) != null ? tmp$14 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$16 = tmp$15.get_start(), tmp$17 = tmp$15.get_end(), tmp$18 = tmp$15.get_increment();
          for (var i_0 = tmp$16; i_0 <= tmp$17; i_0 += tmp$18) {
            var tmp$19;
            var prefix = ((tmp$19 = ctx.xmiReader) != null ? tmp$19 : Kotlin.throwNPE()).getAttributePrefix(i_0);
            if (prefix == null || Kotlin.equals(prefix, '')) {
              var tmp$20, tmp$21;
              var attrName = ((tmp$20 = ctx.xmiReader) != null ? tmp$20 : Kotlin.throwNPE()).getAttributeLocalName(i_0);
              var valueAtt = ((tmp$21 = ctx.xmiReader) != null ? tmp$21 : Kotlin.throwNPE()).getAttributeValue(i_0);
              if (valueAtt != null) {
                if (elemAttributesMap.containsKey(attrName)) {
                  modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, attrName != null ? attrName : Kotlin.throwNPE(), this.unescapeXml(valueAtt), false, false) : null;
                }
                 else {
                  var tmp$22, tmp$23, tmp$24;
                  {
                    tmp$22 = Kotlin.splitString(valueAtt, ' '), tmp$23 = tmp$22.length;
                    for (var tmp$24 = 0; tmp$24 !== tmp$23; ++tmp$24) {
                      var xmiRef = tmp$22[tmp$24];
                      {
                        var tmp$25, tmp$26;
                        if (xmiRef.startsWith('#')) {
                          tmp$25 = xmiRef.substring(1);
                        }
                         else {
                          tmp$25 = xmiRef;
                        }
                        var adjustedRef = tmp$25;
                        if (adjustedRef.startsWith('//')) {
                          tmp$26 = '/0' + adjustedRef.substring(1);
                        }
                         else {
                          tmp$26 = adjustedRef;
                        }
                        adjustedRef = tmp$26;
                        adjustedRef = adjustedRef.replace('.0', '');
                        var ref = ctx.map.get(adjustedRef);
                        if (ref != null) {
                          modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, attrName != null ? attrName : Kotlin.throwNPE(), ref, true, false) : null;
                        }
                         else {
                          ctx.resolvers.add(_.org.kevoree.modeling.api.xmi.XMIResolveCommand(ctx, modelElem != null ? modelElem : Kotlin.throwNPE(), _.org.kevoree.modeling.api.util.ActionType.ADD, attrName != null ? attrName : Kotlin.throwNPE(), adjustedRef));
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        var done = false;
        while (!done) {
          var tmp$27;
          var tmp$28 = ((tmp$27 = ctx.xmiReader) != null ? tmp$27 : Kotlin.throwNPE()).next();
          if (tmp$28 === _.org.kevoree.modeling.api.xmi.Token.START_TAG) {
            var tmp$29, tmp$31;
            var subElemName = ((tmp$29 = ctx.xmiReader) != null ? tmp$29 : Kotlin.throwNPE()).getLocalName();
            var i_1 = ctx.elementsCount.get(xmiAddress + '/@' + subElemName) !== null ? ctx.elementsCount.get(xmiAddress + '/@' + subElemName) : 0;
            var tmp$30 = xmiAddress + '/@' + subElemName;
            if (i_1 !== 0) {
              tmp$31 = '.' + i_1;
            }
             else {
              tmp$31 = '';
            }
            var subElementId = tmp$30 + tmp$31;
            var containedElement = this.loadObject(ctx, subElementId, elemReferencesMap.get(subElemName));
            modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, subElemName != null ? subElemName : Kotlin.throwNPE(), containedElement, true, false) : null;
            ctx.elementsCount.put(xmiAddress + '/@' + subElemName, i_1 + 1);
          }
           else if (tmp$28 === _.org.kevoree.modeling.api.xmi.Token.END_TAG) {
            var tmp$32;
            if (Kotlin.equals(((tmp$32 = ctx.xmiReader) != null ? tmp$32 : Kotlin.throwNPE()).getLocalName(), elementTagName)) {
              done = true;
            }
          }
           else {
          }
        }
        return modelElem != null ? modelElem : Kotlin.throwNPE();
      }},
      deserialize: {value: function (reader) {
        var context = _.org.kevoree.modeling.api.xmi.LoadingContext();
        context.xmiReader = reader;
        while (reader.hasNext()) {
          var nextTag = reader.next();
          if (nextTag === _.org.kevoree.modeling.api.xmi.Token.START_TAG) {
            var localName = reader.getLocalName();
            if (localName != null) {
              var loadedRootsSize = context.loadedRoots.size();
              context.loadedRoots.add(this.loadObject(context, '/' + loadedRootsSize, null));
            }
             else {
              Kotlin.println('Tried to read a tag with null tag_name.');
            }
          }
           else if (nextTag === _.org.kevoree.modeling.api.xmi.Token.END_TAG) {
            break;
          }
           else if (nextTag === _.org.kevoree.modeling.api.xmi.Token.END_DOCUMENT) {
            break;
          }
           else {
          }
        }
        {
          var tmp$0 = context.resolvers.iterator();
          while (tmp$0.hasNext()) {
            var res = tmp$0.next();
            res.run();
          }
        }
        return context.loadedRoots;
      }}
    }, /** @lends _.org.kevoree.modeling.api.xmi.XMIModelLoader */ {
      f0: {value: function () {
        return Kotlin.PrimitiveHashMap(0);
      }},
      f1: {value: function ($outer) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelAttributeVisitor, null, {
          visit: {value: function (value, name, parent) {
            _.kotlin.getOrPut($outer.attributesHashmap, parent.metaClassName(), _.org.kevoree.modeling.api.xmi.XMIModelLoader.f0).put(name, true);
          }, writable: true, enumerable: true}
        });
      }},
      f2: {value: function () {
        return Kotlin.PrimitiveHashMap(0);
      }},
      f3: {value: function ($outer) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
          Object.defineProperty(this, 'refMap', {value: null, writable: true, enumerable: true});
        }, {
          beginVisitElem: {value: function (elem) {
            this.refMap = _.kotlin.getOrPut($outer.referencesHashmap, elem.metaClassName(), _.org.kevoree.modeling.api.xmi.XMIModelLoader.f2);
          }, writable: true, enumerable: true},
          endVisitElem: {value: function (elem) {
            this.refMap = null;
          }, writable: true, enumerable: true},
          beginVisitRef: {value: function (refName, refType) {
            var tmp$0;
            ((tmp$0 = this.refMap) != null ? tmp$0 : Kotlin.throwNPE()).put(refName, refType);
          }, writable: true, enumerable: true},
          visit: {value: function (elem, refNameInParent, parent) {
          }, writable: true, enumerable: true}
        });
      }}
    })
    , ca = Kotlin.createTrait(null)
    , c7 = Kotlin.createClass(ca, null, /** @lends _.org.kevoree.modeling.api.xmi.XMIModelSerializer.prototype */ {
      serialize: {value: function (oMS) {
        var oo = _.java.io.ByteArrayOutputStream();
        this.serialize_0(oMS, oo);
        oo.flush();
        return oo.toString();
      }, writable: true},
      serialize_0: {value: function (oMS, ostream) {
        var wt = _.java.io.PrintStream(_.java.io.BufferedOutputStream(ostream), false);
        var addressTable = Kotlin.ComplexHashMap(0);
        var packageList = Kotlin.ArrayList(0);
        addressTable.put(oMS, '/');
        var elementsCount = Kotlin.PrimitiveHashMap(0);
        var addressBuilderVisitor = _.org.kevoree.modeling.api.xmi.ModelAddressVisitor(addressTable, elementsCount, packageList);
        oMS.visit(addressBuilderVisitor, true, true, false);
        var masterVisitor = _.org.kevoree.modeling.api.xmi.ModelSerializationVisitor(wt, addressTable, elementsCount);
        wt.println('<?xml version="1.0" encoding="UTF-8"?>');
        wt.print('<' + this.formatMetaClassName(oMS.metaClassName()).replace('.', '_'));
        wt.print(' xmlns:xsi="http://wwww.w3.org/2001/XMLSchema-instance"');
        wt.print(' xmi:version="2.0"');
        wt.print(' xmlns:xmi="http://www.omg.org/XMI"');
        var index = 0;
        while (index < _.kotlin.get_size(packageList)) {
          wt.print(' xmlns:' + packageList.get(index).replace('.', '_') + '="http://' + packageList.get(index) + '"');
          index++;
        }
        oMS.visitAttributes(_.org.kevoree.modeling.api.xmi.AttributesVisitor(wt));
        oMS.visit(_.org.kevoree.modeling.api.xmi.ReferencesVisitor(wt, addressTable, elementsCount), false, false, true);
        wt.println('>');
        oMS.visit(masterVisitor, false, true, false);
        wt.println('<\/' + this.formatMetaClassName(oMS.metaClassName()).replace('.', '_') + '>');
        wt.flush();
      }, writable: true},
      formatMetaClassName: {value: function (metaClassName) {
        var lastPoint = _.js.lastIndexOf_0(metaClassName, '.');
        var pack = metaClassName.substring(0, lastPoint);
        var cls = metaClassName.substring(lastPoint + 1);
        return pack + ':' + cls;
      }}
    })
    , c8 = Kotlin.createTrait(null, /** @lends _.org.kevoree.modeling.api.ModelCloner.prototype */ {
      clone: {value: function (o) {
        return this.clone_0(o, false);
      }, writable: true},
      clone_0: {value: function (o, readOnly) {
        return this.clone_1(o, readOnly, false);
      }, writable: true},
      cloneMutableOnly: {value: function (o, readOnly) {
        return this.clone_1(o, readOnly, true);
      }, writable: true},
      cloneModelElem: {value: function (src) {
        var tmp$0;
        var clonedSrc = (tmp$0 = this.mainFactory.create(src.metaClassName())) != null ? tmp$0 : Kotlin.throwNPE();
        var attributesCloner = _.org.kevoree.modeling.api.ModelCloner.f0(clonedSrc);
        src.visitAttributes(attributesCloner);
        return clonedSrc;
      }, writable: true},
      resolveModelElem: {value: function (src, target, context, mutableOnly) {
        var refResolver = _.org.kevoree.modeling.api.ModelCloner.f1(mutableOnly, target, context);
        src.visit(refResolver, false, true, true);
      }, writable: true},
      clone_1: {value: function (o, readOnly, mutableOnly) {
        var context = this.createContext();
        var clonedObject = this.cloneModelElem(o);
        context.put(o, clonedObject);
        var cloneGraphVisitor = _.org.kevoree.modeling.api.ModelCloner.f2(this, mutableOnly, context);
        o.visit(cloneGraphVisitor, true, true, false);
        var resolveGraphVisitor = _.org.kevoree.modeling.api.ModelCloner.f3(this, mutableOnly, context, readOnly);
        o.visit(resolveGraphVisitor, true, true, false);
        this.resolveModelElem(o, clonedObject, context, mutableOnly);
        if (readOnly) {
          clonedObject.setInternalReadOnly();
        }
        return clonedObject != null ? clonedObject : Kotlin.throwNPE();
      }, writable: true}
    }, /** @lends _.org.kevoree.modeling.api.ModelCloner */ {
      f0: {value: function (clonedSrc) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelAttributeVisitor, null, {
          visit: {value: function (value, name, parent) {
            if (value != null) {
              clonedSrc.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, name, value, false, false);
            }
          }, writable: true, enumerable: true}
        });
      }},
      f1: {value: function (mutableOnly, target, context) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            if (mutableOnly && elem.isRecursiveReadOnly()) {
              target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, refNameInParent, elem, false, false);
            }
             else {
              target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, refNameInParent, context.get(elem), false, false);
            }
          }, writable: true, enumerable: true}
        });
      }},
      f2: {value: function ($outer, mutableOnly, context) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            if (mutableOnly && elem.isRecursiveReadOnly()) {
              this.noChildrenVisit();
            }
             else {
              context.put(elem, $outer.cloneModelElem(elem));
            }
          }, writable: true, enumerable: true}
        });
      }},
      f3: {value: function ($outer, mutableOnly, context, readOnly) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            if (mutableOnly && elem.isRecursiveReadOnly()) {
            }
             else {
              var tmp$0;
              var clonedObj = (tmp$0 = context.get(elem)) != null ? tmp$0 : Kotlin.throwNPE();
              $outer.resolveModelElem(elem, clonedObj, context, mutableOnly);
              if (readOnly) {
                clonedObj.setInternalReadOnly();
              }
            }
          }, writable: true, enumerable: true}
        });
      }}
    })
    , c9 = Kotlin.createTrait(null, /** @lends _.org.kevoree.modeling.api.compare.ModelCompare.prototype */ {
      diff: {value: function (origin, target) {
        return this.createSequence().populate(this.internal_diff(origin, target, false, false));
      }, writable: true},
      merge: {value: function (origin, target) {
        return this.createSequence().populate(this.internal_diff(origin, target, false, true));
      }, writable: true},
      inter: {value: function (origin, target) {
        return this.createSequence().populate(this.internal_diff(origin, target, true, false));
      }, writable: true},
      internal_diff: {value: function (origin, target, inter, merge) {
        var traces = Kotlin.ArrayList(0);
        var tracesRef = Kotlin.ArrayList(0);
        var objectsMap = Kotlin.PrimitiveHashMap(0);
        traces.addAll(origin.createTraces(target, inter, merge, false, true));
        tracesRef.addAll(origin.createTraces(target, inter, merge, true, false));
        var visitor = _.org.kevoree.modeling.api.compare.ModelCompare.f0(objectsMap);
        origin.visit(visitor, true, true, false);
        var visitor2 = _.org.kevoree.modeling.api.compare.ModelCompare.f1(objectsMap, inter, traces, merge, tracesRef);
        target.visit(visitor2, true, true, false);
        if (!inter) {
          if (!merge) {
            {
              var tmp$0 = objectsMap.values().iterator();
              while (tmp$0.hasNext()) {
                var diffChild = tmp$0.next();
                var tmp$3, tmp$5, tmp$6;
                if (diffChild.eContainer() != null) {
                  var tmp$1, tmp$2;
                  tmp$3 = (tmp$2 = ((tmp$1 = diffChild.eContainer()) != null ? tmp$1 : Kotlin.throwNPE()).path()) != null ? tmp$2 : Kotlin.throwNPE();
                }
                 else {
                  tmp$3 = 'null';
                }
                var src = tmp$3;
                if (diffChild.getRefInParent() != null) {
                  var tmp$4;
                  tmp$5 = (tmp$4 = diffChild.getRefInParent()) != null ? tmp$4 : Kotlin.throwNPE();
                }
                 else {
                  tmp$5 = 'null';
                }
                var refNameInParent = tmp$5;
                traces.add(_.org.kevoree.modeling.api.trace.ModelRemoveTrace(src, refNameInParent, (tmp$6 = (diffChild != null ? diffChild : Kotlin.throwNPE()).path()) != null ? tmp$6 : Kotlin.throwNPE()));
              }
            }
          }
        }
        traces.addAll(tracesRef);
        return traces;
      }, writable: true}
    }, /** @lends _.org.kevoree.modeling.api.compare.ModelCompare */ {
      f0: {value: function (objectsMap) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            var childPath = elem.path();
            if (childPath != null) {
              objectsMap.put(childPath, elem);
            }
             else {
              throw new Error('Null child path ' + elem);
            }
          }, writable: true, enumerable: true}
        });
      }},
      f1: {value: function (objectsMap, inter, traces, merge, tracesRef) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            var childPath = elem.path();
            if (childPath != null) {
              if (objectsMap.containsKey(childPath)) {
                if (inter) {
                  var tmp$0;
                  traces.add(_.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$0 = parent.path()) != null ? tmp$0 : Kotlin.throwNPE(), refNameInParent, elem.path(), elem.metaClassName()));
                }
                var tmp$1, tmp$2;
                traces.addAll(((tmp$1 = objectsMap.get(childPath)) != null ? tmp$1 : Kotlin.throwNPE()).createTraces(elem, inter, merge, false, true));
                tracesRef.addAll(((tmp$2 = objectsMap.get(childPath)) != null ? tmp$2 : Kotlin.throwNPE()).createTraces(elem, inter, merge, true, false));
                objectsMap.remove(childPath);
              }
               else {
                if (!inter) {
                  var tmp$3;
                  traces.add(_.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$3 = parent.path()) != null ? tmp$3 : Kotlin.throwNPE(), refNameInParent, elem.path(), elem.metaClassName()));
                  traces.addAll(elem.createTraces(elem, true, merge, false, true));
                  tracesRef.addAll(elem.createTraces(elem, true, merge, true, false));
                }
              }
            }
             else {
              throw new Error('Null child path ' + elem);
            }
          }, writable: true, enumerable: true}
        });
      }}
    })
    , cb = Kotlin.createClass(c4, function () {
      Object.defineProperty(this, 'factory', {value: null, writable: true});
    }, /** @lends _.org.kevoree.modeling.api.json.JSONModelLoader.prototype */ {
      loadModelFromString: {value: function (str) {
        return this.deserialize(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(str));
      }, writable: true},
      loadModelFromStream: {value: function (inputStream) {
        return this.deserialize(inputStream);
      }, writable: true},
      deserialize: {value: function (instream) {
        var resolverCommands = Kotlin.ArrayList(0);
        var roots = Kotlin.ArrayList(0);
        var lexer = _.org.kevoree.modeling.api.json.Lexer(instream);
        var currentToken = lexer.nextToken();
        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
          this.loadObject(lexer, null, null, roots, resolverCommands);
        }
         else {
          throw new Error('Bad Format / {\xA0expected');
        }
        {
          var tmp$0 = resolverCommands.iterator();
          while (tmp$0.hasNext()) {
            var resol = tmp$0.next();
            resol.run();
          }
        }
        return roots;
      }},
      loadObject: {value: function (lexer, nameInParent, parent, roots, commands) {
        var currentToken = lexer.nextToken();
        var currentObject = null;
        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
          if (Kotlin.equals(currentToken.value, 'eClass')) {
            lexer.nextToken();
            currentToken = lexer.nextToken();
            var tmp$0, tmp$1;
            var name = (tmp$0 = Kotlin.toString(currentToken.value)) != null ? tmp$0 : Kotlin.throwNPE();
            currentObject = (tmp$1 = this.factory) != null ? tmp$1.create(name) : null;
            if (parent == null) {
              roots.add(currentObject != null ? currentObject : Kotlin.throwNPE());
            }
            var currentNameAttOrRef = null;
            var refModel = false;
            currentToken = lexer.nextToken();
            while (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.EOF) {
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                this.loadObject(lexer, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), currentObject, roots, commands);
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.COMMA) {
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                if (currentNameAttOrRef == null) {
                  currentNameAttOrRef = Kotlin.toString(currentToken.value);
                }
                 else {
                  if (refModel) {
                    var tmp$2;
                    commands.add(_.org.kevoree.modeling.api.json.ResolveCommand(roots, Kotlin.toString((tmp$2 = currentToken.value) != null ? tmp$2 : Kotlin.throwNPE()), currentObject != null ? currentObject : Kotlin.throwNPE(), currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE()));
                  }
                   else {
                    (currentObject != null ? currentObject : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), this.unescapeJSON(Kotlin.toString(currentToken.value)), false, false);
                    currentNameAttOrRef = null;
                  }
                }
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET) {
                currentToken = lexer.nextToken();
                if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                  this.loadObject(lexer, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), currentObject, roots, commands);
                }
                 else {
                  refModel = true;
                  if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                    var tmp$3;
                    commands.add(_.org.kevoree.modeling.api.json.ResolveCommand(roots, Kotlin.toString((tmp$3 = currentToken.value) != null ? tmp$3 : Kotlin.throwNPE()), currentObject != null ? currentObject : Kotlin.throwNPE(), currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE()));
                  }
                }
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET) {
                currentNameAttOrRef = null;
                refModel = false;
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE) {
                if (parent != null) {
                  parent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, nameInParent != null ? nameInParent : Kotlin.throwNPE(), currentObject, false, false);
                }
                return;
              }
              currentToken = lexer.nextToken();
            }
          }
           else {
            throw new Error('Bad Format / eClass att must be first');
          }
        }
         else {
          throw new Error('Bad Format');
        }
      }},
      unescapeJSON: {value: function (src) {
        var builder = null;
        var i = 0;
        while (i < src.length) {
          var c = src.charAt(i);
          if (c === '&') {
            if (builder == null) {
              builder = src.substring(0, i);
            }
            if (src.charAt(i + 1) === 'a') {
              builder = (builder != null ? builder : Kotlin.throwNPE()) + "'";
              i = i + 6;
            }
             else if (src.charAt(i + 1) === 'q') {
              builder = (builder != null ? builder : Kotlin.throwNPE()) + '"';
              i = i + 6;
            }
             else {
              Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1));
            }
          }
           else {
            if (builder != null) {
              builder = (builder != null ? builder : Kotlin.throwNPE()) + c;
            }
            i++;
          }
        }
        if (builder != null) {
          return builder != null ? builder : Kotlin.throwNPE();
        }
         else {
          return src;
        }
      }}
    })
    , cc = Kotlin.createClass(ca, null, /** @lends _.org.kevoree.modeling.api.json.JSONModelSerializer.prototype */ {
      serialize: {value: function (model) {
        var outstream = _.java.io.ByteArrayOutputStream();
        this.serialize_0(model, outstream);
        outstream.close();
        return outstream.toString();
      }, writable: true},
      serialize_0: {value: function (model, raw) {
        var out = _.java.io.PrintStream(_.java.io.BufferedOutputStream(raw), false);
        var internalReferenceVisitor = _.org.kevoree.modeling.api.json.ModelReferenceVisitor(out);
        var masterVisitor = _.org.kevoree.modeling.api.json.JSONModelSerializer.f0(this, out, internalReferenceVisitor);
        model.visit(masterVisitor, true, true, false);
        out.flush();
      }, writable: true},
      printAttName: {value: function (elem, out) {
        out.print('\n{"eClass":"' + elem.metaClassName() + '"');
        var attributeVisitor = _.org.kevoree.modeling.api.json.JSONModelSerializer.f1(this, out);
        elem.visitAttributes(attributeVisitor);
      }},
      escapeJson: {value: function (ostream, chain) {
        if (chain == null) {
          return;
        }
        var i = 0;
        while (i < chain.length) {
          var c = chain.charAt(i);
          if (c === '"') {
            ostream.print('&quot;');
          }
           else if (c === "'") {
            ostream.print('&apos;');
          }
           else {
            ostream.print_0(c);
          }
          i = i + 1;
        }
      }}
    }, /** @lends _.org.kevoree.modeling.api.json.JSONModelSerializer */ {
      f0: {value: function ($outer, out, internalReferenceVisitor) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
          Object.defineProperty(this, 'isFirstInRef', {value: true, writable: true, enumerable: true});
        }, {
          beginVisitElem: {value: function (elem) {
            if (!this.isFirstInRef) {
              out.print(',');
              this.isFirstInRef = false;
            }
            $outer.printAttName(elem, out);
            var tmp$0;
            (tmp$0 = internalReferenceVisitor.alreadyVisited) != null ? tmp$0.clear() : null;
            elem.visit(internalReferenceVisitor, false, false, true);
          }, writable: true, enumerable: true},
          endVisitElem: {value: function (elem) {
            out.println('}');
            this.isFirstInRef = false;
          }, writable: true, enumerable: true},
          beginVisitRef: {value: function (refName, refType) {
            out.print(',"' + refName + '":[');
            this.isFirstInRef = true;
          }, writable: true, enumerable: true},
          endVisitRef: {value: function (refName) {
            out.print(']');
            this.isFirstInRef = false;
          }, writable: true, enumerable: true},
          visit: {value: function (elem, refNameInParent, parent) {
          }, writable: true, enumerable: true}
        });
      }},
      f1: {value: function ($outer, out) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelAttributeVisitor, null, {
          visit: {value: function (value, name, parent) {
            if (value != null) {
              out.print(',"' + name + '":"');
              $outer.escapeJson(out, Kotlin.toString(value));
              out.print('"');
            }
          }, writable: true, enumerable: true}
        });
      }}
    })
    , cd = Kotlin.createTrait(null)
    , ce = Kotlin.createTrait(cd)
    , cf = Kotlin.createTrait(null)
    , cg = Kotlin.createTrait(null)
    , ch = Kotlin.createTrait(null, /** @lends _.org.kevoree.modeling.api.trace.TraceSequence.prototype */ {
      populate: {value: function (addtraces) {
        this.traces.addAll(addtraces);
        return this;
      }, writable: true},
      populateFromString: {value: function (addtracesTxt) {
        return this.populateFromStream(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(addtracesTxt));
      }, writable: true},
      populateFromStream: {value: function (inputStream) {
        var lexer = _.org.kevoree.modeling.api.json.Lexer(inputStream);
        var currentToken = lexer.nextToken();
        if (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET) {
          throw new Error('Bad Format : expect [');
        }
        currentToken = lexer.nextToken();
        var keys = Kotlin.PrimitiveHashMap(0);
        var previousName = null;
        while (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.EOF && currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET) {
          if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
            keys.clear();
          }
          if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
            if (previousName != null) {
              keys.put(previousName != null ? previousName : Kotlin.throwNPE(), Kotlin.toString(currentToken.value));
              previousName = null;
            }
             else {
              previousName = Kotlin.toString(currentToken.value);
            }
          }
          if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE) {
            var tmp$0;
            var tmp$1 = (tmp$0 = keys.get('traceType')) != null ? tmp$0 : Kotlin.throwNPE();
            if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.SET)) {
              var tmp$2, tmp$3;
              this.traces.add(_.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$2 = keys.get('src')) != null ? tmp$2 : Kotlin.throwNPE(), (tmp$3 = keys.get('refname')) != null ? tmp$3 : Kotlin.throwNPE(), keys.get('objpath'), keys.get('content'), keys.get('typename')));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.ADD)) {
              var tmp$4, tmp$5, tmp$6;
              this.traces.add(_.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$4 = keys.get('src')) != null ? tmp$4 : Kotlin.throwNPE(), (tmp$5 = keys.get('refname')) != null ? tmp$5 : Kotlin.throwNPE(), (tmp$6 = keys.get('previouspath')) != null ? tmp$6 : Kotlin.throwNPE(), keys.get('typename')));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.ADD_ALL)) {
              var tmp$7, tmp$8, tmp$9, tmp$10, tmp$11, tmp$12;
              this.traces.add(_.org.kevoree.modeling.api.trace.ModelAddAllTrace((tmp$7 = keys.get('src')) != null ? tmp$7 : Kotlin.throwNPE(), (tmp$8 = keys.get('refname')) != null ? tmp$8 : Kotlin.throwNPE(), (tmp$10 = (tmp$9 = keys.get('content')) != null ? Kotlin.splitString(tmp$9, ';') : null) != null ? _.kotlin.toList_2(tmp$10) : null, (tmp$12 = (tmp$11 = keys.get('typename')) != null ? Kotlin.splitString(tmp$11, ';') : null) != null ? _.kotlin.toList_2(tmp$12) : null));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.REMOVE)) {
              var tmp$13, tmp$14, tmp$15;
              this.traces.add(_.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$13 = keys.get('src')) != null ? tmp$13 : Kotlin.throwNPE(), (tmp$14 = keys.get('refname')) != null ? tmp$14 : Kotlin.throwNPE(), (tmp$15 = keys.get('objpath')) != null ? tmp$15 : Kotlin.throwNPE()));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL)) {
              var tmp$16, tmp$17;
              this.traces.add(_.org.kevoree.modeling.api.trace.ModelRemoveAllTrace((tmp$16 = keys.get('src')) != null ? tmp$16 : Kotlin.throwNPE(), (tmp$17 = keys.get('refname')) != null ? tmp$17 : Kotlin.throwNPE()));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX)) {
            }
             else {
              Kotlin.println('Trace lost !!!');
            }
          }
          currentToken = lexer.nextToken();
        }
        return this;
      }, writable: true},
      exportToString: {value: function () {
        var buffer = _.java.lang.StringBuilder();
        buffer.append('[');
        var isFirst = true;
        {
          var tmp$0 = this.traces.iterator();
          while (tmp$0.hasNext()) {
            var trace = tmp$0.next();
            if (!isFirst) {
              buffer.append(',');
            }
            buffer.append(trace.toString());
            isFirst = false;
          }
        }
        buffer.append(']');
        return buffer.toString();
      }, writable: true},
      applyOn: {value: function (target) {
        var tmp$0;
        var traceApplicator = _.org.kevoree.modeling.api.trace.ModelTraceApplicator(target, (tmp$0 = this.factory) != null ? tmp$0 : Kotlin.throwNPE());
        traceApplicator.applyTraceOnModel(this);
        return true;
      }, writable: true}
    })
    , cj = Kotlin.createClass(null, function () {
      Object.defineProperty(this, 'visitStopped', {value: false, writable: true});
      Object.defineProperty(this, 'visitChildren', {value: true, writable: true});
      Object.defineProperty(this, 'alreadyVisited', {value: null, writable: true});
    }, /** @lends _.org.kevoree.modeling.api.util.ModelVisitor.prototype */ {
      stopVisit: {value: function () {
        this.visitStopped = true;
      }},
      noChildrenVisit: {value: function () {
        this.visitChildren = true;
      }},
      beginVisitElem: {value: function (elem) {
      }, writable: true},
      endVisitElem: {value: function (elem) {
      }, writable: true},
      beginVisitRef: {value: function (refName, refType) {
      }, writable: true},
      endVisitRef: {value: function (refName) {
      }, writable: true}
    })
    , ck = Kotlin.createTrait(null)
    , cm = Kotlin.createTrait(ci)
    , co = Kotlin.createTrait(ci)
    , cp = Kotlin.createTrait([ci, cl])
    , cq = Kotlin.createTrait([ci, c11])
    , cr = Kotlin.createTrait([ci, cn])
    , cs = Kotlin.createTrait(ci)
    , ct = Kotlin.createTrait(ci)
    , cu = Kotlin.createTrait([ci, cl, c13])
    , cv = Kotlin.createTrait(ci, /** @lends _.org.kevoree.container.KMFContainerImpl.prototype */ {
      eContainer: {value: function () {
        return this.internal_eContainer;
      }, writable: true},
      setRecursiveReadOnly: {value: function () {
        if (Kotlin.equals(this.internal_recursive_readOnlyElem, true)) {
          return;
        }
        this.setInternalRecursiveReadOnly();
        var recVisitor = _.org.kevoree.container.KMFContainerImpl.f0();
        this.visit(recVisitor, true, true, true);
        this.setInternalReadOnly();
      }, writable: true},
      setInternalReadOnly: {value: function () {
        this.internal_readOnlyElem = true;
      }, writable: true},
      setInternalRecursiveReadOnly: {value: function () {
        this.internal_recursive_readOnlyElem = true;
      }, writable: true},
      getRefInParent: {value: function () {
        return this.internal_containmentRefName;
      }, writable: true},
      isReadOnly: {value: function () {
        return this.internal_readOnlyElem;
      }, writable: true},
      isRecursiveReadOnly: {value: function () {
        return this.internal_recursive_readOnlyElem;
      }, writable: true},
      setEContainer: {value: function (container, unsetCmd, refNameInParent) {
        this.path_cache = null;
        if (this.internal_readOnlyElem) {
          return;
        }
        var tempUnsetCmd = this.internal_unsetCmd;
        this.internal_unsetCmd = null;
        if (tempUnsetCmd != null) {
          tempUnsetCmd.run();
        }
        this.internal_eContainer = container;
        this.internal_unsetCmd = unsetCmd;
        this.internal_containmentRefName = refNameInParent;
      }, writable: true},
      selectByQuery: {value: function (query) {
        throw new Error('Not activated, please add selector option in KMF generation plugin');
      }, writable: true},
      fireModelEvent: {value: function (evt) {
        if (this.internal_modelElementListeners != null) {
          var tmp$0;
          {
            var tmp$1 = ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).iterator();
            while (tmp$1.hasNext()) {
              var lst = tmp$1.next();
              lst.elementChanged(evt);
            }
          }
        }
        this.fireModelEventOnTree(evt);
      }, writable: true},
      addModelElementListener: {value: function (lst) {
        if (this.internal_modelElementListeners == null) {
          this.internal_modelElementListeners = Kotlin.ArrayList(0);
        }
        var tmp$0;
        ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).add(lst);
      }, writable: true},
      removeModelElementListener: {value: function (lst) {
        if (this.internal_modelElementListeners != null) {
          var tmp$0, tmp$1;
          ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).remove(lst);
          if (((tmp$1 = this.internal_modelElementListeners) != null ? tmp$1 : Kotlin.throwNPE()).isEmpty()) {
            this.internal_modelElementListeners = null;
          }
        }
      }, writable: true},
      removeAllModelElementListeners: {value: function () {
        if (this.internal_modelElementListeners != null) {
          var tmp$0;
          ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).clear();
          this.internal_modelElementListeners = null;
        }
      }, writable: true},
      fireModelEventOnTree: {value: function (evt) {
        if (this.internal_modelTreeListeners != null) {
          var tmp$0;
          {
            var tmp$1 = ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).iterator();
            while (tmp$1.hasNext()) {
              var lst = tmp$1.next();
              lst.elementChanged(evt);
            }
          }
        }
        if (this.eContainer() != null) {
          var tmp$2;
          ((tmp$2 = this.eContainer()) != null ? tmp$2 : Kotlin.throwNPE()).fireModelEventOnTree(evt);
        }
      }, writable: true},
      addModelTreeListener: {value: function (lst) {
        if (this.internal_modelTreeListeners == null) {
          this.internal_modelTreeListeners = Kotlin.ArrayList(0);
        }
        var tmp$0;
        ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).add(lst);
      }, writable: true},
      removeModelTreeListener: {value: function (lst) {
        if (this.internal_modelTreeListeners != null) {
          var tmp$0, tmp$1;
          ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).remove(lst);
          if (((tmp$1 = this.internal_modelTreeListeners) != null ? tmp$1 : Kotlin.throwNPE()).isEmpty()) {
            this.internal_modelTreeListeners = null;
          }
        }
      }, writable: true},
      removeAllModelTreeListeners: {value: function () {
        if (this.internal_modelTreeListeners != null) {
          var tmp$0;
          ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).clear();
          this.internal_modelElementListeners = null;
        }
      }, writable: true},
      visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
      }, writable: true},
      visitAttributes: {value: function (visitor) {
      }, writable: true},
      internal_visit: {value: function (visitor, internalElem, recursive, containedReference, nonContainedReference, refName) {
        if (internalElem != null) {
          if (nonContainedReference && recursive) {
            var tmp$0, tmp$1, tmp$2;
            var elemPath = (tmp$0 = internalElem.path()) != null ? tmp$0 : Kotlin.throwNPE();
            if (visitor.alreadyVisited != null && ((tmp$1 = visitor.alreadyVisited) != null ? tmp$1 : Kotlin.throwNPE()).containsKey(elemPath)) {
              return;
            }
            if (visitor.alreadyVisited == null) {
              visitor.alreadyVisited = Kotlin.PrimitiveHashMap(0);
            }
            ((tmp$2 = visitor.alreadyVisited) != null ? tmp$2 : Kotlin.throwNPE()).put(elemPath, internalElem);
          }
          visitor.visit(internalElem, refName, this);
          if (!visitor.visitStopped) {
            if (recursive && visitor.visitChildren) {
              internalElem.visit(visitor, recursive, containedReference, nonContainedReference);
            }
            visitor.visitChildren = true;
          }
        }
      }, writable: true},
      path: {value: function () {
        if (this.path_cache != null) {
          return this.path_cache;
        }
        var container = this.eContainer();
        if (container != null) {
          var parentPath = container.path();
          if (parentPath == null) {
            return null;
          }
           else {
            var tmp$0;
            if (Kotlin.equals(parentPath, '')) {
              tmp$0 = '';
            }
             else {
              tmp$0 = parentPath + '/';
            }
            this.path_cache = tmp$0 + this.internal_containmentRefName + '[' + this.internalGetKey() + ']';
          }
        }
         else {
          this.path_cache = '';
        }
        return this.path_cache;
      }, writable: true},
      modelEquals: {value: function (similarObj) {
        if (similarObj == null) {
          return false;
        }
        if (Kotlin.equals(this, similarObj)) {
          return true;
        }
        if (!Kotlin.equals(similarObj.metaClassName(), this.metaClassName())) {
          return false;
        }
        var values = Kotlin.PrimitiveHashMap(0);
        var attVisitor = _.org.kevoree.container.KMFContainerImpl.f1(values);
        this.visitAttributes(attVisitor);
        similarObj.visitAttributes(attVisitor);
        if (!values.isEmpty()) {
          return false;
        }
        var payload = '';
        var refVisitor = _.org.kevoree.container.KMFContainerImpl.f2(values, payload);
        this.visit(refVisitor, false, false, true);
        similarObj.visit(refVisitor, false, false, true);
        if (!values.isEmpty()) {
          return false;
        }
        return true;
      }, writable: true},
      deepModelEquals: {value: function (similarObj) {
        if (!this.modelEquals(similarObj)) {
          return false;
        }
        var similarRoot = similarObj != null ? similarObj : Kotlin.throwNPE();
        while (similarRoot.eContainer() != null) {
          var tmp$0;
          similarRoot = (tmp$0 = similarRoot.eContainer()) != null ? tmp$0 : Kotlin.throwNPE();
        }
        var resultTest = {v: true};
        var finalRoot = similarRoot;
        var objVisitor = _.org.kevoree.container.KMFContainerImpl.f3(finalRoot, resultTest);
        this.visit(objVisitor, true, true, false);
        return resultTest.v;
      }, writable: true},
      findByPath: {value: function (query) {
        var firstSepIndex = _.js.indexOf(query, '[');
        var queryID = '';
        var extraReadChar = 2;
        var relationName = query.substring(0, _.js.indexOf(query, '['));
        if (_.js.indexOf(query, '{') === firstSepIndex + 1) {
          queryID = query.substring(_.js.indexOf(query, '{') + 1, _.js.indexOf(query, '}'));
          extraReadChar = extraReadChar + 2;
        }
         else {
          var indexFirstClose = _.js.indexOf(query, ']');
          while (indexFirstClose + 1 < query.length && query.charAt(indexFirstClose + 1) !== '/') {
            indexFirstClose = _.js.indexOf_0(query, ']', indexFirstClose + 1);
          }
          queryID = query.substring(_.js.indexOf(query, '[') + 1, indexFirstClose);
        }
        var subquery = query.substring(relationName.length + queryID.length + extraReadChar, query.length);
        if (_.js.indexOf(subquery, '/') !== -1) {
          subquery = subquery.substring(_.js.indexOf(subquery, '/') + 1, subquery.length);
        }
        var objFound = this.findByID(relationName, queryID);
        if (!Kotlin.equals(subquery, '') && objFound != null) {
          return objFound.findByPath(subquery);
        }
         else {
          return objFound;
        }
      }, writable: true},
      createTraces: {value: function (similarObj, isInter, isMerge, onlyReferences, onlyAttributes) {
        var traces = Kotlin.ArrayList(0);
        var values = Kotlin.PrimitiveHashMap(0);
        if (onlyAttributes) {
          var attVisitorFill = _.org.kevoree.container.KMFContainerImpl.f4(values);
          this.visitAttributes(attVisitorFill);
          var attVisitor = _.org.kevoree.container.KMFContainerImpl.f5(this, values, isInter, traces);
          if (similarObj != null) {
            similarObj.visitAttributes(attVisitor);
          }
          if (!isInter && !isMerge && _.kotlin.get_size(values) !== 0) {
            {
              var tmp$0 = values.keySet().iterator();
              while (tmp$0.hasNext()) {
                var hashLoopRes = tmp$0.next();
                var tmp$1;
                traces.add(_.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$1 = this.path()) != null ? tmp$1 : Kotlin.throwNPE(), hashLoopRes, null, null, null));
              }
            }
          }
        }
        if (onlyReferences) {
          var payload = '';
          var refVisitorFill = _.org.kevoree.container.KMFContainerImpl.f6(values, payload);
          this.visit(refVisitorFill, false, false, true);
          var refVisitor = _.org.kevoree.container.KMFContainerImpl.f7(this, values, isInter, traces);
          if (similarObj != null) {
            similarObj.visit(refVisitor, false, false, true);
          }
          if (!isInter && !isMerge && _.kotlin.get_size(values) !== 0) {
            {
              var tmp$2 = values.keySet().iterator();
              while (tmp$2.hasNext()) {
                var hashLoopRes_0 = tmp$2.next();
                var splittedVal = Kotlin.splitString(hashLoopRes_0, '_');
                var tmp$3;
                traces.add(_.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$3 = this.path()) != null ? tmp$3 : Kotlin.throwNPE(), splittedVal[0], splittedVal[1]));
              }
            }
          }
        }
        return traces;
      }, writable: true}
    }, /** @lends _.org.kevoree.container.KMFContainerImpl */ {
      f0: {value: function () {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            if (elem.isRecursiveReadOnly()) {
              this.noChildrenVisit();
            }
             else {
              (elem != null ? elem : Kotlin.throwNPE()).setInternalRecursiveReadOnly();
              elem.setInternalReadOnly();
            }
          }, writable: true, enumerable: true}
        });
      }},
      f1: {value: function (values) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelAttributeVisitor, null, {
          visit: {value: function (value, name, parent) {
            if (values.containsKey(name)) {
              if (Kotlin.equals(values.get(name), Kotlin.toString(value))) {
                values.remove(name);
              }
            }
             else {
              values.put(name, Kotlin.toString(value));
            }
          }, writable: true, enumerable: true}
        });
      }},
      f2: {value: function (values, payload) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            var concatedKey = refNameInParent + '_' + elem.path();
            if (values.containsKey(concatedKey)) {
              values.remove(concatedKey);
            }
             else {
              values.put(concatedKey, payload);
            }
          }, writable: true, enumerable: true}
        });
      }},
      f3: {value: function (finalRoot, resultTest) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            var tmp$0;
            var similarSubObj = finalRoot.findByPath((tmp$0 = elem.path()) != null ? tmp$0 : Kotlin.throwNPE());
            if (!elem.modelEquals(similarSubObj)) {
              resultTest = false;
              this.stopVisit();
            }
          }, writable: true, enumerable: true}
        });
      }},
      f4: {value: function (values) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelAttributeVisitor, null, {
          visit: {value: function (value, name, parent) {
            values.put(name, Kotlin.toString(value));
          }, writable: true, enumerable: true}
        });
      }},
      f5: {value: function ($outer, values, isInter, traces) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelAttributeVisitor, null, {
          visit: {value: function (value, name, parent) {
            var attVal2;
            if (value != null) {
              attVal2 = Kotlin.toString(value);
            }
             else {
              attVal2 = null;
            }
            if (Kotlin.equals(values.get(name), attVal2)) {
              if (isInter) {
                var tmp$0;
                traces.add(_.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$0 = $outer.path()) != null ? tmp$0 : Kotlin.throwNPE(), name, null, attVal2, null));
              }
            }
             else {
              if (!isInter) {
                var tmp$1;
                traces.add(_.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$1 = $outer.path()) != null ? tmp$1 : Kotlin.throwNPE(), name, null, attVal2, null));
              }
            }
            values.remove(name);
          }, writable: true, enumerable: true}
        });
      }},
      f6: {value: function (values, payload) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            var concatedKey = refNameInParent + '_' + elem.path();
            values.put(concatedKey, payload);
          }, writable: true, enumerable: true}
        });
      }},
      f7: {value: function ($outer, values, isInter, traces) {
        return Kotlin.createObject(_.org.kevoree.modeling.api.util.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: {value: function (elem, refNameInParent, parent) {
            var concatedKey = refNameInParent + '_' + elem.path();
            if (values.get(concatedKey) != null) {
              if (isInter) {
                var tmp$0, tmp$1;
                traces.add(_.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$0 = $outer.path()) != null ? tmp$0 : Kotlin.throwNPE(), refNameInParent, (tmp$1 = elem.path()) != null ? tmp$1 : Kotlin.throwNPE(), null));
              }
            }
             else {
              if (!isInter) {
                var tmp$2, tmp$3;
                traces.add(_.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$2 = $outer.path()) != null ? tmp$2 : Kotlin.throwNPE(), refNameInParent, (tmp$3 = elem.path()) != null ? tmp$3 : Kotlin.throwNPE(), null));
              }
            }
            values.remove(concatedKey);
          }, writable: true, enumerable: true}
        });
      }}
    })
    , cw = Kotlin.createTrait([ci, cl])
    , cx = Kotlin.createTrait([ci, cl])
    , cy = Kotlin.createTrait(ci)
    , cz = Kotlin.createTrait(ci)
    , c10 = Kotlin.createTrait(ci)
    , c12 = Kotlin.createTrait([ci, cl])
    , c14 = Kotlin.createTrait([ci, cn])
    , c16 = Kotlin.createTrait([ci, cl])
    , c17 = Kotlin.createTrait([ci, cw])
    , c1g = Kotlin.createTrait([ci, cn])
    , c18 = Kotlin.createTrait([ci, c1g])
    , c19 = Kotlin.createTrait(c5)
    , c1a = Kotlin.createTrait(ci)
    , c1b = Kotlin.createTrait(ci)
    , c1c = Kotlin.createTrait([ci, c13])
    , c1d = Kotlin.createTrait(ci)
    , c1e = Kotlin.createTrait(ci)
    , c1f = Kotlin.createTrait([ci, cl])
    , c1h = Kotlin.createTrait([ci, cl])
    , c1i = Kotlin.createTrait([ci, cl])
    , c1j = Kotlin.createTrait(ci)
    , c1k = Kotlin.createTrait([ci, cl])
    , c1l = Kotlin.createTrait(ci)
    , c1m = Kotlin.createTrait([ci, cl, c13])
    , c1n = Kotlin.createTrait(null)
    , c1o = Kotlin.createTrait(null)
    , c1p = Kotlin.createTrait(null, /** @lends _.org.w3c.dom.events.EventListener.prototype */ {
      handleEvent: {value: function (arg1) {
        noImpl;
      }, writable: true}
    })
    , c1q = Kotlin.createTrait(null)
    , c1r = Kotlin.createClass(Kotlin.Iterator, function () {
      Object.defineProperty(this, 'state', {value: _.kotlin.support.State.NotReady, writable: true});
      Object.defineProperty(this, 'nextValue', {value: null, writable: true});
    }, /** @lends _.kotlin.support.AbstractIterator.prototype */ {
      hasNext: {value: function () {
        _.kotlin.require(this.state !== _.kotlin.support.State.Failed, 'Failed requirement');
        var tmp$0 = this.state, tmp$1;
        if (tmp$0 === _.kotlin.support.State.Done)
          tmp$1 = false;
        else if (tmp$0 === _.kotlin.support.State.Ready)
          tmp$1 = true;
        else
          tmp$1 = this.tryToComputeNext();
        return tmp$1;
      }, writable: true},
      next: {value: function () {
        if (!this.hasNext())
          throw Kotlin.NoSuchElementException();
        this.state = _.kotlin.support.State.NotReady;
        var tmp$0;
        return (tmp$0 = this.nextValue) != null ? tmp$0 : Kotlin.throwNPE();
      }, writable: true},
      peek: {value: function () {
        if (!this.hasNext())
          throw Kotlin.NoSuchElementException();
        var tmp$0;
        return (tmp$0 = this.nextValue) != null ? tmp$0 : Kotlin.throwNPE();
      }},
      tryToComputeNext: {value: function () {
        this.state = _.kotlin.support.State.Failed;
        this.computeNext();
        return this.state === _.kotlin.support.State.Ready;
      }},
      setNext: {value: function (value) {
        this.nextValue = value;
        this.state = _.kotlin.support.State.Ready;
      }},
      done: {value: function () {
        this.state = _.kotlin.support.State.Done;
      }}
    });
    return {ci: ci, c0: c0, cl: cl, c13: c13, c1: c1, c15: c15, c11: c11, c2: c2, cn: cn, c3: c3, c4: c4, c5: c5, c6: c6, ca: ca, c7: c7, c8: c8, c9: c9, cb: cb, cc: cc, cd: cd, ce: ce, cf: cf, cg: cg, ch: ch, cj: cj, ck: ck, cm: cm, co: co, cp: cp, cq: cq, cr: cr, cs: cs, ct: ct, cu: cu, cv: cv, cw: cw, cx: cx, cy: cy, cz: cz, c10: c10, c12: c12, c14: c14, c16: c16, c17: c17, c1g: c1g, c18: c18, c19: c19, c1a: c1a, c1b: c1b, c1c: c1c, c1d: c1d, c1e: c1e, c1f: c1f, c1h: c1h, c1i: c1i, c1j: c1j, c1k: c1k, c1l: c1l, c1m: c1m, c1n: c1n, c1o: c1o, c1p: c1p, c1q: c1q, c1r: c1r};
  }()
  , _ = Object.create(null, {
    kotlin: Kotlin.definePackage(null, {
      Pair: {value: Kotlin.createClass(null, function (first, second) {
        Object.defineProperty(this, 'first', {value: first});
        Object.defineProperty(this, 'second', {value: second});
      }, /** @lends _.kotlin.Pair.prototype */ {
        component1: {value: function () {
          return this.first;
        }},
        component2: {value: function () {
          return this.second;
        }},
        toString: {value: function () {
          return '(' + this.first.toString() + ', ' + this.second.toString() + ')';
        }}
      })},
      Triple: {value: Kotlin.createClass(null, function (first, second, third) {
        Object.defineProperty(this, 'first', {value: first});
        Object.defineProperty(this, 'second', {value: second});
        Object.defineProperty(this, 'third', {value: third});
      }, /** @lends _.kotlin.Triple.prototype */ {
        component1: {value: function () {
          return this.first;
        }},
        component2: {value: function () {
          return this.second;
        }},
        component3: {value: function () {
          return this.third;
        }},
        toString: {value: function () {
          return '(' + this.first.toString() + ', ' + this.second.toString() + ', ' + this.third.toString() + ')';
        }}
      })},
      toString: {value: function ($receiver) {
        return _.kotlin.makeString($receiver, ', ', '[', ']', -1, '...');
      }},
      arrayList: {value: function (values) {
        var list = Kotlin.ArrayList(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var value = tmp$0[tmp$2];
            {
              list.add(value);
            }
          }
        }
        return list;
      }},
      hashSet: {value: function (values) {
        var list = Kotlin.ComplexHashSet();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var value = tmp$0[tmp$2];
            {
              list.add(value);
            }
          }
        }
        return list;
      }},
      map: {value: function ($receiver, transform) {
        return _.kotlin.mapTo($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapValues: {value: function ($receiver, transform) {
        return _.kotlin.mapValuesTo($receiver, Kotlin.ComplexHashMap(0), transform);
      }},
      hashMap: {value: function (values) {
        var answer = Kotlin.ComplexHashMap(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var v = tmp$0[tmp$2];
            {
              answer.put(v.first, v.second);
            }
          }
        }
        return answer;
      }},
      require: {value: function (value, message) {
        if (!value) {
          throw Kotlin.IllegalArgumentException(Kotlin.toString(message));
        }
      }},
      require_0: {value: function (value, lazyMessage) {
        if (!value) {
          var message = lazyMessage();
          throw Kotlin.IllegalArgumentException(message.toString());
        }
      }},
      requireNotNull: {value: function (value, message) {
        if (value == null) {
          throw Kotlin.IllegalArgumentException(Kotlin.toString(message));
        }
         else {
          return value;
        }
      }},
      check: {value: function (value, message) {
        if (!value) {
          throw Kotlin.IllegalStateException(Kotlin.toString(message));
        }
      }},
      check_0: {value: function (value, lazyMessage) {
        if (!value) {
          var message = lazyMessage();
          throw Kotlin.IllegalStateException(message.toString());
        }
      }},
      checkNotNull: {value: function (value, message) {
        if (value == null) {
          throw Kotlin.IllegalStateException(message);
        }
         else {
          return value;
        }
      }},
      all: {value: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any: {value: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find: {value: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filterTo: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNotTo: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNotNullTo: {value: function ($receiver, result) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null)
              result.add(element);
          }
        }
        return result;
      }},
      partition: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      mapTo_0: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMapTo: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach: {value: function ($receiver, operation) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      reduce: {value: function ($receiver, operation) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      groupBy: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      f0: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f0);
            list.add(element);
          }
        }
        return result;
      }},
      drop: {value: function ($receiver, n) {
        return _.kotlin.dropWhile($receiver, _.kotlin.countTo(n));
      }},
      dropWhile: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      takeWhileTo: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection: {value: function ($receiver, result) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse: {value: function ($receiver) {
        var list = _.kotlin.toCollection($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList: {value: function ($receiver) {
        return _.kotlin.toCollection($receiver, Kotlin.LinkedList());
      }},
      toList: {value: function ($receiver) {
        return _.kotlin.toCollection($receiver, Kotlin.ArrayList(0));
      }},
      toSet: {value: function ($receiver) {
        return _.kotlin.toCollection($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet: {value: function ($receiver) {
        return _.kotlin.toCollection($receiver, Kotlin.TreeSet());
      }},
      withIndices: {value: function ($receiver) {
        return _.kotlin.IndexIterator($receiver.iterator());
      }},
      f1: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f1.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      all_0: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_0: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_0: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_0: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_0($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_0: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_0($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_0: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_0: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_0: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_1($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_1: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_0($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_0: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_0: {value: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_0: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_0: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_0: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_0($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      f2: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_0: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f2);
            list.add(element);
          }
        }
        return result;
      }},
      drop_0: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_0($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_0: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_0($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_0: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      take: {value: function ($receiver, n) {
        return _.kotlin.takeWhile($receiver, _.kotlin.countTo(n));
      }},
      takeWhile: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_0($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_0: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_0: {value: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_0: {value: function ($receiver) {
        var list = _.kotlin.toCollection_0($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_0: {value: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, Kotlin.LinkedList());
      }},
      toList_0: {value: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, Kotlin.ArrayList(0));
      }},
      toSet_0: {value: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_0: {value: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, Kotlin.TreeSet());
      }},
      plus: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_0($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_0: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_0($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_1: {value: function ($receiver, collection) {
        return _.kotlin.plus_0($receiver, collection.iterator());
      }},
      withIndices_0: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      f3: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_0: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_0($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f3.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_0: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_0: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_0($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      all_1: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_1: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_1: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_1: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_0: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_1($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_1: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_0: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_1($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_1: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_1: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_1: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_2($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_2: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_0: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_1($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_1: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_1: {value: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_1: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_0: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_1: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_0: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_1: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_1($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      f4: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_1: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f4);
            list.add(element);
          }
        }
        return result;
      }},
      drop_1: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_1($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_1: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_1($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_1: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      take_0: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_0($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_0: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_1($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_1: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_1: {value: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_1: {value: function ($receiver) {
        var list = _.kotlin.toCollection_1($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_1: {value: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, Kotlin.LinkedList());
      }},
      toList_1: {value: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, Kotlin.ArrayList(0));
      }},
      toSet_1: {value: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_1: {value: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, Kotlin.TreeSet());
      }},
      plus_2: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_1($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_3: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_1($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_4: {value: function ($receiver, collection) {
        return _.kotlin.plus_3($receiver, collection.iterator());
      }},
      withIndices_1: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      f5: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_1: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_1($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f5.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_1: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_1: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_1($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      downTo: {value: function ($receiver, to) {
        return _.jet.ByteProgression($receiver, to, -1);
      }},
      downTo_0: {value: function ($receiver, to) {
        return _.jet.CharProgression($receiver.toChar(), to, -1);
      }},
      downTo_1: {value: function ($receiver, to) {
        return _.jet.ShortProgression($receiver, to, -1);
      }},
      downTo_2: {value: function ($receiver, to) {
        return Kotlin.NumberProgression($receiver, to, -1);
      }},
      downTo_3: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      }},
      downTo_4: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to, -1);
      }},
      downTo_5: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_6: {value: function ($receiver, to) {
        return _.jet.CharProgression($receiver, to.toChar(), -1);
      }},
      downTo_7: {value: function ($receiver, to) {
        return _.jet.CharProgression($receiver, to, -1);
      }},
      downTo_8: {value: function ($receiver, to) {
        return _.jet.ShortProgression($receiver.toShort(), to, -1);
      }},
      downTo_9: {value: function ($receiver, to) {
        return Kotlin.NumberProgression($receiver.toInt(), to, -1);
      }},
      downTo_10: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      }},
      downTo_11: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver.toFloat(), to, -1);
      }},
      downTo_12: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver.toDouble(), to, -1.0);
      }},
      downTo_13: {value: function ($receiver, to) {
        return _.jet.ShortProgression($receiver, to, -1);
      }},
      downTo_14: {value: function ($receiver, to) {
        return _.jet.ShortProgression($receiver, to.toShort(), -1);
      }},
      downTo_15: {value: function ($receiver, to) {
        return _.jet.ShortProgression($receiver, to, -1);
      }},
      downTo_16: {value: function ($receiver, to) {
        return Kotlin.NumberProgression($receiver, to, -1);
      }},
      downTo_17: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      }},
      downTo_18: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to, -1);
      }},
      downTo_19: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_20: {value: function ($receiver, to) {
        return Kotlin.NumberProgression($receiver, to, -1);
      }},
      downTo_21: {value: function ($receiver, to) {
        return Kotlin.NumberProgression($receiver, to.toInt(), -1);
      }},
      downTo_22: {value: function ($receiver, to) {
        return Kotlin.NumberProgression($receiver, to, -1);
      }},
      downTo_23: {value: function ($receiver, to) {
        return Kotlin.NumberProgression($receiver, to, -1);
      }},
      downTo_24: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      }},
      downTo_25: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to, -1);
      }},
      downTo_26: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_27: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      }},
      downTo_28: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      }},
      downTo_29: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      }},
      downTo_30: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      }},
      downTo_31: {value: function ($receiver, to) {
        return _.jet.LongProgression($receiver, to, -(1).toLong());
      }},
      downTo_32: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver.toFloat(), to, -1);
      }},
      downTo_33: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver.toDouble(), to, -1.0);
      }},
      downTo_34: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to, -1);
      }},
      downTo_35: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to.toFloat(), -1);
      }},
      downTo_36: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to, -1);
      }},
      downTo_37: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to, -1);
      }},
      downTo_38: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to.toFloat(), -1);
      }},
      downTo_39: {value: function ($receiver, to) {
        return _.jet.FloatProgression($receiver, to, -1);
      }},
      downTo_40: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_41: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_42: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to.toDouble(), -1.0);
      }},
      downTo_43: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_44: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_45: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to.toDouble(), -1.0);
      }},
      downTo_46: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      downTo_47: {value: function ($receiver, to) {
        return _.jet.DoubleProgression($receiver, to, -1.0);
      }},
      all_2: {value: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_2: {value: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_2: {value: function ($receiver, predicate) {
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_2: {value: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_1: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_2($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_2: {value: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_1: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_2($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_2: {value: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNotNull: {value: function ($receiver) {
        return _.kotlin.filterNotNullTo_0($receiver, Kotlin.ArrayList(0));
      }},
      filterNotNullTo_0: {value: function ($receiver, result) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (element != null)
              result.add(element);
          }
        }
        return result;
      }},
      partition_2: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              if (predicate(element)) {
                first.add(element);
              }
               else {
                second.add(element);
              }
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_2: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_3($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_3: {value: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_1: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_2($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_2: {value: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              var list = transform(element);
              {
                var tmp$3 = list.iterator();
                while (tmp$3.hasNext()) {
                  var r = tmp$3.next();
                  result.add(r);
                }
              }
            }
          }
        }
        return result;
      }},
      forEach_2: {value: function ($receiver, operation) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            operation(element);
          }
        }
      }},
      fold_2: {value: function ($receiver, initial, operation) {
        var answer = initial;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_1: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_2: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_1: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_2: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_2($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      f6: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_2: {value: function ($receiver, result, toKey) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              var key = toKey(element);
              var list = _.kotlin.getOrPut(result, key, _.kotlin.f6);
              list.add(element);
            }
          }
        }
        return result;
      }},
      drop_2: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_2($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_2: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_2($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_2: {value: function ($receiver, result, predicate) {
        var start = true;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              if (start && predicate(element)) {
              }
               else {
                start = false;
                result.add(element);
              }
            }
          }
        }
        return result;
      }},
      take_1: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_1($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_1: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_2($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_2: {value: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_2: {value: function ($receiver, result) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            result.add(element);
          }
        }
        return result;
      }},
      reverse_2: {value: function ($receiver) {
        var list = _.kotlin.toCollection_2($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_2: {value: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, Kotlin.LinkedList());
      }},
      toList_2: {value: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, Kotlin.ArrayList(0));
      }},
      toSet_2: {value: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_2: {value: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, Kotlin.TreeSet());
      }},
      requireNoNulls: {value: function ($receiver) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              if (element == null) {
                throw Kotlin.IllegalArgumentException('null element found in ' + $receiver.toString());
              }
            }
          }
        }
        return $receiver != null ? $receiver : Kotlin.throwNPE();
      }},
      plus_5: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_2($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_6: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_2($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_7: {value: function ($receiver, collection) {
        return _.kotlin.plus_6($receiver, collection.iterator());
      }},
      withIndices_2: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      f7: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_2: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_2($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f7.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_2: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              if (++count > 1)
                buffer.append(separator);
              if (limit < 0 || count <= limit) {
                var text = element == null ? 'null' : Kotlin.toString(element);
                buffer.append(text);
              }
               else
                break;
            }
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_2: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_2($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      all_3: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_3: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_3: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_3: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_2: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_3($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_3: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_2: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_3($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_3: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_3: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_3: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_4($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_4: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_2: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_3($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_3: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_3: {value: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_3: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_2: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_3: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_2: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_3: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_3($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      f8: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_3: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f8);
            list.add(element);
          }
        }
        return result;
      }},
      drop_3: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_3($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_3: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_3($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_3: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      take_2: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_2($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_2: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_3($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_3: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_3: {value: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_3: {value: function ($receiver) {
        var list = _.kotlin.toCollection_3($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_3: {value: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, Kotlin.LinkedList());
      }},
      toList_3: {value: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, Kotlin.ArrayList(0));
      }},
      toSet_3: {value: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_3: {value: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, Kotlin.TreeSet());
      }},
      plus_8: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_3($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_9: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_3($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_10: {value: function ($receiver, collection) {
        return _.kotlin.plus_9($receiver, collection.iterator());
      }},
      withIndices_3: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      f9: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_3: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_3($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f9.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_3: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_3: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_3($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      get_size: {value: function ($receiver) {
        return $receiver.size();
      }},
      get_empty: {value: function ($receiver) {
        return $receiver.isEmpty();
      }},
      get_indices: {value: function ($receiver) {
        return Kotlin.NumberRange(0, _.kotlin.get_size($receiver) - 1);
      }},
      get_indices: {value: function ($receiver) {
        return Kotlin.NumberRange(0, $receiver - 1);
      }},
      isNotEmpty_0: {value: function ($receiver) {
        return !$receiver.isEmpty();
      }},
      get_notEmpty: {value: function ($receiver) {
        return _.kotlin.isNotEmpty_0($receiver);
      }},
      orEmpty: {value: function ($receiver) {
        var tmp$0;
        return $receiver != null ? $receiver : (tmp$0 = Kotlin.emptyList()) != null ? tmp$0 : Kotlin.throwNPE();
      }},
      toSortedList: {value: function ($receiver) {
        return _.kotlin.sort(_.kotlin.toCollection($receiver, Kotlin.ArrayList(0)));
      }},
      toSortedList_0: {value: function ($receiver, comparator) {
        return _.kotlin.sort_0(_.kotlin.toList($receiver), comparator);
      }},
      orEmpty_0: {value: function ($receiver) {
        var tmp$0;
        return $receiver != null ? $receiver : (tmp$0 = Kotlin.emptyList()) != null ? tmp$0 : Kotlin.throwNPE();
      }},
      get_first: {value: function ($receiver) {
        return _.kotlin.get_head($receiver);
      }},
      get_last: {value: function ($receiver) {
        var s = _.kotlin.get_size($receiver);
        return s > 0 ? $receiver.get(s - 1) : null;
      }},
      get_lastIndex: {value: function ($receiver) {
        return _.kotlin.get_size($receiver) - 1;
      }},
      get_head: {value: function ($receiver) {
        return $receiver.get(0);
      }},
      get_tail: {value: function ($receiver) {
        return _.kotlin.drop($receiver, 1);
      }},
      all_4: {value: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_4: {value: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_4: {value: function ($receiver, predicate) {
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_4: {value: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_3: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_4($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_4: {value: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_3: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_4($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_4: {value: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_4: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              if (predicate(element)) {
                first.add(element);
              }
               else {
                second.add(element);
              }
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_4: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_5($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_5: {value: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_3: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_4($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_4: {value: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              var list = transform(element);
              {
                var tmp$3 = list.iterator();
                while (tmp$3.hasNext()) {
                  var r = tmp$3.next();
                  result.add(r);
                }
              }
            }
          }
        }
        return result;
      }},
      forEach_4: {value: function ($receiver, operation) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            operation(element);
          }
        }
      }},
      fold_4: {value: function ($receiver, initial, operation) {
        var answer = initial;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_3: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_4: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_3: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_4: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_4($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      fa: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_4: {value: function ($receiver, result, toKey) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              var key = toKey(element);
              var list = _.kotlin.getOrPut(result, key, _.kotlin.fa);
              list.add(element);
            }
          }
        }
        return result;
      }},
      drop_4: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_4($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_4: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_4($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_4: {value: function ($receiver, result, predicate) {
        var start = true;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              if (start && predicate(element)) {
              }
               else {
                start = false;
                result.add(element);
              }
            }
          }
        }
        return result;
      }},
      take_3: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_3($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_3: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_4($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_4: {value: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_4: {value: function ($receiver, result) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            result.add(element);
          }
        }
        return result;
      }},
      reverse_4: {value: function ($receiver) {
        var list = _.kotlin.toCollection_4($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_4: {value: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, Kotlin.LinkedList());
      }},
      toList_4: {value: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, Kotlin.ArrayList(0));
      }},
      toSet_4: {value: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_4: {value: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, Kotlin.TreeSet());
      }},
      plus_11: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_4($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_12: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_4($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_13: {value: function ($receiver, collection) {
        return _.kotlin.plus_12($receiver, collection.iterator());
      }},
      withIndices_4: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      fb: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_4: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_4($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fb.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_4: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            {
              if (++count > 1)
                buffer.append(separator);
              if (limit < 0 || count <= limit) {
                var text = element == null ? 'null' : Kotlin.toString(element);
                buffer.append(text);
              }
               else
                break;
            }
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_4: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_4($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      test: Kotlin.definePackage(function () {
        Object.defineProperty(this, 'asserter', {value: _.kotlin.test.QUnitAsserter(), writable: true});
      }, {
        todo: {value: function (block) {
          Kotlin.println('TODO at ' + block);
        }},
        QUnitAsserter: {value: Kotlin.createClass(classes.c1q, null, /** @lends _.kotlin.test.QUnitAsserter.prototype */ {
          assertTrue: {value: function (message, actual) {
            ok(actual, message);
          }, writable: true},
          assertEquals: {value: function (message, expected, actual) {
            ok(Kotlin.equals(expected, actual), message + '. Expected <' + expected.toString() + '> actual <' + actual.toString() + '>');
          }, writable: true},
          assertNotNull: {value: function (message, actual) {
            ok(actual != null, message);
          }, writable: true},
          assertNull: {value: function (message, actual) {
            ok(actual == null, message);
          }, writable: true},
          fail: {value: function (message) {
            ok(false, message);
          }, writable: true}
        })},
        assertTrue: {value: function (message, block) {
          var actual = block();
          _.kotlin.test.asserter.assertTrue(message, actual);
        }},
        assertTrue_0: {value: function (block) {
          _.kotlin.test.assertTrue(Kotlin.toString(block), block);
        }},
        f0: {value: function (block) {
          return !block();
        }},
        assertNot: {value: function (message, block) {
          _.kotlin.test.assertTrue(message, _.kotlin.test.f0.bind(null, block));
        }},
        assertNot_0: {value: function (block) {
          _.kotlin.test.assertNot(Kotlin.toString(block), block);
        }},
        assertTrue_1: {value: function (actual, message) {
          return _.kotlin.test.assertEquals(true, actual, message);
        }},
        assertFalse: {value: function (actual, message) {
          return _.kotlin.test.assertEquals(false, actual, message);
        }},
        assertEquals: {value: function (expected, actual, message) {
          _.kotlin.test.asserter.assertEquals(message, expected, actual);
        }},
        assertNotNull: {value: function (actual, message) {
          _.kotlin.test.asserter.assertNotNull(message, actual);
          return actual != null ? actual : Kotlin.throwNPE();
        }},
        assertNotNull_0: {value: function (actual, message, block) {
          _.kotlin.test.asserter.assertNotNull(message, actual);
          if (actual != null) {
            block(actual);
          }
        }},
        assertNull: {value: function (actual, message) {
          _.kotlin.test.asserter.assertNull(message, actual);
        }},
        fail: {value: function (message) {
          _.kotlin.test.asserter.fail(message);
        }},
        expect: {value: function (expected, block) {
          _.kotlin.test.expect_0(expected, Kotlin.toString(block), block);
        }},
        expect_0: {value: function (expected, message, block) {
          var actual = block();
          _.kotlin.test.assertEquals(expected, actual, message);
        }},
        fails: {value: function (block) {
          try {
            block();
            _.kotlin.test.asserter.fail('Expected an exception to be thrown');
            return null;
          }
           catch (e) {
            return e;
          }
        }},
        Asserter: {value: classes.c1q}
      }),
      filter_4: {value: function ($receiver, predicate) {
        return _.kotlin.FilterIterator($receiver, predicate);
      }},
      fc: {value: function (predicate, it) {
        return !predicate(it);
      }},
      filterNot_4: {value: function ($receiver, predicate) {
        return _.kotlin.filter_4($receiver, _.kotlin.fc.bind(null, predicate));
      }},
      filterNotNull_0: {value: function ($receiver) {
        return _.kotlin.FilterNotNullIterator($receiver);
      }},
      map_5: {value: function ($receiver, transform) {
        return _.kotlin.MapIterator($receiver, transform);
      }},
      flatMap_4: {value: function ($receiver, transform) {
        return _.kotlin.FlatMapIterator($receiver, transform);
      }},
      fd: {value: function (it) {
        if (it == null)
          throw Kotlin.IllegalArgumentException('null element in iterator ' + $receiver.toString());
        else
          return it;
      }},
      requireNoNulls_0: {value: function ($receiver) {
        return _.kotlin.map_5($receiver, _.kotlin.fd);
      }},
      fe: {value: function (count, it) {
        return --count.v >= 0;
      }},
      take_4: {value: function ($receiver, n) {
        var count = {v: n};
        return _.kotlin.takeWhile_4($receiver, _.kotlin.fe.bind(null, count));
      }},
      takeWhile_4: {value: function ($receiver, predicate) {
        return _.kotlin.TakeWhileIterator($receiver, predicate);
      }},
      plus_14: {value: function ($receiver, element) {
        return _.kotlin.CompositeIterator([$receiver, _.kotlin.SingleIterator(element)]);
      }},
      plus_15: {value: function ($receiver, iterator) {
        return _.kotlin.CompositeIterator([$receiver, iterator]);
      }},
      plus_16: {value: function ($receiver, collection) {
        return _.kotlin.plus_15($receiver, collection.iterator());
      }},
      filter_5: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNot_5: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotNull_1: {value: function ($receiver) {
        return _.kotlin.filterNotNullTo($receiver, Kotlin.ArrayList(0));
      }},
      map_6: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_0($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMap_5: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo($receiver, Kotlin.ArrayList(0), transform);
      }},
      take_5: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_5($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_5: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo($receiver, Kotlin.ArrayList(0), predicate);
      }},
      requireNoNulls_1: {value: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element == null) {
              throw Kotlin.IllegalArgumentException('null element found in ' + $receiver.toString());
            }
          }
        }
        return $receiver != null ? $receiver : Kotlin.throwNPE();
      }},
      plus_17: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_18: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_19: {value: function ($receiver, collection) {
        return _.kotlin.plus_18($receiver, collection.iterator());
      }},
      get_size: {value: function ($receiver) {
        return $receiver.size();
      }},
      get_empty: {value: function ($receiver) {
        return $receiver.isEmpty();
      }},
      set: {value: function ($receiver, key, value) {
        return $receiver.put(key, value);
      }},
      orEmpty_1: {value: function ($receiver) {
        var tmp$0;
        return $receiver != null ? $receiver : (tmp$0 = Kotlin.emptyMap()) != null ? tmp$0 : Kotlin.throwNPE();
      }},
      get_key: {value: function ($receiver) {
        return $receiver.getKey();
      }},
      get_value: {value: function ($receiver) {
        return $receiver.getValue();
      }},
      component1: {value: function ($receiver) {
        return $receiver.getKey();
      }},
      component2: {value: function ($receiver) {
        return $receiver.getValue();
      }},
      getOrElse: {value: function ($receiver, key, defaultValue) {
        if ($receiver.containsKey(key)) {
          var tmp$0;
          return (tmp$0 = $receiver.get(key)) != null ? tmp$0 : Kotlin.throwNPE();
        }
         else {
          return defaultValue();
        }
      }},
      getOrPut: {value: function ($receiver, key, defaultValue) {
        if ($receiver.containsKey(key)) {
          var tmp$0;
          return (tmp$0 = $receiver.get(key)) != null ? tmp$0 : Kotlin.throwNPE();
        }
         else {
          var answer = defaultValue();
          $receiver.put(key, answer);
          return answer;
        }
      }},
      iterator: {value: function ($receiver) {
        var entrySet = $receiver.entrySet();
        return entrySet.iterator();
      }},
      mapTo: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = _.kotlin.iterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      mapValuesTo: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = _.kotlin.iterator($receiver);
          while (tmp$0.hasNext()) {
            var e = tmp$0.next();
            var newValue = transform(e);
            result.put(_.kotlin.get_key(e), newValue);
          }
        }
        return result;
      }},
      putAll: {value: function ($receiver, values) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var v = tmp$0[tmp$2];
            {
              $receiver.put(v.first, v.second);
            }
          }
        }
      }},
      toMap: {value: function ($receiver, map) {
        map.putAll($receiver);
        return map;
      }},
      map_7: {value: function ($receiver, transform) {
        return _.kotlin.mapTo($receiver, Kotlin.ArrayList(_.kotlin.get_size($receiver)), transform);
      }},
      mapValues_0: {value: function ($receiver, transform) {
        return _.kotlin.mapValuesTo($receiver, Kotlin.ComplexHashMap(_.kotlin.get_size($receiver)), transform);
      }},
      all_5: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_5: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_5: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_5: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_6: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_5($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_5: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_6: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_5($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_5: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_5: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_8: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_6($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_6: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_6: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_5($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_5: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_5: {value: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_5: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_4: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_5: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_4: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_5: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_5($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      ff: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_5: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.ff);
            list.add(element);
          }
        }
        return result;
      }},
      drop_5: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_5($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_5: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_5($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_5: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      take_6: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_6($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_6: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_5($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_5: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_5: {value: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_5: {value: function ($receiver) {
        var list = _.kotlin.toCollection_5($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_5: {value: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, Kotlin.LinkedList());
      }},
      toList_5: {value: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, Kotlin.ArrayList(0));
      }},
      toSet_5: {value: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_5: {value: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, Kotlin.TreeSet());
      }},
      plus_20: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_5($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_21: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_5($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_22: {value: function ($receiver, collection) {
        return _.kotlin.plus_21($receiver, collection.iterator());
      }},
      withIndices_5: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      fg: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_5: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_5($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fg.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_5: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_5: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_5($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      dom: Kotlin.definePackage(null, {
        createDocument: {value: function () {
          return document.implementation.createDocument(null, null, null);
        }},
        toXmlString: {value: function ($receiver) {
          return $receiver.outerHTML;
        }},
        toXmlString_0: {value: function ($receiver, xmlDeclaration) {
          return $receiver.outerHTML;
        }},
        eventHandler: {value: function (handler) {
          return _.kotlin.dom.EventListenerHandler(handler);
        }},
        EventListenerHandler: {value: Kotlin.createClass(classes.c1p, function (handler) {
          Object.defineProperty(this, 'handler', {value: handler});
        }, /** @lends _.kotlin.dom.EventListenerHandler.prototype */ {
          handleEvent: {value: function (e) {
            if (e != null) {
              this.handler(e);
            }
          }, writable: true}
        })},
        f0: {value: function (handler, e) {
          if (Kotlin.isType(e, MouseEvent)) {
            handler(e);
          }
        }},
        mouseEventHandler: {value: function (handler) {
          return _.kotlin.dom.eventHandler(_.kotlin.dom.f0.bind(null, handler));
        }},
        on: {value: function ($receiver, name, capture, handler) {
          return _.kotlin.dom.on_0($receiver, name, capture, _.kotlin.dom.eventHandler(handler));
        }},
        on_0: {value: function ($receiver, name, capture, listener) {
          var tmp$0;
          if (Kotlin.isType($receiver, EventTarget)) {
            addEventListener(name, listener, capture);
            tmp$0 = _.kotlin.dom.CloseableEventListener($receiver, listener, name, capture);
          }
           else {
            tmp$0 = null;
          }
          return tmp$0;
        }},
        CloseableEventListener: {value: Kotlin.createClass(Kotlin.Closeable, function (target, listener, name, capture) {
          Object.defineProperty(this, 'target', {value: target});
          Object.defineProperty(this, 'listener', {value: listener});
          Object.defineProperty(this, 'name', {value: name});
          Object.defineProperty(this, 'capture', {value: capture});
        }, /** @lends _.kotlin.dom.CloseableEventListener.prototype */ {
          close: {value: function () {
            this.target.removeEventListener(this.name, this.listener, this.capture);
          }, writable: true}
        })},
        onClick: {value: function ($receiver, capture, handler) {
          return _.kotlin.dom.on_0($receiver, 'click', capture, _.kotlin.dom.mouseEventHandler(handler));
        }},
        onDoubleClick: {value: function ($receiver, capture, handler) {
          return _.kotlin.dom.on_0($receiver, 'dblclick', capture, _.kotlin.dom.mouseEventHandler(handler));
        }},
        emptyElementList: {value: function () {
          return Kotlin.emptyList();
        }},
        emptyNodeList: {value: function () {
          return Kotlin.emptyList();
        }},
        get_text: {value: function ($receiver) {
          return $receiver.textContent;
        }},
        set_text: {value: function ($receiver, value) {
          $receiver.textContent = value;
        }},
        get_childrenText: {value: function ($receiver) {
          var buffer = Kotlin.StringBuilder();
          var nodeList = $receiver.childNodes;
          var i = 0;
          var size = nodeList.length;
          while (i < size) {
            var node = nodeList.item(i);
            if (node != null) {
              if (_.kotlin.dom.isText(node)) {
                buffer.append(node.nodeValue);
              }
            }
            i++;
          }
          return buffer.toString();
        }},
        set_childrenText: {value: function ($receiver, value) {
          var element = $receiver;
          {
            var tmp$0 = _.kotlin.dom.children(element).iterator();
            while (tmp$0.hasNext()) {
              var node = tmp$0.next();
              if (_.kotlin.dom.isText(node)) {
                $receiver.removeChild(node);
              }
            }
          }
          _.kotlin.dom.addText(element, value, null);
        }},
        get_id: {value: function ($receiver) {
          return $receiver.getAttribute('id') !== null ? $receiver.getAttribute('id') : '';
        }},
        set_id: {value: function ($receiver, value) {
          $receiver.setAttribute('id', value);
          $receiver.setIdAttribute('id', true);
        }},
        get_style: {value: function ($receiver) {
          return $receiver.getAttribute('style') !== null ? $receiver.getAttribute('style') : '';
        }},
        set_style: {value: function ($receiver, value) {
          $receiver.setAttribute('style', value);
        }},
        get_classes: {value: function ($receiver) {
          return $receiver.getAttribute('class') !== null ? $receiver.getAttribute('class') : '';
        }},
        set_classes: {value: function ($receiver, value) {
          $receiver.setAttribute('class', value);
        }},
        hasClass: {value: function ($receiver, cssClass) {
          var c = _.kotlin.dom.get_classes($receiver);
          return _.js.matches(c, '(^|.*' + '\\' + 's+)' + cssClass + '(' + '$' + '|' + '\\' + 's+.*)');
        }},
        children: {value: function ($receiver) {
          return _.kotlin.dom.toList($receiver != null ? $receiver.childNodes : null);
        }},
        f1: {value: function (it) {
          return it.nodeType === Node.ELEMENT_NODE;
        }},
        f2: {value: function (it) {
          return it != null ? it : Kotlin.throwNPE();
        }},
        childElements: {value: function ($receiver) {
          return _.kotlin.map_6(_.kotlin.filter_5(_.kotlin.dom.children($receiver), _.kotlin.dom.f1), _.kotlin.dom.f2);
        }},
        f3: {value: function (name, it) {
          return it.nodeType === Node.ELEMENT_NODE && Kotlin.equals(it.nodeName, name);
        }},
        f4: {value: function (it) {
          return it != null ? it : Kotlin.throwNPE();
        }},
        childElements_0: {value: function ($receiver, name) {
          return _.kotlin.map_6(_.kotlin.filter_5(_.kotlin.dom.children($receiver), _.kotlin.dom.f3.bind(null, name)), _.kotlin.dom.f4);
        }},
        get_elements: {value: function ($receiver) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName('*') : null);
        }},
        get_elements: {value: function ($receiver) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName('*') : null);
        }},
        elements: {value: function ($receiver, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName(localName) : null);
        }},
        elements_0: {value: function ($receiver, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName(localName) : null);
        }},
        elements_1: {value: function ($receiver, namespaceUri, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagNameNS(namespaceUri, localName) : null);
        }},
        elements_2: {value: function ($receiver, namespaceUri, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagNameNS(namespaceUri, localName) : null);
        }},
        toList: {value: function ($receiver) {
          var tmp$0;
          if ($receiver == null) {
            tmp$0 = _.kotlin.dom.emptyNodeList();
          }
           else {
            tmp$0 = _.kotlin.dom.NodeListAsList($receiver);
          }
          return tmp$0;
        }},
        toElementList: {value: function ($receiver) {
          var tmp$0;
          if ($receiver == null) {
            tmp$0 = Kotlin.ArrayList(0);
          }
           else {
            tmp$0 = _.kotlin.dom.ElementListAsList($receiver);
          }
          return tmp$0;
        }},
        f5: {value: function (selector, it) {
          return _.kotlin.dom.hasClass(it, selector.substring(1));
        }},
        get: {value: function ($receiver, selector) {
          var root = $receiver != null ? $receiver.documentElement : null;
          var tmp$0;
          if (root != null) {
            if (Kotlin.equals(selector, '*')) {
              tmp$0 = _.kotlin.dom.get_elements($receiver);
            }
             else if (selector.startsWith('.')) {
              tmp$0 = _.kotlin.toList(_.kotlin.filter_5(_.kotlin.dom.get_elements($receiver), _.kotlin.dom.f5.bind(null, selector)));
            }
             else if (selector.startsWith('#')) {
              var id = selector.substring(1);
              var element = $receiver != null ? $receiver.getElementById(id) : null;
              return element != null ? _.kotlin.arrayList([element]) : _.kotlin.dom.emptyElementList();
            }
             else {
              tmp$0 = _.kotlin.dom.elements_0($receiver, selector);
            }
          }
           else {
            tmp$0 = _.kotlin.dom.emptyElementList();
          }
          return tmp$0;
        }},
        f6: {value: function (selector, it) {
          return _.kotlin.dom.hasClass(it, selector.substring(1));
        }},
        get_0: {value: function ($receiver, selector) {
          var tmp$1;
          if (Kotlin.equals(selector, '*')) {
            tmp$1 = _.kotlin.dom.get_elements($receiver);
          }
           else if (selector.startsWith('.')) {
            tmp$1 = _.kotlin.toList(_.kotlin.filter_5(_.kotlin.dom.get_elements($receiver), _.kotlin.dom.f6.bind(null, selector)));
          }
           else if (selector.startsWith('#')) {
            var tmp$0;
            var element = (tmp$0 = $receiver.ownerDocument) != null ? tmp$0.getElementById(selector.substring(1)) : null;
            return element != null ? _.kotlin.arrayList([element]) : _.kotlin.dom.emptyElementList();
          }
           else {
            tmp$1 = _.kotlin.dom.elements($receiver, selector);
          }
          return tmp$1;
        }},
        NodeListAsList: {value: Kotlin.createClass(Kotlin.AbstractList, function $fun(nodeList) {
          Object.defineProperty(this, 'nodeList', {value: nodeList});
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.NodeListAsList.prototype */ {
          get: {value: function (index) {
            var node = this.nodeList.item(index);
            if (node == null) {
              throw new RangeError('NodeList does not contain a node at index: ' + index);
            }
             else {
              return node;
            }
          }, writable: true},
          size: {value: function () {
            return this.nodeList.length;
          }, writable: true}
        })},
        ElementListAsList: {value: Kotlin.createClass(Kotlin.AbstractList, function $fun(nodeList) {
          Object.defineProperty(this, 'nodeList', {value: nodeList});
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.ElementListAsList.prototype */ {
          get: {value: function (index) {
            var node = this.nodeList.item(index);
            if (node == null) {
              throw new RangeError('NodeList does not contain a node at index: ' + index);
            }
             else if (node.nodeType === Node.ELEMENT_NODE) {
              return node != null ? node : Kotlin.throwNPE();
            }
             else {
              throw Kotlin.IllegalArgumentException('Node is not an Element as expected but is ' + node.toString());
            }
          }, writable: true},
          size: {value: function () {
            return this.nodeList.length;
          }, writable: true}
        })},
        clear: {value: function ($receiver) {
          while (true) {
            var child = $receiver.firstChild;
            if (child == null) {
              return;
            }
             else {
              $receiver.removeChild(child);
            }
          }
        }},
        nextSiblings: {value: function ($receiver) {
          return _.kotlin.dom.NextSiblingIterator($receiver);
        }},
        NextSiblingIterator: {value: Kotlin.createClass(classes.c1r, function $fun(node) {
          Object.defineProperty(this, 'node', {value: node, writable: true});
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.NextSiblingIterator.prototype */ {
          computeNext: {value: function () {
            var nextValue = this.node.nextSibling;
            if (nextValue != null) {
              this.setNext(nextValue);
              this.node = nextValue;
            }
             else {
              this.done();
            }
          }, writable: true}
        })},
        previousSiblings: {value: function ($receiver) {
          return _.kotlin.dom.PreviousSiblingIterator($receiver);
        }},
        PreviousSiblingIterator: {value: Kotlin.createClass(classes.c1r, function $fun(node) {
          Object.defineProperty(this, 'node', {value: node, writable: true});
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.PreviousSiblingIterator.prototype */ {
          computeNext: {value: function () {
            var nextValue = this.node.previousSibling;
            if (nextValue != null) {
              this.setNext(nextValue);
              this.node = nextValue;
            }
             else {
              this.done();
            }
          }, writable: true}
        })},
        isText: {value: function ($receiver) {
          var nt = $receiver.nodeType;
          return nt === Node.TEXT_NODE || nt === Node.CDATA_SECTION_NODE;
        }},
        attribute: {value: function ($receiver, name) {
          return $receiver.getAttribute(name) !== null ? $receiver.getAttribute(name) : '';
        }},
        get_head: {value: function ($receiver) {
          return $receiver != null && $receiver.length > 0 ? $receiver.item(0) : null;
        }},
        get_first: {value: function ($receiver) {
          return _.kotlin.dom.get_head($receiver);
        }},
        get_tail: {value: function ($receiver) {
          if ($receiver == null) {
            return null;
          }
           else {
            var s = $receiver.length;
            return s > 0 ? $receiver.item(s - 1) : null;
          }
        }},
        get_last: {value: function ($receiver) {
          return _.kotlin.dom.get_tail($receiver);
        }},
        toXmlString_1: {value: function ($receiver, xmlDeclaration) {
          var tmp$0;
          if ($receiver == null)
            tmp$0 = '';
          else {
            tmp$0 = _.kotlin.dom.nodesToXmlString(_.kotlin.dom.toList($receiver), xmlDeclaration);
          }
          return tmp$0;
        }},
        nodesToXmlString: {value: function (nodes, xmlDeclaration) {
          var builder = Kotlin.StringBuilder();
          {
            var tmp$0 = nodes.iterator();
            while (tmp$0.hasNext()) {
              var n = tmp$0.next();
              builder.append(_.kotlin.dom.toXmlString_0(n, xmlDeclaration));
            }
          }
          return builder.toString();
        }},
        plus: {value: function ($receiver, child) {
          if (child != null) {
            $receiver.appendChild(child);
          }
          return $receiver;
        }},
        plus_0: {value: function ($receiver, text) {
          return _.kotlin.dom.addText($receiver, text, null);
        }},
        plusAssign: {value: function ($receiver, text) {
          return _.kotlin.dom.addText($receiver, text, null);
        }},
        createElement: {value: function ($receiver, name, init) {
          var tmp$0;
          var elem = (tmp$0 = $receiver.createElement(name)) != null ? tmp$0 : Kotlin.throwNPE();
          init(elem);
          return elem;
        }},
        createElement_0: {value: function ($receiver, name, doc, init) {
          var tmp$0;
          var elem = (tmp$0 = _.kotlin.dom.ownerDocument($receiver, doc).createElement(name)) != null ? tmp$0 : Kotlin.throwNPE();
          init(elem);
          return elem;
        }},
        ownerDocument: {value: function ($receiver, doc) {
          var tmp$0;
          if ($receiver.nodeType === Node.DOCUMENT_NODE)
            tmp$0 = $receiver != null ? $receiver : Kotlin.throwNPE();
          else if (doc == null)
            tmp$0 = $receiver.ownerDocument;
          else
            tmp$0 = doc;
          var answer = tmp$0;
          if (answer == null) {
            throw Kotlin.IllegalArgumentException('Element does not have an ownerDocument and none was provided for: ' + $receiver.toString());
          }
           else {
            return answer;
          }
        }},
        addElement: {value: function ($receiver, name, init) {
          var child = _.kotlin.dom.createElement($receiver, name, init);
          $receiver.appendChild(child);
          return child;
        }},
        addElement_0: {value: function ($receiver, name, doc, init) {
          var child = _.kotlin.dom.createElement_0($receiver, name, doc, init);
          $receiver.appendChild(child);
          return child;
        }},
        addText: {value: function ($receiver, text, doc) {
          if (text != null) {
            var tmp$0;
            var child = (tmp$0 = _.kotlin.dom.ownerDocument($receiver, doc).createTextNode(text)) != null ? tmp$0 : Kotlin.throwNPE();
            $receiver.appendChild(child);
          }
          return $receiver;
        }}
      }),
      all_6: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_6: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_6: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_6: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_7: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_6($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_6: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_7: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_6($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_6: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_6: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_9: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_7($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_7: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_7: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_6($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_6: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_6: {value: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_6: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_5: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_6: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_5: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_6: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_6($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      fh: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_6: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fh);
            list.add(element);
          }
        }
        return result;
      }},
      drop_6: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_6($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_6: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_6($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_6: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      take_7: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_7($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_7: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_6($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_6: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_6: {value: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_6: {value: function ($receiver) {
        var list = _.kotlin.toCollection_6($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_6: {value: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, Kotlin.LinkedList());
      }},
      toList_6: {value: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, Kotlin.ArrayList(0));
      }},
      toSet_6: {value: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_6: {value: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, Kotlin.TreeSet());
      }},
      plus_23: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_6($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_24: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_6($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_25: {value: function ($receiver, collection) {
        return _.kotlin.plus_24($receiver, collection.iterator());
      }},
      withIndices_6: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      fi: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_6: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_6($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fi.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_6: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_6: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_6($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      all_7: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_7: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_7: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_7: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_8: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_7($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_7: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_8: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_7($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_7: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_7: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_10: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_8($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_8: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_8: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_7($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_7: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_7: {value: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_7: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_6: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_7: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_6: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_7: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_7($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      fj: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_7: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fj);
            list.add(element);
          }
        }
        return result;
      }},
      drop_7: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_7($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_7: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_7($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_7: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      take_8: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_8($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_8: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_7($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_7: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_7: {value: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_7: {value: function ($receiver) {
        var list = _.kotlin.toCollection_7($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_7: {value: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, Kotlin.LinkedList());
      }},
      toList_7: {value: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, Kotlin.ArrayList(0));
      }},
      toSet_7: {value: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_7: {value: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, Kotlin.TreeSet());
      }},
      plus_26: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_7($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_27: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_7($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_28: {value: function ($receiver, collection) {
        return _.kotlin.plus_27($receiver, collection.iterator());
      }},
      withIndices_7: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      fk: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_7: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_7($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fk.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_7: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_7: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_7($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      iterate: {value: function (nextFunction) {
        return _.kotlin.FunctionIterator(nextFunction);
      }},
      FilterIterator: {value: Kotlin.createClass(classes.c1r, function $fun(iterator, predicate) {
        Object.defineProperty(this, 'iterator', {value: iterator});
        Object.defineProperty(this, 'predicate', {value: predicate});
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.FilterIterator.prototype */ {
        computeNext: {value: function () {
          while (this.iterator.hasNext()) {
            var next = this.iterator.next();
            if (this.predicate(next)) {
              this.setNext(next);
              return;
            }
          }
          this.done();
        }, writable: true}
      })},
      FilterNotNullIterator: {value: Kotlin.createClass(classes.c1r, function $fun(iterator) {
        Object.defineProperty(this, 'iterator', {value: iterator});
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.FilterNotNullIterator.prototype */ {
        computeNext: {value: function () {
          if (this.iterator != null) {
            while (this.iterator.hasNext()) {
              var next = this.iterator.next();
              if (next != null) {
                this.setNext(next);
                return;
              }
            }
          }
          this.done();
        }, writable: true}
      })},
      MapIterator: {value: Kotlin.createClass(classes.c1r, function $fun(iterator, transform) {
        Object.defineProperty(this, 'iterator', {value: iterator});
        Object.defineProperty(this, 'transform', {value: transform});
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.MapIterator.prototype */ {
        computeNext: {value: function () {
          if (this.iterator.hasNext()) {
            this.setNext(this.transform(this.iterator.next()));
          }
           else {
            this.done();
          }
        }, writable: true}
      })},
      FlatMapIterator: {value: Kotlin.createClass(classes.c1r, function $fun(iterator, transform) {
        Object.defineProperty(this, 'iterator', {value: iterator});
        Object.defineProperty(this, 'transform', {value: transform});
        $fun.baseInitializer.call(this);
        Object.defineProperty(this, 'transformed', {value: _.kotlin.iterate(function () {
          return null;
        }), writable: true});
      }, /** @lends _.kotlin.FlatMapIterator.prototype */ {
        computeNext: {value: function () {
          while (true) {
            if (this.transformed.hasNext()) {
              this.setNext(this.transformed.next());
              return;
            }
            if (this.iterator.hasNext()) {
              this.transformed = this.transform(this.iterator.next());
            }
             else {
              this.done();
              return;
            }
          }
        }, writable: true}
      })},
      TakeWhileIterator: {value: Kotlin.createClass(classes.c1r, function $fun(iterator, predicate) {
        Object.defineProperty(this, 'iterator', {value: iterator});
        Object.defineProperty(this, 'predicate', {value: predicate});
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.TakeWhileIterator.prototype */ {
        computeNext: {value: function () {
          if (this.iterator.hasNext()) {
            var item = this.iterator.next();
            if (this.predicate(item)) {
              this.setNext(item);
              return;
            }
          }
          this.done();
        }, writable: true}
      })},
      FunctionIterator: {value: Kotlin.createClass(classes.c1r, function $fun(nextFunction) {
        Object.defineProperty(this, 'nextFunction', {value: nextFunction});
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.FunctionIterator.prototype */ {
        computeNext: {value: function () {
          var next = this.nextFunction();
          if (next == null) {
            this.done();
          }
           else {
            this.setNext(next);
          }
        }, writable: true}
      })},
      CompositeIterator: {value: Kotlin.createClass(classes.c1r, function $fun(iterators) {
        $fun.baseInitializer.call(this);
        Object.defineProperty(this, 'iteratorsIter', {value: Kotlin.arrayIterator(iterators)});
        Object.defineProperty(this, 'currentIter', {value: null, writable: true});
      }, /** @lends _.kotlin.CompositeIterator.prototype */ {
        computeNext: {value: function () {
          while (true) {
            if (this.currentIter == null) {
              if (this.iteratorsIter.hasNext()) {
                this.currentIter = this.iteratorsIter.next();
              }
               else {
                this.done();
                return;
              }
            }
            var iter = this.currentIter;
            if (iter != null) {
              if (iter.hasNext()) {
                this.setNext(iter.next());
                return;
              }
               else {
                this.currentIter = null;
              }
            }
          }
        }, writable: true}
      })},
      SingleIterator: {value: Kotlin.createClass(classes.c1r, function $fun(value) {
        Object.defineProperty(this, 'value', {value: value});
        $fun.baseInitializer.call(this);
        Object.defineProperty(this, 'first', {value: true, writable: true});
      }, /** @lends _.kotlin.SingleIterator.prototype */ {
        computeNext: {value: function () {
          if (this.first) {
            this.first = false;
            this.setNext(this.value);
          }
           else {
            this.done();
          }
        }, writable: true}
      })},
      IndexIterator: {value: Kotlin.createClass(Kotlin.Iterator, function (iterator) {
        Object.defineProperty(this, 'iterator', {value: iterator});
        Object.defineProperty(this, 'index', {value: 0, writable: true});
      }, /** @lends _.kotlin.IndexIterator.prototype */ {
        next: {value: function () {
          var tmp$0, tmp$1;
          return _.kotlin.Pair((tmp$0 = this.index, tmp$1 = tmp$0, this.index = tmp$0 + 1, tmp$1), this.iterator.next());
        }, writable: true},
        hasNext: {value: function () {
          return this.iterator.hasNext();
        }, writable: true}
      })},
      all_8: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_8: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_8: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_8: {value: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filter_9: {value: function ($receiver, predicate) {
        return _.kotlin.filterTo_8($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterTo_8: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNot_9: {value: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_8($receiver, Kotlin.ArrayList(0), predicate);
      }},
      filterNotTo_8: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      partition_8: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      map_11: {value: function ($receiver, transform) {
        return _.kotlin.mapTo_9($receiver, Kotlin.ArrayList(0), transform);
      }},
      mapTo_9: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMap_9: {value: function ($receiver, transform) {
        return _.kotlin.flatMapTo_8($receiver, Kotlin.ArrayList(0), transform);
      }},
      flatMapTo_8: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_8: {value: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_8: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      foldRight_7: {value: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      reduce_8: {value: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      reduceRight_7: {value: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      }},
      groupBy_8: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_8($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      fl: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_8: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fl);
            list.add(element);
          }
        }
        return result;
      }},
      drop_8: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_8($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_8: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_8($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_8: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      take_9: {value: function ($receiver, n) {
        return _.kotlin.takeWhile_9($receiver, _.kotlin.countTo(n));
      }},
      takeWhile_9: {value: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_8($receiver, Kotlin.ArrayList(0), predicate);
      }},
      takeWhileTo_8: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_8: {value: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_8: {value: function ($receiver) {
        var list = _.kotlin.toCollection_8($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_8: {value: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, Kotlin.LinkedList());
      }},
      toList_8: {value: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, Kotlin.ArrayList(0));
      }},
      toSet_8: {value: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_8: {value: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, Kotlin.TreeSet());
      }},
      plus_29: {value: function ($receiver, element) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_8($receiver, answer);
        answer.add(element);
        return answer;
      }},
      plus_30: {value: function ($receiver, iterator) {
        var answer = Kotlin.ArrayList(0);
        _.kotlin.toCollection_8($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      }},
      plus_31: {value: function ($receiver, collection) {
        return _.kotlin.plus_30($receiver, collection.iterator());
      }},
      withIndices_8: {value: function ($receiver) {
        return _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      }},
      fm: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_8: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_8($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fm.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_8: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_8: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_8($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      trim: {value: function ($receiver, text) {
        return _.kotlin.trimTrailing(_.kotlin.trimLeading($receiver, text), text);
      }},
      trim_0: {value: function ($receiver, prefix, postfix) {
        return _.kotlin.trimTrailing(_.kotlin.trimLeading($receiver, prefix), postfix);
      }},
      trimLeading: {value: function ($receiver, prefix) {
        var answer = $receiver;
        if (answer.startsWith(prefix)) {
          answer = answer.substring(prefix.length);
        }
        return answer;
      }},
      trimTrailing: {value: function ($receiver, postfix) {
        var answer = $receiver;
        if (answer.endsWith(postfix)) {
          answer = answer.substring(0, $receiver.length - postfix.length);
        }
        return answer;
      }},
      isNotEmpty: {value: function ($receiver) {
        return $receiver != null && $receiver.length > 0;
      }},
      iterator_0: {value: function ($receiver) {
        return Kotlin.createObject(_.jet.CharIterator, function $fun() {
          $fun.baseInitializer.call(this);
          Object.defineProperty(this, 'index', {value: 0, writable: true, enumerable: true});
        }, {
          nextChar: {value: function () {
            var tmp$0, tmp$1;
            return $receiver.get((tmp$0 = this.index, tmp$1 = tmp$0, this.index = tmp$0 + 1, tmp$1));
          }, writable: true, enumerable: true},
          hasNext: {value: function () {
            return this.index < $receiver.length;
          }, writable: true, enumerable: true}
        });
      }},
      orEmpty_2: {value: function ($receiver) {
        return $receiver !== null ? $receiver : '';
      }},
      get_size: {value: function ($receiver) {
        return $receiver.length;
      }},
      count_9: {value: function ($receiver, predicate) {
        var answer = 0;
        {
          var tmp$0 = _.kotlin.iterator_0($receiver);
          while (tmp$0.hasNext()) {
            var c = tmp$0.next();
            if (predicate(c)) {
              answer++;
            }
          }
        }
        return answer;
      }},
      count_10: {value: function ($receiver) {
        if (Kotlin.isType($receiver, _.jet.Collection)) {
          return $receiver.size();
        }
        var number = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var elem = tmp$0.next();
            ++number;
          }
        }
        return number;
      }},
      fn: {value: function (count, n, it) {
        ++count.v;
        return count.v <= n;
      }},
      countTo: {value: function (n) {
        var count = {v: 0};
        return _.kotlin.fn.bind(null, count, n);
      }},
      first: {value: function ($receiver) {
        if (Kotlin.isType($receiver, _.jet.List)) {
          return _.kotlin.first($receiver);
        }
        return $receiver.iterator().next();
      }},
      containsItem: {value: function ($receiver, item) {
        if (Kotlin.isType($receiver, Kotlin.AbstractCollection)) {
          return $receiver.contains(item);
        }
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var elem = tmp$0.next();
            if (Kotlin.equals(elem, item)) {
              return true;
            }
          }
        }
        return false;
      }},
      sort: {value: function ($receiver) {
        var list = _.kotlin.toCollection($receiver, Kotlin.ArrayList(0));
        Kotlin.collectionsSort(list);
        return list;
      }},
      sort_0: {value: function ($receiver, comparator) {
        var list = _.kotlin.toCollection($receiver, Kotlin.ArrayList(0));
        Kotlin.collectionsSort(list, comparator);
        return list;
      }},
      all_9: {value: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      }},
      any_9: {value: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      }},
      count_11: {value: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      }},
      find_9: {value: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      }},
      filterTo_9: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNotTo_9: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      }},
      filterNotNullTo_1: {value: function ($receiver, result) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null)
              result.add(element);
          }
        }
        return result;
      }},
      partition_9: {value: function ($receiver, predicate) {
        var first = Kotlin.ArrayList(0);
        var second = Kotlin.ArrayList(0);
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return _.kotlin.Pair(first, second);
      }},
      mapTo_10: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      }},
      flatMapTo_9: {value: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      }},
      forEach_9: {value: function ($receiver, operation) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      }},
      fold_9: {value: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      }},
      reduce_9: {value: function ($receiver, operation) {
        var iterator = $receiver;
        if (!iterator.hasNext()) {
          throw Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      }},
      groupBy_9: {value: function ($receiver, toKey) {
        return _.kotlin.groupByTo_9($receiver, Kotlin.ComplexHashMap(0), toKey);
      }},
      fo: {value: function () {
        return Kotlin.ArrayList(0);
      }},
      groupByTo_9: {value: function ($receiver, result, toKey) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fo);
            list.add(element);
          }
        }
        return result;
      }},
      drop_9: {value: function ($receiver, n) {
        return _.kotlin.dropWhile_9($receiver, _.kotlin.countTo(n));
      }},
      dropWhile_9: {value: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_9($receiver, Kotlin.ArrayList(0), predicate);
      }},
      dropWhileTo_9: {value: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      }},
      takeWhileTo_9: {value: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      }},
      toCollection_9: {value: function ($receiver, result) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      }},
      reverse_9: {value: function ($receiver) {
        var list = _.kotlin.toCollection_9($receiver, Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      }},
      toLinkedList_9: {value: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, Kotlin.LinkedList());
      }},
      toList_9: {value: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, Kotlin.ArrayList(0));
      }},
      toSet_9: {value: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, Kotlin.LinkedHashSet());
      }},
      toSortedSet_9: {value: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, Kotlin.TreeSet());
      }},
      withIndices_9: {value: function ($receiver) {
        return _.kotlin.IndexIterator($receiver);
      }},
      fp: {value: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      }},
      sortBy_9: {value: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_9($receiver, Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fp.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      }},
      appendString_9: {value: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      }},
      makeString_9: {value: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = Kotlin.StringBuilder();
        _.kotlin.appendString_9($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      }},
      isNotEmpty_1: {value: function ($receiver) {
        return !_.kotlin.isEmpty($receiver);
      }},
      isEmpty: {value: function ($receiver) {
        return $receiver.length === 0;
      }},
      orEmpty_3: {value: function ($receiver) {
        return $receiver != null ? $receiver : [];
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      iterator_1: {value: function ($receiver) {
        return Kotlin.createObject(Kotlin.Iterator, null, {
          hasNext: {value: function () {
            return $receiver.hasMoreElements();
          }, writable: true, enumerable: true},
          next: {value: function () {
            return $receiver.nextElement();
          }, writable: true, enumerable: true}
        });
      }},
      toArrayList: {value: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, Kotlin.ArrayList(0));
      }},
      toHashSet: {value: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, Kotlin.ComplexHashSet());
      }},
      to: {value: function ($receiver, that) {
        return _.kotlin.Pair($receiver, that);
      }},
      run: {value: function (f) {
        return f();
      }},
      with: {value: function (receiver, f) {
        return f(receiver);
      }},
      let: {value: function ($receiver, f) {
        return f($receiver);
      }},
      support: Kotlin.definePackage(function () {
        Object.defineProperty(this, 'State', {value: Kotlin.createObject(null, function () {
          Object.defineProperty(this, 'Ready', {value: 0});
          Object.defineProperty(this, 'NotReady', {value: 1});
          Object.defineProperty(this, 'Done', {value: 2});
          Object.defineProperty(this, 'Failed', {value: 3});
        })});
      }, {
        AbstractIterator: {value: classes.c1r}
      })
    }),
    org: Kotlin.definePackage(null, {
      kevoree: Kotlin.definePackage(null, {
        loader: Kotlin.definePackage(null, {
          XMIModelLoader: {value: Kotlin.createClass(classes.c6, function $fun() {
            $fun.baseInitializer.call(this);
            Object.defineProperty(this, 'factory', {value: _.org.kevoree.factory.MainFactory(), writable: true});
          })},
          JSONModelLoader: {value: Kotlin.createClass(classes.cb, function $fun() {
            $fun.baseInitializer.call(this);
            Object.defineProperty(this, 'factory', {value: _.org.kevoree.factory.MainFactory(), writable: true});
          })}
        }),
        DeployUnit: {value: classes.c0},
        ContainerNode: {value: classes.c1},
        MessagePortType: {value: classes.c2},
        GroupType: {value: classes.c3},
        NamedElement: {value: classes.cl},
        Wire: {value: classes.cm},
        LifeCycleTypeDefinition: {value: classes.cn},
        Repository: {value: classes.co},
        NetworkProperty: {value: classes.cp},
        ServicePortType: {value: classes.cq},
        ChannelType: {value: classes.cr},
        AdaptationPrimitiveTypeRef: {value: classes.cs},
        ContainerRoot: {value: classes.ct},
        Channel: {value: classes.cu},
        TypedElement: {value: classes.cw},
        Parameter: {value: classes.cx},
        NodeNetwork: {value: classes.cy},
        NodeLink: {value: classes.cz},
        MBinding: {value: classes.c10},
        PortType: {value: classes.c11},
        Operation: {value: classes.c12},
        Instance: {value: classes.c13},
        NodeType: {value: classes.c14},
        TypeDefinition: {value: classes.c15},
        PortTypeRef: {value: classes.c16},
        DictionaryAttribute: {value: classes.c17},
        CompositeType: {value: classes.c18},
        KevoreeFactory: {value: classes.c19},
        DictionaryValue: {value: classes.c1a},
        PortTypeMapping: {value: classes.c1b},
        Group: {value: classes.c1c},
        ExtraFonctionalProperty: {value: classes.c1d},
        DictionaryType: {value: classes.c1e},
        Namespace: {value: classes.c1f},
        ComponentType: {value: classes.c1g},
        AdaptationPrimitiveType: {value: classes.c1h},
        TypeLibrary: {value: classes.c1i},
        Port: {value: classes.c1j},
        IntegrationPattern: {value: classes.c1k},
        Dictionary: {value: classes.c1l},
        ComponentInstance: {value: classes.c1m},
        impl: Kotlin.definePackage(null, {
          CompositeTypeImpl: {value: Kotlin.createClass([classes.cv, classes.c18], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$factoryBean', {value: null, writable: true});
            Object.defineProperty(this, '$bean', {value: null, writable: true});
            Object.defineProperty(this, '$abstract', {value: null, writable: true});
            Object.defineProperty(this, '$startMethod', {value: null, writable: true});
            Object.defineProperty(this, '$stopMethod', {value: null, writable: true});
            Object.defineProperty(this, '$updateMethod', {value: null, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$dictionaryType', {value: null, writable: true});
            Object.defineProperty(this, '_superTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '_required', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllRequiredCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_integrationPatterns', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllIntegrationPatternsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '$extraFonctionalProperties', {value: null, writable: true});
            Object.defineProperty(this, '_provided', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllProvidedCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_childs', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '_wires', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllWiresCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.CompositeTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._required) != null ? tmp$2.clear() : null;
              (tmp$3 = this._integrationPatterns) != null ? tmp$3.clear() : null;
              this.extraFonctionalProperties = null;
              (tmp$4 = this._provided) != null ? tmp$4.clear() : null;
              (tmp$5 = this._childs) != null ? tmp$5.clear() : null;
              (tmp$6 = this._wires) != null ? tmp$6.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            }},
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            }},
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            }},
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            }},
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            }},
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            }},
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: {value: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            }},
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            doAddSuperTypes: {value: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            }},
            addSuperTypes: {value: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            }, writable: true},
            addAllSuperTypes: {value: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            }, writable: true},
            internal_addSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            internal_addAllSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            removeSuperTypes: {value: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            }, writable: true},
            removeAllSuperTypes: {value: function () {
              this.internal_removeAllSuperTypes(true, true);
            }, writable: true},
            internal_removeSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            internal_removeAllSuperTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            }},
            required: {
              get: function () {
                return _.kotlin.toList(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: {value: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            }},
            doAddRequired: {value: function (requiredP) {
              var _key_ = (requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey(_key_)) {
                this._required.put(_key_, requiredP);
                (requiredP != null ? requiredP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
              }
            }},
            addRequired: {value: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
            }, writable: true},
            addAllRequired: {value: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
            }, writable: true},
            internal_addRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            }},
            internal_addAllRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            }},
            removeRequired: {value: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
            }, writable: true},
            removeAllRequired: {value: function () {
              this.internal_removeAllRequired(true, true);
            }, writable: true},
            internal_removeRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey())) {
                this._required.remove((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey());
                ((requiredP != null ? requiredP : Kotlin.throwNPE()) != null ? requiredP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            }},
            internal_removeAllRequired: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.required) != null ? tmp$0 : Kotlin.throwNPE();
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            }},
            integrationPatterns: {
              get: function () {
                return _.kotlin.toList(this._integrationPatterns.values());
              },
              set: function (integrationPatternsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (integrationPatternsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_integrationPatterns(integrationPatternsP, true, true);
              }
            },
            internal_integrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._integrationPatterns.values(), integrationPatternsP)) {
                this._integrationPatterns.clear();
                {
                  var tmp$0 = integrationPatternsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._integrationPatterns.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_integrationPatterns, el), _.org.kevoree.util.Constants.Ref_integrationPatterns);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
                }
              }
            }},
            doAddIntegrationPatterns: {value: function (integrationPatternsP) {
              var _key_ = (integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._integrationPatterns.containsKey(_key_)) {
                this._integrationPatterns.put(_key_, integrationPatternsP);
                (integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP), _.org.kevoree.util.Constants.Ref_integrationPatterns);
              }
            }},
            addIntegrationPatterns: {value: function (integrationPatternsP) {
              this.internal_addIntegrationPatterns(integrationPatternsP, true, true);
            }, writable: true},
            addAllIntegrationPatterns: {value: function (integrationPatternsP) {
              this.internal_addAllIntegrationPatterns(integrationPatternsP, true, true);
            }, writable: true},
            internal_addIntegrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddIntegrationPatterns(integrationPatternsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
              }
            }},
            internal_addAllIntegrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = integrationPatternsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddIntegrationPatterns(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = integrationPatternsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddIntegrationPatterns(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
              }
            }},
            removeIntegrationPatterns: {value: function (integrationPatternsP) {
              this.internal_removeIntegrationPatterns(integrationPatternsP, true, true);
            }, writable: true},
            removeAllIntegrationPatterns: {value: function () {
              this.internal_removeAllIntegrationPatterns(true, true);
            }, writable: true},
            internal_removeIntegrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._integrationPatterns.size() !== 0 && this._integrationPatterns.containsKey((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey())) {
                this._integrationPatterns.remove((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey());
                ((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()) != null ? integrationPatternsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllIntegrationPatternsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
                }
              }
            }},
            internal_removeAllIntegrationPatterns: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllIntegrationPatternsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.integrationPatterns) != null ? tmp$0 : Kotlin.throwNPE();
              this._integrationPatterns.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, temp_els));
                this.removeAllIntegrationPatternsCurrentlyProcessing = false;
              }
            }},
            extraFonctionalProperties: {
              get: function () {
                return this.$extraFonctionalProperties;
              },
              set: function (extraFonctionalPropertiesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_extraFonctionalProperties(extraFonctionalPropertiesP, true, true);
              }
            },
            internal_extraFonctionalProperties: {value: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$extraFonctionalProperties, extraFonctionalPropertiesP)) {
                if (this.$extraFonctionalProperties != null) {
                  var tmp$0;
                  (((tmp$0 = this.$extraFonctionalProperties) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (extraFonctionalPropertiesP != null) {
                  (extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                }
                this.$extraFonctionalProperties = extraFonctionalPropertiesP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
                }
              }
            }},
            provided: {
              get: function () {
                return _.kotlin.toList(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: {value: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            }},
            doAddProvided: {value: function (providedP) {
              var _key_ = (providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey(_key_)) {
                this._provided.put(_key_, providedP);
                (providedP != null ? providedP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
              }
            }},
            addProvided: {value: function (providedP) {
              this.internal_addProvided(providedP, true, true);
            }, writable: true},
            addAllProvided: {value: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
            }, writable: true},
            internal_addProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            }},
            internal_addAllProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            }},
            removeProvided: {value: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
            }, writable: true},
            removeAllProvided: {value: function () {
              this.internal_removeAllProvided(true, true);
            }, writable: true},
            internal_removeProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey())) {
                this._provided.remove((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey());
                ((providedP != null ? providedP : Kotlin.throwNPE()) != null ? providedP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            }},
            internal_removeAllProvided: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.provided) != null ? tmp$0 : Kotlin.throwNPE();
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            }},
            childs: {
              get: function () {
                return _.kotlin.toList(this._childs.values());
              },
              set: function (childsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (childsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_childs(childsP, true, true);
              }
            },
            internal_childs: {value: function (childsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._childs.values(), childsP)) {
                this._childs.clear();
                {
                  var tmp$0 = childsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._childs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, childsP));
                }
              }
            }},
            doAddChilds: {value: function (childsP) {
              var _key_ = (childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._childs.containsKey(_key_)) {
                this._childs.put(_key_, childsP);
              }
            }},
            addChilds: {value: function (childsP) {
              this.internal_addChilds(childsP, true, true);
            }, writable: true},
            addAllChilds: {value: function (childsP) {
              this.internal_addAllChilds(childsP, true, true);
            }, writable: true},
            internal_addChilds: {value: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddChilds(childsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, childsP));
              }
            }},
            internal_addAllChilds: {value: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = childsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddChilds(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = childsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddChilds(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, childsP));
              }
            }},
            removeChilds: {value: function (childsP) {
              this.internal_removeChilds(childsP, true, true);
            }, writable: true},
            removeAllChilds: {value: function () {
              this.internal_removeAllChilds(true, true);
            }, writable: true},
            internal_removeChilds: {value: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._childs.size() !== 0 && this._childs.containsKey((childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey())) {
                this._childs.remove((childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, childsP));
                }
              }
            }},
            internal_removeAllChilds: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.childs) != null ? tmp$0 : Kotlin.throwNPE();
              this._childs.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, temp_els));
              }
            }},
            wires: {
              get: function () {
                return _.kotlin.toList(this._wires.values());
              },
              set: function (wiresP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (wiresP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_wires(wiresP, true, true);
              }
            },
            internal_wires: {value: function (wiresP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._wires.values(), wiresP)) {
                this._wires.clear();
                {
                  var tmp$0 = wiresP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._wires.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_wires, el), _.org.kevoree.util.Constants.Ref_wires);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, wiresP));
                }
              }
            }},
            doAddWires: {value: function (wiresP) {
              var _key_ = (wiresP != null ? wiresP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._wires.containsKey(_key_)) {
                this._wires.put(_key_, wiresP);
                (wiresP != null ? wiresP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_wires, wiresP), _.org.kevoree.util.Constants.Ref_wires);
              }
            }},
            addWires: {value: function (wiresP) {
              this.internal_addWires(wiresP, true, true);
            }, writable: true},
            addAllWires: {value: function (wiresP) {
              this.internal_addAllWires(wiresP, true, true);
            }, writable: true},
            internal_addWires: {value: function (wiresP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddWires(wiresP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, wiresP));
              }
            }},
            internal_addAllWires: {value: function (wiresP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = wiresP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddWires(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = wiresP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddWires(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, wiresP));
              }
            }},
            removeWires: {value: function (wiresP) {
              this.internal_removeWires(wiresP, true, true);
            }, writable: true},
            removeAllWires: {value: function () {
              this.internal_removeAllWires(true, true);
            }, writable: true},
            internal_removeWires: {value: function (wiresP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._wires.size() !== 0 && this._wires.containsKey((wiresP != null ? wiresP : Kotlin.throwNPE()).internalGetKey())) {
                this._wires.remove((wiresP != null ? wiresP : Kotlin.throwNPE()).internalGetKey());
                ((wiresP != null ? wiresP : Kotlin.throwNPE()) != null ? wiresP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllWiresCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, wiresP));
                }
              }
            }},
            internal_removeAllWires: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllWiresCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.wires) != null ? tmp$0 : Kotlin.throwNPE();
              this._wires.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, temp_els));
                this.removeAllWiresCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRequired();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._required.size() !== 0 && this._required.containsKey(value)) {
                    var obj_1 = this._required.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._required.remove(value);
                    this._required.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_integrationPatterns) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllIntegrationPatterns();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._integrationPatterns.size() !== 0 && this._integrationPatterns.containsKey(value)) {
                    var obj_2 = this._integrationPatterns.get(value);
                    var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_2 == null) {
                      throw new Error('Key newed to null ' + obj_2);
                    }
                    this._integrationPatterns.remove(value);
                    this._integrationPatterns.put(objNewKey_2, obj_2);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_extraFonctionalProperties(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_extraFonctionalProperties(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_extraFonctionalProperties(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllProvided();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._provided.size() !== 0 && this._provided.containsKey(value)) {
                    var obj_3 = this._provided.get(value);
                    var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_3 == null) {
                      throw new Error('Key newed to null ' + obj_3);
                    }
                    this._provided.remove(value);
                    this._provided.put(objNewKey_3, obj_3);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_childs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllChilds();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._childs.size() !== 0 && this._childs.containsKey(value)) {
                    var obj_4 = this._childs.get(value);
                    var objNewKey_4 = (obj_4 != null ? obj_4 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_4 == null) {
                      throw new Error('Key newed to null ' + obj_4);
                    }
                    this._childs.remove(value);
                    this._childs.put(objNewKey_4, obj_4);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_wires) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addWires(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllWires(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeWires(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllWires();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._wires.size() !== 0 && this._wires.containsKey(value)) {
                    var obj_5 = this._wires.get(value);
                    var objNewKey_5 = (obj_5 != null ? obj_5 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_5 == null) {
                      throw new Error('Key newed to null ' + obj_5);
                    }
                    this._wires.remove(value);
                    this._wires.put(objNewKey_5, obj_5);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findSuperTypesByID: {value: function (key) {
              return this._superTypes.get(key);
            }, writable: true},
            findRequiredByID: {value: function (key) {
              return this._required.get(key);
            }, writable: true},
            findIntegrationPatternsByID: {value: function (key) {
              return this._integrationPatterns.get(key);
            }, writable: true},
            findProvidedByID: {value: function (key) {
              return this._provided.get(key);
            }, writable: true},
            findChildsByID: {value: function (key) {
              return this._childs.get(key);
            }, writable: true},
            findWiresByID: {value: function (key) {
              return this._wires.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                return this.findRequiredByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_integrationPatterns) {
                return this.findIntegrationPatternsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                var objFound_0 = this.extraFonctionalProperties;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                return this.findProvidedByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_childs) {
                return this.findChildsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_wires) {
                return this.findWiresByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$0 = this._required.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._required.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_integrationPatterns, _.org.kevoree.util.Constants.org_kevoree_IntegrationPattern);
                {
                  var tmp$1 = this._integrationPatterns.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._integrationPatterns.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_integrationPatterns);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_integrationPatterns);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties, _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty);
                this.internal_visit(visitor, this.extraFonctionalProperties, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$2 = this._provided.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._provided.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_wires, _.org.kevoree.util.Constants.org_kevoree_Wire);
                {
                  var tmp$3 = this._wires.keySet().iterator();
                  while (tmp$3.hasNext()) {
                    var KMFLoopEntryKey_2 = tmp$3.next();
                    this.internal_visit(visitor, this._wires.get(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_wires);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_wires);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$4 = this._deployUnits.keySet().iterator();
                  while (tmp$4.hasNext()) {
                    var KMFLoopEntryKey_3 = tmp$4.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$5 = this._superTypes.keySet().iterator();
                  while (tmp$5.hasNext()) {
                    var KMFLoopEntryKey_4 = tmp$5.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_4), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_childs, _.org.kevoree.util.Constants.org_kevoree_ComponentType);
                {
                  var tmp$6 = this._childs.keySet().iterator();
                  while (tmp$6.hasNext()) {
                    var KMFLoopEntryKey_5 = tmp$6.next();
                    this.internal_visit(visitor, this._childs.get(KMFLoopEntryKey_5), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_childs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_childs);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_CompositeType;
            }, writable: true}
          })},
          DictionaryTypeImpl: {value: Kotlin.createClass([classes.cv, classes.c1e], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_attributes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllAttributesCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_defaultValues', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllDefaultValuesCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.DictionaryTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1;
              (tmp$0 = this._attributes) != null ? tmp$0.clear() : null;
              (tmp$1 = this._defaultValues) != null ? tmp$1.clear() : null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            attributes: {
              get: function () {
                return _.kotlin.toList(this._attributes.values());
              },
              set: function (attributesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (attributesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_attributes(attributesP, true, true);
              }
            },
            internal_attributes: {value: function (attributesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._attributes.values(), attributesP)) {
                this._attributes.clear();
                {
                  var tmp$0 = attributesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._attributes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_attributes, el), _.org.kevoree.util.Constants.Ref_attributes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP));
                }
              }
            }},
            doAddAttributes: {value: function (attributesP) {
              var _key_ = (attributesP != null ? attributesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._attributes.containsKey(_key_)) {
                this._attributes.put(_key_, attributesP);
                (attributesP != null ? attributesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_attributes, attributesP), _.org.kevoree.util.Constants.Ref_attributes);
              }
            }},
            addAttributes: {value: function (attributesP) {
              this.internal_addAttributes(attributesP, true, true);
            }, writable: true},
            addAllAttributes: {value: function (attributesP) {
              this.internal_addAllAttributes(attributesP, true, true);
            }, writable: true},
            internal_addAttributes: {value: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddAttributes(attributesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP));
              }
            }},
            internal_addAllAttributes: {value: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = attributesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddAttributes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = attributesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddAttributes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP));
              }
            }},
            removeAttributes: {value: function (attributesP) {
              this.internal_removeAttributes(attributesP, true, true);
            }, writable: true},
            removeAllAttributes: {value: function () {
              this.internal_removeAllAttributes(true, true);
            }, writable: true},
            internal_removeAttributes: {value: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._attributes.size() !== 0 && this._attributes.containsKey((attributesP != null ? attributesP : Kotlin.throwNPE()).internalGetKey())) {
                this._attributes.remove((attributesP != null ? attributesP : Kotlin.throwNPE()).internalGetKey());
                ((attributesP != null ? attributesP : Kotlin.throwNPE()) != null ? attributesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllAttributesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP));
                }
              }
            }},
            internal_removeAllAttributes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllAttributesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.attributes) != null ? tmp$0 : Kotlin.throwNPE();
              this._attributes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, temp_els));
                this.removeAllAttributesCurrentlyProcessing = false;
              }
            }},
            defaultValues: {
              get: function () {
                return _.kotlin.toList(this._defaultValues.values());
              },
              set: function (defaultValuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (defaultValuesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_defaultValues(defaultValuesP, true, true);
              }
            },
            internal_defaultValues: {value: function (defaultValuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._defaultValues.values(), defaultValuesP)) {
                this._defaultValues.clear();
                {
                  var tmp$0 = defaultValuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._defaultValues.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_defaultValues, el), _.org.kevoree.util.Constants.Ref_defaultValues);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP));
                }
              }
            }},
            doAddDefaultValues: {value: function (defaultValuesP) {
              var _key_ = (defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._defaultValues.containsKey(_key_)) {
                this._defaultValues.put(_key_, defaultValuesP);
                (defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP), _.org.kevoree.util.Constants.Ref_defaultValues);
              }
            }},
            addDefaultValues: {value: function (defaultValuesP) {
              this.internal_addDefaultValues(defaultValuesP, true, true);
            }, writable: true},
            addAllDefaultValues: {value: function (defaultValuesP) {
              this.internal_addAllDefaultValues(defaultValuesP, true, true);
            }, writable: true},
            internal_addDefaultValues: {value: function (defaultValuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDefaultValues(defaultValuesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP));
              }
            }},
            internal_addAllDefaultValues: {value: function (defaultValuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = defaultValuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDefaultValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = defaultValuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDefaultValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP));
              }
            }},
            removeDefaultValues: {value: function (defaultValuesP) {
              this.internal_removeDefaultValues(defaultValuesP, true, true);
            }, writable: true},
            removeAllDefaultValues: {value: function () {
              this.internal_removeAllDefaultValues(true, true);
            }, writable: true},
            internal_removeDefaultValues: {value: function (defaultValuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._defaultValues.size() !== 0 && this._defaultValues.containsKey((defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()).internalGetKey())) {
                this._defaultValues.remove((defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()).internalGetKey());
                ((defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()) != null ? defaultValuesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllDefaultValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP));
                }
              }
            }},
            internal_removeAllDefaultValues: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllDefaultValuesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.defaultValues) != null ? tmp$0 : Kotlin.throwNPE();
              this._defaultValues.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, temp_els));
                this.removeAllDefaultValuesCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_attributes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllAttributes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._attributes.size() !== 0 && this._attributes.containsKey(value)) {
                    var obj = this._attributes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._attributes.remove(value);
                    this._attributes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_defaultValues) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDefaultValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDefaultValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDefaultValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDefaultValues();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._defaultValues.size() !== 0 && this._defaultValues.containsKey(value)) {
                    var obj_0 = this._defaultValues.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._defaultValues.remove(value);
                    this._defaultValues.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findAttributesByID: {value: function (key) {
              return this._attributes.get(key);
            }, writable: true},
            findDefaultValuesByID: {value: function (key) {
              return this._defaultValues.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_attributes) {
                return this.findAttributesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_defaultValues) {
                return this.findDefaultValuesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_attributes, _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute);
                {
                  var tmp$0 = this._attributes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._attributes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_attributes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_attributes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_defaultValues, _.org.kevoree.util.Constants.org_kevoree_DictionaryValue);
                {
                  var tmp$1 = this._defaultValues.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._defaultValues.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_defaultValues);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_defaultValues);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryType;
            }, writable: true}
          })},
          ChannelImpl: {value: Kotlin.createClass([classes.cv, classes.cu], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$metaData', {value: null, writable: true});
            Object.defineProperty(this, '$started', {value: true, writable: true});
            Object.defineProperty(this, '$typeDefinition', {value: null, writable: true});
            Object.defineProperty(this, '$dictionary', {value: null, writable: true});
            Object.defineProperty(this, '_bindings', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.ChannelImpl.prototype */ {
            delete: {value: function () {
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$0;
              (tmp$0 = this._bindings) != null ? tmp$0.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            }},
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            }},
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: {value: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            }},
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: {value: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            }},
            bindings: {
              get: function () {
                return _.kotlin.toList(this._bindings.values());
              },
              set: function (bindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (bindingsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_bindings(bindingsP, true, true);
              }
            },
            internal_bindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._bindings.values(), bindingsP)) {
                this.internal_removeAllBindings(true, false);
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._bindings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
                }
              }
            }},
            doAddBindings: {value: function (bindingsP) {
              var _key_ = (bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._bindings.containsKey(_key_)) {
                this._bindings.put(_key_, bindingsP);
              }
            }},
            addBindings: {value: function (bindingsP) {
              this.internal_addBindings(bindingsP, true, true);
            }, writable: true},
            addAllBindings: {value: function (bindingsP) {
              this.internal_addAllBindings(bindingsP, true, true);
            }, writable: true},
            internal_addBindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddBindings(bindingsP);
              if (setOpposite) {
                (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
              }
            }},
            internal_addAllBindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddBindings(el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = bindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
              }
            }},
            removeBindings: {value: function (bindingsP) {
              this.internal_removeBindings(bindingsP, true, true);
            }, writable: true},
            removeAllBindings: {value: function () {
              this.internal_removeAllBindings(true, true);
            }, writable: true},
            internal_removeBindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._bindings.size() !== 0 && this._bindings.containsKey((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._bindings.remove((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
                }
                if (setOpposite) {
                  (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, null, false, fireEvents);
                }
              }
            }},
            internal_removeAllBindings: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.bindings) != null ? tmp$0 : Kotlin.throwNPE();
              if (setOpposite) {
                {
                  var tmp$1 = (temp_els != null ? temp_els : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var el = tmp$1.next();
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, null, false, fireEvents);
                  }
                }
              }
              this._bindings.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_bindings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.internal_removeAllBindings(setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._bindings.size() !== 0 && this._bindings.containsKey(value)) {
                    var obj = this._bindings.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._bindings.remove(value);
                    this._bindings.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findBindingsByID: {value: function (key) {
              return this._bindings.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_bindings) {
                return this.findBindingsByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_bindings, _.org.kevoree.util.Constants.org_kevoree_MBinding);
                {
                  var tmp$0 = this._bindings.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._bindings.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_bindings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_bindings);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Channel;
            }, writable: true}
          })},
          NamespaceImpl: {value: Kotlin.createClass([classes.cv, classes.c1f], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '_childs', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllChildsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '$parent', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.NamespaceImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._childs) != null ? tmp$0.clear() : null;
              this.parent = null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            childs: {
              get: function () {
                return _.kotlin.toList(this._childs.values());
              },
              set: function (childsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (childsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_childs(childsP, true, true);
              }
            },
            internal_childs: {value: function (childsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._childs.values(), childsP)) {
                this._childs.clear();
                {
                  var tmp$0 = childsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._childs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_childs, el), _.org.kevoree.util.Constants.Ref_childs);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, childsP));
                }
              }
            }},
            doAddChilds: {value: function (childsP) {
              var _key_ = (childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._childs.containsKey(_key_)) {
                this._childs.put(_key_, childsP);
                (childsP != null ? childsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_childs, childsP), _.org.kevoree.util.Constants.Ref_childs);
              }
            }},
            addChilds: {value: function (childsP) {
              this.internal_addChilds(childsP, true, true);
            }, writable: true},
            addAllChilds: {value: function (childsP) {
              this.internal_addAllChilds(childsP, true, true);
            }, writable: true},
            internal_addChilds: {value: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddChilds(childsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, childsP));
              }
            }},
            internal_addAllChilds: {value: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = childsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddChilds(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = childsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddChilds(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, childsP));
              }
            }},
            removeChilds: {value: function (childsP) {
              this.internal_removeChilds(childsP, true, true);
            }, writable: true},
            removeAllChilds: {value: function () {
              this.internal_removeAllChilds(true, true);
            }, writable: true},
            internal_removeChilds: {value: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._childs.size() !== 0 && this._childs.containsKey((childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey())) {
                this._childs.remove((childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey());
                ((childsP != null ? childsP : Kotlin.throwNPE()) != null ? childsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllChildsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, childsP));
                }
              }
            }},
            internal_removeAllChilds: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllChildsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.childs) != null ? tmp$0 : Kotlin.throwNPE();
              this._childs.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, temp_els));
                this.removeAllChildsCurrentlyProcessing = false;
              }
            }},
            parent: {
              get: function () {
                return this.$parent;
              },
              set: function (parentP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_parent(parentP, true, true);
              }
            },
            internal_parent: {value: function (parentP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$parent, parentP)) {
                this.$parent = parentP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_parent, parentP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_childs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllChilds();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._childs.size() !== 0 && this._childs.containsKey(value)) {
                    var obj = this._childs.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._childs.remove(value);
                    this._childs.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_parent) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_parent(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_parent(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_parent(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findChildsByID: {value: function (key) {
              return this._childs.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_childs) {
                return this.findChildsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_parent) {
                var objFound = this.parent;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_childs, _.org.kevoree.util.Constants.org_kevoree_Namespace);
                {
                  var tmp$0 = this._childs.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._childs.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_childs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_childs);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_parent, _.org.kevoree.util.Constants.org_kevoree_Namespace);
                this.internal_visit(visitor, this.parent, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_parent);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_parent);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Namespace;
            }, writable: true}
          })},
          ContainerNodeImpl: {value: Kotlin.createClass([classes.cv, classes.c1], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$metaData', {value: null, writable: true});
            Object.defineProperty(this, '$started', {value: true, writable: true});
            Object.defineProperty(this, '$typeDefinition', {value: null, writable: true});
            Object.defineProperty(this, '$dictionary', {value: null, writable: true});
            Object.defineProperty(this, '_components', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllComponentsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_hosts', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$host', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.ContainerNodeImpl.prototype */ {
            delete: {value: function () {
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$0, tmp$1;
              (tmp$0 = this._components) != null ? tmp$0.clear() : null;
              (tmp$1 = this._hosts) != null ? tmp$1.clear() : null;
              this.host = null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            }},
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            }},
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: {value: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            }},
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: {value: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            }},
            components: {
              get: function () {
                return _.kotlin.toList(this._components.values());
              },
              set: function (componentsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (componentsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_components(componentsP, true, true);
              }
            },
            internal_components: {value: function (componentsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._components.values(), componentsP)) {
                this._components.clear();
                {
                  var tmp$0 = componentsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._components.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_components, el), _.org.kevoree.util.Constants.Ref_components);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP));
                }
              }
            }},
            doAddComponents: {value: function (componentsP) {
              var _key_ = (componentsP != null ? componentsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._components.containsKey(_key_)) {
                this._components.put(_key_, componentsP);
                (componentsP != null ? componentsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_components, componentsP), _.org.kevoree.util.Constants.Ref_components);
              }
            }},
            addComponents: {value: function (componentsP) {
              this.internal_addComponents(componentsP, true, true);
            }, writable: true},
            addAllComponents: {value: function (componentsP) {
              this.internal_addAllComponents(componentsP, true, true);
            }, writable: true},
            internal_addComponents: {value: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddComponents(componentsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP));
              }
            }},
            internal_addAllComponents: {value: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = componentsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddComponents(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = componentsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddComponents(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP));
              }
            }},
            removeComponents: {value: function (componentsP) {
              this.internal_removeComponents(componentsP, true, true);
            }, writable: true},
            removeAllComponents: {value: function () {
              this.internal_removeAllComponents(true, true);
            }, writable: true},
            internal_removeComponents: {value: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._components.size() !== 0 && this._components.containsKey((componentsP != null ? componentsP : Kotlin.throwNPE()).internalGetKey())) {
                this._components.remove((componentsP != null ? componentsP : Kotlin.throwNPE()).internalGetKey());
                ((componentsP != null ? componentsP : Kotlin.throwNPE()) != null ? componentsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllComponentsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP));
                }
              }
            }},
            internal_removeAllComponents: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllComponentsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.components) != null ? tmp$0 : Kotlin.throwNPE();
              this._components.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, temp_els));
                this.removeAllComponentsCurrentlyProcessing = false;
              }
            }},
            hosts: {
              get: function () {
                return _.kotlin.toList(this._hosts.values());
              },
              set: function (hostsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (hostsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_hosts(hostsP, true, true);
              }
            },
            internal_hosts: {value: function (hostsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._hosts.values(), hostsP)) {
                this.internal_removeAllHosts(true, false);
                {
                  var tmp$0 = hostsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._hosts.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP));
                }
              }
            }},
            doAddHosts: {value: function (hostsP) {
              var _key_ = (hostsP != null ? hostsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._hosts.containsKey(_key_)) {
                this._hosts.put(_key_, hostsP);
              }
            }},
            addHosts: {value: function (hostsP) {
              this.internal_addHosts(hostsP, true, true);
            }, writable: true},
            addAllHosts: {value: function (hostsP) {
              this.internal_addAllHosts(hostsP, true, true);
            }, writable: true},
            internal_addHosts: {value: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddHosts(hostsP);
              if (setOpposite) {
                (hostsP != null ? hostsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP));
              }
            }},
            internal_addAllHosts: {value: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = hostsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddHosts(el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = hostsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddHosts(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP));
              }
            }},
            removeHosts: {value: function (hostsP) {
              this.internal_removeHosts(hostsP, true, true);
            }, writable: true},
            removeAllHosts: {value: function () {
              this.internal_removeAllHosts(true, true);
            }, writable: true},
            internal_removeHosts: {value: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._hosts.size() !== 0 && this._hosts.containsKey((hostsP != null ? hostsP : Kotlin.throwNPE()).internalGetKey())) {
                this._hosts.remove((hostsP != null ? hostsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP));
                }
                if (setOpposite) {
                  (hostsP != null ? hostsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, null, false, fireEvents);
                }
              }
            }},
            internal_removeAllHosts: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.hosts) != null ? tmp$0 : Kotlin.throwNPE();
              if (setOpposite) {
                {
                  var tmp$1 = (temp_els != null ? temp_els : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var el = tmp$1.next();
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, null, false, fireEvents);
                  }
                }
              }
              this._hosts.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, temp_els));
              }
            }},
            host: {
              get: function () {
                return this.$host;
              },
              set: function (hostP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_host(hostP, true, true);
              }
            },
            internal_host: {value: function (hostP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$host, hostP)) {
                if (setOpposite) {
                  if (this.$host != null) {
                    var tmp$0;
                    ((tmp$0 = this.$host) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_hosts, this, false, fireEvents);
                  }
                  if (hostP != null) {
                    hostP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.util.Constants.Ref_hosts, this, false, fireEvents);
                  }
                }
                this.$host = hostP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_host, hostP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_components) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllComponents();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._components.size() !== 0 && this._components.containsKey(value)) {
                    var obj = this._components.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._components.remove(value);
                    this._components.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_hosts) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.internal_removeAllHosts(setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._hosts.size() !== 0 && this._hosts.containsKey(value)) {
                    var obj_0 = this._hosts.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._hosts.remove(value);
                    this._hosts.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_host) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_host(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_host(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_host(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findComponentsByID: {value: function (key) {
              return this._components.get(key);
            }, writable: true},
            findHostsByID: {value: function (key) {
              return this._hosts.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_components) {
                return this.findComponentsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_hosts) {
                return this.findHostsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_host) {
                var objFound_1 = this.host;
                if (objFound_1 != null && Kotlin.equals((objFound_1 != null ? objFound_1 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_1;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_components, _.org.kevoree.util.Constants.org_kevoree_ComponentInstance);
                {
                  var tmp$0 = this._components.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._components.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_components);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_components);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hosts, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                {
                  var tmp$1 = this._hosts.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._hosts.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hosts);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hosts);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_host, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.host, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_host);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_host);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ContainerNode;
            }, writable: true}
          })},
          ComponentInstanceImpl: {value: Kotlin.createClass([classes.cv, classes.c1m], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$metaData', {value: null, writable: true});
            Object.defineProperty(this, '$started', {value: true, writable: true});
            Object.defineProperty(this, '$typeDefinition', {value: null, writable: true});
            Object.defineProperty(this, '$dictionary', {value: null, writable: true});
            Object.defineProperty(this, '_provided', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllProvidedCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_required', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllRequiredCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '$namespace', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.ComponentInstanceImpl.prototype */ {
            delete: {value: function () {
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$0, tmp$1;
              (tmp$0 = this._provided) != null ? tmp$0.clear() : null;
              (tmp$1 = this._required) != null ? tmp$1.clear() : null;
              this.namespace = null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            }},
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            }},
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: {value: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            }},
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: {value: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            }},
            provided: {
              get: function () {
                return _.kotlin.toList(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: {value: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            }},
            doAddProvided: {value: function (providedP) {
              var _key_ = (providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey(_key_)) {
                this._provided.put(_key_, providedP);
                (providedP != null ? providedP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
              }
            }},
            addProvided: {value: function (providedP) {
              this.internal_addProvided(providedP, true, true);
            }, writable: true},
            addAllProvided: {value: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
            }, writable: true},
            internal_addProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            }},
            internal_addAllProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            }},
            removeProvided: {value: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
            }, writable: true},
            removeAllProvided: {value: function () {
              this.internal_removeAllProvided(true, true);
            }, writable: true},
            internal_removeProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey())) {
                this._provided.remove((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey());
                ((providedP != null ? providedP : Kotlin.throwNPE()) != null ? providedP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            }},
            internal_removeAllProvided: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.provided) != null ? tmp$0 : Kotlin.throwNPE();
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            }},
            required: {
              get: function () {
                return _.kotlin.toList(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: {value: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            }},
            doAddRequired: {value: function (requiredP) {
              var _key_ = (requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey(_key_)) {
                this._required.put(_key_, requiredP);
                (requiredP != null ? requiredP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
              }
            }},
            addRequired: {value: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
            }, writable: true},
            addAllRequired: {value: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
            }, writable: true},
            internal_addRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            }},
            internal_addAllRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            }},
            removeRequired: {value: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
            }, writable: true},
            removeAllRequired: {value: function () {
              this.internal_removeAllRequired(true, true);
            }, writable: true},
            internal_removeRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey())) {
                this._required.remove((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey());
                ((requiredP != null ? requiredP : Kotlin.throwNPE()) != null ? requiredP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            }},
            internal_removeAllRequired: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.required) != null ? tmp$0 : Kotlin.throwNPE();
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            }},
            namespace: {
              get: function () {
                return this.$namespace;
              },
              set: function (namespaceP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_namespace(namespaceP, true, true);
              }
            },
            internal_namespace: {value: function (namespaceP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$namespace, namespaceP)) {
                this.$namespace = namespaceP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_namespace, namespaceP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllProvided();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._provided.size() !== 0 && this._provided.containsKey(value)) {
                    var obj = this._provided.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._provided.remove(value);
                    this._provided.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRequired();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._required.size() !== 0 && this._required.containsKey(value)) {
                    var obj_0 = this._required.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._required.remove(value);
                    this._required.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_namespace) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_namespace(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_namespace(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_namespace(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findProvidedByID: {value: function (key) {
              return this._provided.get(key);
            }, writable: true},
            findRequiredByID: {value: function (key) {
              return this._required.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                return this.findProvidedByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                return this.findRequiredByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_namespace) {
                var objFound_1 = this.namespace;
                if (objFound_1 != null && Kotlin.equals((objFound_1 != null ? objFound_1 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_1;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_Port);
                {
                  var tmp$0 = this._provided.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._provided.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_Port);
                {
                  var tmp$1 = this._required.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._required.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_namespace, _.org.kevoree.util.Constants.org_kevoree_Namespace);
                this.internal_visit(visitor, this.namespace, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_namespace);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_namespace);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ComponentInstance;
            }, writable: true}
          })},
          MessagePortTypeImpl: {value: Kotlin.createClass([classes.cv, classes.c2], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$factoryBean', {value: null, writable: true});
            Object.defineProperty(this, '$bean', {value: null, writable: true});
            Object.defineProperty(this, '$abstract', {value: null, writable: true});
            Object.defineProperty(this, '$synchrone', {value: null, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$dictionaryType', {value: null, writable: true});
            Object.defineProperty(this, '_superTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '_filters', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.MessagePortTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1, tmp$2;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._filters) != null ? tmp$2.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            }},
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            }},
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            }},
            synchrone: {
              get: function () {
                return this.$synchrone;
              },
              set: function (iP) {
                this.internal_synchrone(iP, true);
              }
            },
            internal_synchrone: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.synchrone)) {
                var oldPath = this.path();
                this.$synchrone = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_synchrone, this.synchrone));
                }
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            }},
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: {value: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            }},
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            doAddSuperTypes: {value: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            }},
            addSuperTypes: {value: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            }, writable: true},
            addAllSuperTypes: {value: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            }, writable: true},
            internal_addSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            internal_addAllSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            removeSuperTypes: {value: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            }, writable: true},
            removeAllSuperTypes: {value: function () {
              this.internal_removeAllSuperTypes(true, true);
            }, writable: true},
            internal_removeSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            internal_removeAllSuperTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            }},
            filters: {
              get: function () {
                return _.kotlin.toList(this._filters.values());
              },
              set: function (filtersP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (filtersP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_filters(filtersP, true, true);
              }
            },
            internal_filters: {value: function (filtersP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._filters.values(), filtersP)) {
                this._filters.clear();
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._filters.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP));
                }
              }
            }},
            doAddFilters: {value: function (filtersP) {
              var _key_ = (filtersP != null ? filtersP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._filters.containsKey(_key_)) {
                this._filters.put(_key_, filtersP);
              }
            }},
            addFilters: {value: function (filtersP) {
              this.internal_addFilters(filtersP, true, true);
            }, writable: true},
            addAllFilters: {value: function (filtersP) {
              this.internal_addAllFilters(filtersP, true, true);
            }, writable: true},
            internal_addFilters: {value: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFilters(filtersP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP));
              }
            }},
            internal_addAllFilters: {value: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFilters(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = filtersP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFilters(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP));
              }
            }},
            removeFilters: {value: function (filtersP) {
              this.internal_removeFilters(filtersP, true, true);
            }, writable: true},
            removeAllFilters: {value: function () {
              this.internal_removeAllFilters(true, true);
            }, writable: true},
            internal_removeFilters: {value: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._filters.size() !== 0 && this._filters.containsKey((filtersP != null ? filtersP : Kotlin.throwNPE()).internalGetKey())) {
                this._filters.remove((filtersP != null ? filtersP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP));
                }
              }
            }},
            internal_removeAllFilters: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.filters) != null ? tmp$0 : Kotlin.throwNPE();
              this._filters.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_synchrone) {
                this.internal_synchrone(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_filters) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllFilters();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._filters.size() !== 0 && this._filters.containsKey(value)) {
                    var obj_1 = this._filters.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._filters.remove(value);
                    this._filters.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findSuperTypesByID: {value: function (key) {
              return this._superTypes.get(key);
            }, writable: true},
            findFiltersByID: {value: function (key) {
              return this._filters.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_filters) {
                return this.findFiltersByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._deployUnits.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$1 = this._superTypes.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_filters, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$2 = this._filters.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._filters.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_filters);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_filters);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.synchrone, _.org.kevoree.util.Constants.Att_synchrone, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_MessagePortType;
            }, writable: true}
          })},
          ParameterImpl: {value: Kotlin.createClass([classes.cv, classes.cx], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$order', {value: null, writable: true});
            Object.defineProperty(this, '$type', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.ParameterImpl.prototype */ {
            delete: {value: function () {
              this.type = null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            order: {
              get: function () {
                return this.$order;
              },
              set: function (iP) {
                this.internal_order(iP, true);
              }
            },
            internal_order: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.order) {
                var oldPath = this.path();
                this.$order = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_order, this.order));
                }
              }
            }},
            type: {
              get: function () {
                return this.$type;
              },
              set: function (typeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_type(typeP, true, true);
              }
            },
            internal_type: {value: function (typeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$type, typeP)) {
                this.$type = typeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_type, typeP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_order) {
                this.internal_order(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_type) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_type(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_type(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_type(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_type) {
                var objFound = this.type;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_type, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                this.internal_visit(visitor, this.type, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_type);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_type);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.order, _.org.kevoree.util.Constants.Att_order, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Parameter;
            }, writable: true}
          })},
          DictionaryAttributeImpl: {value: Kotlin.createClass([classes.cv, classes.c17], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$optional', {value: null, writable: true});
            Object.defineProperty(this, '$state', {value: null, writable: true});
            Object.defineProperty(this, '$datatype', {value: null, writable: true});
            Object.defineProperty(this, '$fragmentDependant', {value: null, writable: true});
            Object.defineProperty(this, '_genericTypes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.DictionaryAttributeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._genericTypes) != null ? tmp$0.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            optional: {
              get: function () {
                return this.$optional;
              },
              set: function (iP) {
                this.internal_optional(iP, true);
              }
            },
            internal_optional: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.optional)) {
                var oldPath = this.path();
                this.$optional = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_optional, this.optional));
                }
              }
            }},
            state: {
              get: function () {
                return this.$state;
              },
              set: function (iP) {
                this.internal_state(iP, true);
              }
            },
            internal_state: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.state)) {
                var oldPath = this.path();
                this.$state = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_state, this.state));
                }
              }
            }},
            datatype: {
              get: function () {
                return this.$datatype;
              },
              set: function (iP) {
                this.internal_datatype(iP, true);
              }
            },
            internal_datatype: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.datatype)) {
                var oldPath = this.path();
                this.$datatype = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_datatype, this.datatype));
                }
              }
            }},
            fragmentDependant: {
              get: function () {
                return this.$fragmentDependant;
              },
              set: function (iP) {
                this.internal_fragmentDependant(iP, true);
              }
            },
            internal_fragmentDependant: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.fragmentDependant)) {
                var oldPath = this.path();
                this.$fragmentDependant = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_fragmentDependant, this.fragmentDependant));
                }
              }
            }},
            genericTypes: {
              get: function () {
                return _.kotlin.toList(this._genericTypes.values());
              },
              set: function (genericTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (genericTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_genericTypes(genericTypesP, true, true);
              }
            },
            internal_genericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._genericTypes.values(), genericTypesP)) {
                this._genericTypes.clear();
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._genericTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
                }
              }
            }},
            doAddGenericTypes: {value: function (genericTypesP) {
              var _key_ = (genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._genericTypes.containsKey(_key_)) {
                this._genericTypes.put(_key_, genericTypesP);
              }
            }},
            addGenericTypes: {value: function (genericTypesP) {
              this.internal_addGenericTypes(genericTypesP, true, true);
            }, writable: true},
            addAllGenericTypes: {value: function (genericTypesP) {
              this.internal_addAllGenericTypes(genericTypesP, true, true);
            }, writable: true},
            internal_addGenericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGenericTypes(genericTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
              }
            }},
            internal_addAllGenericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGenericTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = genericTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGenericTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
              }
            }},
            removeGenericTypes: {value: function (genericTypesP) {
              this.internal_removeGenericTypes(genericTypesP, true, true);
            }, writable: true},
            removeAllGenericTypes: {value: function () {
              this.internal_removeAllGenericTypes(true, true);
            }, writable: true},
            internal_removeGenericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._genericTypes.remove((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
                }
              }
            }},
            internal_removeAllGenericTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.genericTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._genericTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_optional) {
                this.internal_optional(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_state) {
                this.internal_state(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_datatype) {
                this.internal_datatype(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_fragmentDependant) {
                this.internal_fragmentDependant(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllGenericTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey(value)) {
                    var obj = this._genericTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._genericTypes.remove(value);
                    this._genericTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findGenericTypesByID: {value: function (key) {
              return this._genericTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                return this.findGenericTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$0 = this._genericTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._genericTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_genericTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.fragmentDependant, _.org.kevoree.util.Constants.Att_fragmentDependant, this);
              visitor.visit(this.optional, _.org.kevoree.util.Constants.Att_optional, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.state, _.org.kevoree.util.Constants.Att_state, this);
              visitor.visit(this.datatype, _.org.kevoree.util.Constants.Att_datatype, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute;
            }, writable: true}
          })},
          InstanceImpl: {value: Kotlin.createClass([classes.cv, classes.c13], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$metaData', {value: null, writable: true});
            Object.defineProperty(this, '$started', {value: true, writable: true});
            Object.defineProperty(this, '$typeDefinition', {value: null, writable: true});
            Object.defineProperty(this, '$dictionary', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.InstanceImpl.prototype */ {
            delete: {value: function () {
              this.typeDefinition = null;
              this.dictionary = null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            }},
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            }},
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: {value: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            }},
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: {value: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Instance;
            }, writable: true}
          })},
          TypedElementImpl: {value: Kotlin.createClass([classes.cv, classes.cw], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '_genericTypes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.TypedElementImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._genericTypes) != null ? tmp$0.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            genericTypes: {
              get: function () {
                return _.kotlin.toList(this._genericTypes.values());
              },
              set: function (genericTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (genericTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_genericTypes(genericTypesP, true, true);
              }
            },
            internal_genericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._genericTypes.values(), genericTypesP)) {
                this._genericTypes.clear();
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._genericTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
                }
              }
            }},
            doAddGenericTypes: {value: function (genericTypesP) {
              var _key_ = (genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._genericTypes.containsKey(_key_)) {
                this._genericTypes.put(_key_, genericTypesP);
              }
            }},
            addGenericTypes: {value: function (genericTypesP) {
              this.internal_addGenericTypes(genericTypesP, true, true);
            }, writable: true},
            addAllGenericTypes: {value: function (genericTypesP) {
              this.internal_addAllGenericTypes(genericTypesP, true, true);
            }, writable: true},
            internal_addGenericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGenericTypes(genericTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
              }
            }},
            internal_addAllGenericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGenericTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = genericTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGenericTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
              }
            }},
            removeGenericTypes: {value: function (genericTypesP) {
              this.internal_removeGenericTypes(genericTypesP, true, true);
            }, writable: true},
            removeAllGenericTypes: {value: function () {
              this.internal_removeAllGenericTypes(true, true);
            }, writable: true},
            internal_removeGenericTypes: {value: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._genericTypes.remove((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
                }
              }
            }},
            internal_removeAllGenericTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.genericTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._genericTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllGenericTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey(value)) {
                    var obj = this._genericTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._genericTypes.remove(value);
                    this._genericTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findGenericTypesByID: {value: function (key) {
              return this._genericTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                return this.findGenericTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$0 = this._genericTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._genericTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_genericTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_TypedElement;
            }, writable: true}
          })},
          NodeTypeImpl: {value: Kotlin.createClass([classes.cv, classes.c14], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$factoryBean', {value: null, writable: true});
            Object.defineProperty(this, '$bean', {value: null, writable: true});
            Object.defineProperty(this, '$abstract', {value: null, writable: true});
            Object.defineProperty(this, '$startMethod', {value: null, writable: true});
            Object.defineProperty(this, '$stopMethod', {value: null, writable: true});
            Object.defineProperty(this, '$updateMethod', {value: null, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$dictionaryType', {value: null, writable: true});
            Object.defineProperty(this, '_superTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '_managedPrimitiveTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '_managedPrimitiveTypeRefs', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllManagedPrimitiveTypeRefsCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.NodeTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1, tmp$2, tmp$3;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._managedPrimitiveTypes) != null ? tmp$2.clear() : null;
              (tmp$3 = this._managedPrimitiveTypeRefs) != null ? tmp$3.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            }},
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            }},
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            }},
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            }},
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            }},
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            }},
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: {value: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            }},
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            doAddSuperTypes: {value: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            }},
            addSuperTypes: {value: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            }, writable: true},
            addAllSuperTypes: {value: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            }, writable: true},
            internal_addSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            internal_addAllSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            removeSuperTypes: {value: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            }, writable: true},
            removeAllSuperTypes: {value: function () {
              this.internal_removeAllSuperTypes(true, true);
            }, writable: true},
            internal_removeSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            internal_removeAllSuperTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            }},
            managedPrimitiveTypes: {
              get: function () {
                return _.kotlin.toList(this._managedPrimitiveTypes.values());
              },
              set: function (managedPrimitiveTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (managedPrimitiveTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_managedPrimitiveTypes(managedPrimitiveTypesP, true, true);
              }
            },
            internal_managedPrimitiveTypes: {value: function (managedPrimitiveTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._managedPrimitiveTypes.values(), managedPrimitiveTypesP)) {
                this._managedPrimitiveTypes.clear();
                {
                  var tmp$0 = managedPrimitiveTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._managedPrimitiveTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, managedPrimitiveTypesP));
                }
              }
            }},
            doAddManagedPrimitiveTypes: {value: function (managedPrimitiveTypesP) {
              var _key_ = (managedPrimitiveTypesP != null ? managedPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._managedPrimitiveTypes.containsKey(_key_)) {
                this._managedPrimitiveTypes.put(_key_, managedPrimitiveTypesP);
              }
            }},
            addManagedPrimitiveTypes: {value: function (managedPrimitiveTypesP) {
              this.internal_addManagedPrimitiveTypes(managedPrimitiveTypesP, true, true);
            }, writable: true},
            addAllManagedPrimitiveTypes: {value: function (managedPrimitiveTypesP) {
              this.internal_addAllManagedPrimitiveTypes(managedPrimitiveTypesP, true, true);
            }, writable: true},
            internal_addManagedPrimitiveTypes: {value: function (managedPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddManagedPrimitiveTypes(managedPrimitiveTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, managedPrimitiveTypesP));
              }
            }},
            internal_addAllManagedPrimitiveTypes: {value: function (managedPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = managedPrimitiveTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddManagedPrimitiveTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = managedPrimitiveTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddManagedPrimitiveTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, managedPrimitiveTypesP));
              }
            }},
            removeManagedPrimitiveTypes: {value: function (managedPrimitiveTypesP) {
              this.internal_removeManagedPrimitiveTypes(managedPrimitiveTypesP, true, true);
            }, writable: true},
            removeAllManagedPrimitiveTypes: {value: function () {
              this.internal_removeAllManagedPrimitiveTypes(true, true);
            }, writable: true},
            internal_removeManagedPrimitiveTypes: {value: function (managedPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._managedPrimitiveTypes.size() !== 0 && this._managedPrimitiveTypes.containsKey((managedPrimitiveTypesP != null ? managedPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._managedPrimitiveTypes.remove((managedPrimitiveTypesP != null ? managedPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, managedPrimitiveTypesP));
                }
              }
            }},
            internal_removeAllManagedPrimitiveTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.managedPrimitiveTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._managedPrimitiveTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, temp_els));
              }
            }},
            managedPrimitiveTypeRefs: {
              get: function () {
                return _.kotlin.toList(this._managedPrimitiveTypeRefs.values());
              },
              set: function (managedPrimitiveTypeRefsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (managedPrimitiveTypeRefsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_managedPrimitiveTypeRefs(managedPrimitiveTypeRefsP, true, true);
              }
            },
            internal_managedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._managedPrimitiveTypeRefs.values(), managedPrimitiveTypeRefsP)) {
                this._managedPrimitiveTypeRefs.clear();
                {
                  var tmp$0 = managedPrimitiveTypeRefsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._managedPrimitiveTypeRefs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, el), _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP));
                }
              }
            }},
            doAddManagedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP) {
              var _key_ = (managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._managedPrimitiveTypeRefs.containsKey(_key_)) {
                this._managedPrimitiveTypeRefs.put(_key_, managedPrimitiveTypeRefsP);
                (managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP), _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs);
              }
            }},
            addManagedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP) {
              this.internal_addManagedPrimitiveTypeRefs(managedPrimitiveTypeRefsP, true, true);
            }, writable: true},
            addAllManagedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP) {
              this.internal_addAllManagedPrimitiveTypeRefs(managedPrimitiveTypeRefsP, true, true);
            }, writable: true},
            internal_addManagedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddManagedPrimitiveTypeRefs(managedPrimitiveTypeRefsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP));
              }
            }},
            internal_addAllManagedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = managedPrimitiveTypeRefsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddManagedPrimitiveTypeRefs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = managedPrimitiveTypeRefsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddManagedPrimitiveTypeRefs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP));
              }
            }},
            removeManagedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP) {
              this.internal_removeManagedPrimitiveTypeRefs(managedPrimitiveTypeRefsP, true, true);
            }, writable: true},
            removeAllManagedPrimitiveTypeRefs: {value: function () {
              this.internal_removeAllManagedPrimitiveTypeRefs(true, true);
            }, writable: true},
            internal_removeManagedPrimitiveTypeRefs: {value: function (managedPrimitiveTypeRefsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._managedPrimitiveTypeRefs.size() !== 0 && this._managedPrimitiveTypeRefs.containsKey((managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).internalGetKey())) {
                this._managedPrimitiveTypeRefs.remove((managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).internalGetKey());
                ((managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()) != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllManagedPrimitiveTypeRefsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP));
                }
              }
            }},
            internal_removeAllManagedPrimitiveTypeRefs: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllManagedPrimitiveTypeRefsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.managedPrimitiveTypeRefs) != null ? tmp$0 : Kotlin.throwNPE();
              this._managedPrimitiveTypeRefs.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, temp_els));
                this.removeAllManagedPrimitiveTypeRefsCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addManagedPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllManagedPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeManagedPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllManagedPrimitiveTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._managedPrimitiveTypes.size() !== 0 && this._managedPrimitiveTypes.containsKey(value)) {
                    var obj_1 = this._managedPrimitiveTypes.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._managedPrimitiveTypes.remove(value);
                    this._managedPrimitiveTypes.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addManagedPrimitiveTypeRefs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllManagedPrimitiveTypeRefs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeManagedPrimitiveTypeRefs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllManagedPrimitiveTypeRefs();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._managedPrimitiveTypeRefs.size() !== 0 && this._managedPrimitiveTypeRefs.containsKey(value)) {
                    var obj_2 = this._managedPrimitiveTypeRefs.get(value);
                    var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_2 == null) {
                      throw new Error('Key newed to null ' + obj_2);
                    }
                    this._managedPrimitiveTypeRefs.remove(value);
                    this._managedPrimitiveTypeRefs.put(objNewKey_2, obj_2);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findSuperTypesByID: {value: function (key) {
              return this._superTypes.get(key);
            }, writable: true},
            findManagedPrimitiveTypesByID: {value: function (key) {
              return this._managedPrimitiveTypes.get(key);
            }, writable: true},
            findManagedPrimitiveTypeRefsByID: {value: function (key) {
              return this._managedPrimitiveTypeRefs.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes) {
                return this.findManagedPrimitiveTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs) {
                return this.findManagedPrimitiveTypeRefsByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveTypeRef);
                {
                  var tmp$0 = this._managedPrimitiveTypeRefs.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._managedPrimitiveTypeRefs.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$1 = this._deployUnits.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$2 = this._superTypes.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType);
                {
                  var tmp$3 = this._managedPrimitiveTypes.keySet().iterator();
                  while (tmp$3.hasNext()) {
                    var KMFLoopEntryKey_2 = tmp$3.next();
                    this.internal_visit(visitor, this._managedPrimitiveTypes.get(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_managedPrimitiveTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NodeType;
            }, writable: true}
          })},
          DeployUnitImpl: {value: Kotlin.createClass([classes.cv, classes.c0], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$groupName', {value: null, writable: true});
            Object.defineProperty(this, '$unitName', {value: null, writable: true});
            Object.defineProperty(this, '$version', {value: null, writable: true});
            Object.defineProperty(this, '$url', {value: null, writable: true});
            Object.defineProperty(this, '$hashcode', {value: null, writable: true});
            Object.defineProperty(this, '$type', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_requiredLibs', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$targetNodeType', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.DeployUnitImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._requiredLibs) != null ? tmp$0.clear() : null;
              this.targetNodeType = null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
              }
            }},
            groupName: {
              get: function () {
                return this.$groupName;
              },
              set: function (iP) {
                this.internal_groupName(iP, true);
              }
            },
            internal_groupName: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.groupName)) {
                var oldPath = this.path();
                this.$groupName = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_groupName, this.groupName));
                }
              }
            }},
            unitName: {
              get: function () {
                return this.$unitName;
              },
              set: function (iP) {
                this.internal_unitName(iP, true);
              }
            },
            internal_unitName: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.unitName)) {
                var oldPath = this.path();
                this.$unitName = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_unitName, this.unitName));
                }
              }
            }},
            version: {
              get: function () {
                return this.$version;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                this.$version = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version));
                }
              }
            }},
            url: {
              get: function () {
                return this.$url;
              },
              set: function (iP) {
                this.internal_url(iP, true);
              }
            },
            internal_url: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.url)) {
                var oldPath = this.path();
                this.$url = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_url, this.url));
                }
              }
            }},
            hashcode: {
              get: function () {
                return this.$hashcode;
              },
              set: function (iP) {
                this.internal_hashcode(iP, true);
              }
            },
            internal_hashcode: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.hashcode)) {
                var oldPath = this.path();
                this.$hashcode = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_hashcode, this.hashcode));
                }
              }
            }},
            type: {
              get: function () {
                return this.$type;
              },
              set: function (iP) {
                this.internal_type(iP, true);
              }
            },
            internal_type: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.type)) {
                var oldPath = this.path();
                this.$type = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_type, this.type));
                }
              }
            }},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            requiredLibs: {
              get: function () {
                return _.kotlin.toList(this._requiredLibs.values());
              },
              set: function (requiredLibsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredLibsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_requiredLibs(requiredLibsP, true, true);
              }
            },
            internal_requiredLibs: {value: function (requiredLibsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._requiredLibs.values(), requiredLibsP)) {
                this._requiredLibs.clear();
                {
                  var tmp$0 = requiredLibsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._requiredLibs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP));
                }
              }
            }},
            doAddRequiredLibs: {value: function (requiredLibsP) {
              var _key_ = (requiredLibsP != null ? requiredLibsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._requiredLibs.containsKey(_key_)) {
                this._requiredLibs.put(_key_, requiredLibsP);
              }
            }},
            addRequiredLibs: {value: function (requiredLibsP) {
              this.internal_addRequiredLibs(requiredLibsP, true, true);
            }, writable: true},
            addAllRequiredLibs: {value: function (requiredLibsP) {
              this.internal_addAllRequiredLibs(requiredLibsP, true, true);
            }, writable: true},
            internal_addRequiredLibs: {value: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequiredLibs(requiredLibsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP));
              }
            }},
            internal_addAllRequiredLibs: {value: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredLibsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequiredLibs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredLibsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequiredLibs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP));
              }
            }},
            removeRequiredLibs: {value: function (requiredLibsP) {
              this.internal_removeRequiredLibs(requiredLibsP, true, true);
            }, writable: true},
            removeAllRequiredLibs: {value: function () {
              this.internal_removeAllRequiredLibs(true, true);
            }, writable: true},
            internal_removeRequiredLibs: {value: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._requiredLibs.size() !== 0 && this._requiredLibs.containsKey((requiredLibsP != null ? requiredLibsP : Kotlin.throwNPE()).internalGetKey())) {
                this._requiredLibs.remove((requiredLibsP != null ? requiredLibsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP));
                }
              }
            }},
            internal_removeAllRequiredLibs: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.requiredLibs) != null ? tmp$0 : Kotlin.throwNPE();
              this._requiredLibs.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, temp_els));
              }
            }},
            targetNodeType: {
              get: function () {
                return this.$targetNodeType;
              },
              set: function (targetNodeTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_targetNodeType(targetNodeTypeP, true, true);
              }
            },
            internal_targetNodeType: {value: function (targetNodeTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$targetNodeType, targetNodeTypeP)) {
                this.$targetNodeType = targetNodeTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_targetNodeType, targetNodeTypeP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_groupName) {
                this.internal_groupName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_unitName) {
                this.internal_unitName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_version) {
                this.internal_version(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_url) {
                this.internal_url(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_hashcode) {
                this.internal_hashcode(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_type) {
                this.internal_type(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_requiredLibs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRequiredLibs();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._requiredLibs.size() !== 0 && this._requiredLibs.containsKey(value)) {
                    var obj = this._requiredLibs.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._requiredLibs.remove(value);
                    this._requiredLibs.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_targetNodeType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_targetNodeType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_targetNodeType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_targetNodeType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findRequiredLibsByID: {value: function (key) {
              return this._requiredLibs.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_requiredLibs) {
                return this.findRequiredLibsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_targetNodeType) {
                var objFound = this.targetNodeType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_requiredLibs, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._requiredLibs.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._requiredLibs.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_requiredLibs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_requiredLibs);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_targetNodeType, _.org.kevoree.util.Constants.org_kevoree_NodeType);
                this.internal_visit(visitor, this.targetNodeType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_targetNodeType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_targetNodeType);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.groupName, _.org.kevoree.util.Constants.Att_groupName, this);
              visitor.visit(this.unitName, _.org.kevoree.util.Constants.Att_unitName, this);
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.hashcode, _.org.kevoree.util.Constants.Att_hashcode, this);
              visitor.visit(this.type, _.org.kevoree.util.Constants.Att_type, this);
              visitor.visit(this.url, _.org.kevoree.util.Constants.Att_url, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DeployUnit;
            }, writable: true}
          })},
          GroupTypeImpl: {value: Kotlin.createClass([classes.cv, classes.c3], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$factoryBean', {value: null, writable: true});
            Object.defineProperty(this, '$bean', {value: null, writable: true});
            Object.defineProperty(this, '$abstract', {value: null, writable: true});
            Object.defineProperty(this, '$startMethod', {value: null, writable: true});
            Object.defineProperty(this, '$stopMethod', {value: null, writable: true});
            Object.defineProperty(this, '$updateMethod', {value: null, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$dictionaryType', {value: null, writable: true});
            Object.defineProperty(this, '_superTypes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.GroupTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            }},
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            }},
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            }},
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            }},
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            }},
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            }},
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: {value: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            }},
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            doAddSuperTypes: {value: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            }},
            addSuperTypes: {value: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            }, writable: true},
            addAllSuperTypes: {value: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            }, writable: true},
            internal_addSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            internal_addAllSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            removeSuperTypes: {value: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            }, writable: true},
            removeAllSuperTypes: {value: function () {
              this.internal_removeAllSuperTypes(true, true);
            }, writable: true},
            internal_removeSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            internal_removeAllSuperTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findSuperTypesByID: {value: function (key) {
              return this._superTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._deployUnits.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$1 = this._superTypes.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_GroupType;
            }, writable: true}
          })},
          AdaptationPrimitiveTypeRefImpl: {value: Kotlin.createClass([classes.cv, classes.cs], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$maxTime', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '$ref', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.AdaptationPrimitiveTypeRefImpl.prototype */ {
            delete: {value: function () {
              this.ref = null;
            }, writable: true},
            maxTime: {
              get: function () {
                return this.$maxTime;
              },
              set: function (iP) {
                this.internal_maxTime(iP, true);
              }
            },
            internal_maxTime: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.maxTime)) {
                var oldPath = this.path();
                this.$maxTime = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_maxTime, this.maxTime));
                }
              }
            }},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            ref: {
              get: function () {
                return this.$ref;
              },
              set: function (refP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_ref(refP, true, true);
              }
            },
            internal_ref: {value: function (refP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$ref, refP)) {
                this.$ref = refP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ref, refP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_maxTime) {
                this.internal_maxTime(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_ref) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_ref(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_ref(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_ref(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_ref) {
                var objFound = this.ref;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_ref, _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType);
                this.internal_visit(visitor, this.ref, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_ref);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_ref);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.maxTime, _.org.kevoree.util.Constants.Att_maxTime, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveTypeRef;
            }, writable: true}
          })},
          IntegrationPatternImpl: {value: Kotlin.createClass([classes.cv, classes.c1k], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '_extraFonctionalProperties', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllExtraFonctionalPropertiesCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_portTypes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.IntegrationPatternImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1;
              (tmp$0 = this._extraFonctionalProperties) != null ? tmp$0.clear() : null;
              (tmp$1 = this._portTypes) != null ? tmp$1.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            extraFonctionalProperties: {
              get: function () {
                return _.kotlin.toList(this._extraFonctionalProperties.values());
              },
              set: function (extraFonctionalPropertiesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (extraFonctionalPropertiesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_extraFonctionalProperties(extraFonctionalPropertiesP, true, true);
              }
            },
            internal_extraFonctionalProperties: {value: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._extraFonctionalProperties.values(), extraFonctionalPropertiesP)) {
                this._extraFonctionalProperties.clear();
                {
                  var tmp$0 = extraFonctionalPropertiesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._extraFonctionalProperties.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, el), _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
                }
              }
            }},
            doAddExtraFonctionalProperties: {value: function (extraFonctionalPropertiesP) {
              var _key_ = (extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._extraFonctionalProperties.containsKey(_key_)) {
                this._extraFonctionalProperties.put(_key_, extraFonctionalPropertiesP);
                (extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP), _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
              }
            }},
            addExtraFonctionalProperties: {value: function (extraFonctionalPropertiesP) {
              this.internal_addExtraFonctionalProperties(extraFonctionalPropertiesP, true, true);
            }, writable: true},
            addAllExtraFonctionalProperties: {value: function (extraFonctionalPropertiesP) {
              this.internal_addAllExtraFonctionalProperties(extraFonctionalPropertiesP, true, true);
            }, writable: true},
            internal_addExtraFonctionalProperties: {value: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddExtraFonctionalProperties(extraFonctionalPropertiesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
              }
            }},
            internal_addAllExtraFonctionalProperties: {value: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = extraFonctionalPropertiesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddExtraFonctionalProperties(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = extraFonctionalPropertiesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddExtraFonctionalProperties(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
              }
            }},
            removeExtraFonctionalProperties: {value: function (extraFonctionalPropertiesP) {
              this.internal_removeExtraFonctionalProperties(extraFonctionalPropertiesP, true, true);
            }, writable: true},
            removeAllExtraFonctionalProperties: {value: function () {
              this.internal_removeAllExtraFonctionalProperties(true, true);
            }, writable: true},
            internal_removeExtraFonctionalProperties: {value: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._extraFonctionalProperties.size() !== 0 && this._extraFonctionalProperties.containsKey((extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).internalGetKey())) {
                this._extraFonctionalProperties.remove((extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).internalGetKey());
                ((extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()) != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllExtraFonctionalPropertiesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
                }
              }
            }},
            internal_removeAllExtraFonctionalProperties: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllExtraFonctionalPropertiesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.extraFonctionalProperties) != null ? tmp$0 : Kotlin.throwNPE();
              this._extraFonctionalProperties.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, temp_els));
                this.removeAllExtraFonctionalPropertiesCurrentlyProcessing = false;
              }
            }},
            portTypes: {
              get: function () {
                return _.kotlin.toList(this._portTypes.values());
              },
              set: function (portTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (portTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_portTypes(portTypesP, true, true);
              }
            },
            internal_portTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._portTypes.values(), portTypesP)) {
                this._portTypes.clear();
                {
                  var tmp$0 = portTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._portTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
                }
              }
            }},
            doAddPortTypes: {value: function (portTypesP) {
              var _key_ = (portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._portTypes.containsKey(_key_)) {
                this._portTypes.put(_key_, portTypesP);
              }
            }},
            addPortTypes: {value: function (portTypesP) {
              this.internal_addPortTypes(portTypesP, true, true);
            }, writable: true},
            addAllPortTypes: {value: function (portTypesP) {
              this.internal_addAllPortTypes(portTypesP, true, true);
            }, writable: true},
            internal_addPortTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddPortTypes(portTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
              }
            }},
            internal_addAllPortTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = portTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddPortTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = portTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddPortTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
              }
            }},
            removePortTypes: {value: function (portTypesP) {
              this.internal_removePortTypes(portTypesP, true, true);
            }, writable: true},
            removeAllPortTypes: {value: function () {
              this.internal_removeAllPortTypes(true, true);
            }, writable: true},
            internal_removePortTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._portTypes.size() !== 0 && this._portTypes.containsKey((portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._portTypes.remove((portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
                }
              }
            }},
            internal_removeAllPortTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.portTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._portTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addExtraFonctionalProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllExtraFonctionalProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeExtraFonctionalProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllExtraFonctionalProperties();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._extraFonctionalProperties.size() !== 0 && this._extraFonctionalProperties.containsKey(value)) {
                    var obj = this._extraFonctionalProperties.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._extraFonctionalProperties.remove(value);
                    this._extraFonctionalProperties.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_portTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addPortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllPortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removePortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllPortTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._portTypes.size() !== 0 && this._portTypes.containsKey(value)) {
                    var obj_0 = this._portTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._portTypes.remove(value);
                    this._portTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findExtraFonctionalPropertiesByID: {value: function (key) {
              return this._extraFonctionalProperties.get(key);
            }, writable: true},
            findPortTypesByID: {value: function (key) {
              return this._portTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                return this.findExtraFonctionalPropertiesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_portTypes) {
                return this.findPortTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties, _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty);
                {
                  var tmp$0 = this._extraFonctionalProperties.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._extraFonctionalProperties.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_portTypes, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$1 = this._portTypes.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._portTypes.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_portTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_portTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_IntegrationPattern;
            }, writable: true}
          })},
          ChannelTypeImpl: {value: Kotlin.createClass([classes.cv, classes.cr], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$factoryBean', {value: null, writable: true});
            Object.defineProperty(this, '$bean', {value: null, writable: true});
            Object.defineProperty(this, '$abstract', {value: null, writable: true});
            Object.defineProperty(this, '$startMethod', {value: null, writable: true});
            Object.defineProperty(this, '$stopMethod', {value: null, writable: true});
            Object.defineProperty(this, '$updateMethod', {value: null, writable: true});
            Object.defineProperty(this, '$lowerBindings', {value: null, writable: true});
            Object.defineProperty(this, '$upperBindings', {value: null, writable: true});
            Object.defineProperty(this, '$lowerFragments', {value: null, writable: true});
            Object.defineProperty(this, '$upperFragments', {value: null, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$dictionaryType', {value: null, writable: true});
            Object.defineProperty(this, '_superTypes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.ChannelTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            }},
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            }},
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            }},
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            }},
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            }},
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            }},
            lowerBindings: {
              get: function () {
                return this.$lowerBindings;
              },
              set: function (iP) {
                this.internal_lowerBindings(iP, true);
              }
            },
            internal_lowerBindings: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.lowerBindings) {
                var oldPath = this.path();
                this.$lowerBindings = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lowerBindings, this.lowerBindings));
                }
              }
            }},
            upperBindings: {
              get: function () {
                return this.$upperBindings;
              },
              set: function (iP) {
                this.internal_upperBindings(iP, true);
              }
            },
            internal_upperBindings: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.upperBindings) {
                var oldPath = this.path();
                this.$upperBindings = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_upperBindings, this.upperBindings));
                }
              }
            }},
            lowerFragments: {
              get: function () {
                return this.$lowerFragments;
              },
              set: function (iP) {
                this.internal_lowerFragments(iP, true);
              }
            },
            internal_lowerFragments: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.lowerFragments) {
                var oldPath = this.path();
                this.$lowerFragments = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lowerFragments, this.lowerFragments));
                }
              }
            }},
            upperFragments: {
              get: function () {
                return this.$upperFragments;
              },
              set: function (iP) {
                this.internal_upperFragments(iP, true);
              }
            },
            internal_upperFragments: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.upperFragments) {
                var oldPath = this.path();
                this.$upperFragments = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_upperFragments, this.upperFragments));
                }
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            }},
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: {value: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            }},
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            doAddSuperTypes: {value: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            }},
            addSuperTypes: {value: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            }, writable: true},
            addAllSuperTypes: {value: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            }, writable: true},
            internal_addSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            internal_addAllSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            removeSuperTypes: {value: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            }, writable: true},
            removeAllSuperTypes: {value: function () {
              this.internal_removeAllSuperTypes(true, true);
            }, writable: true},
            internal_removeSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            internal_removeAllSuperTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lowerBindings) {
                this.internal_lowerBindings(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_upperBindings) {
                this.internal_upperBindings(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lowerFragments) {
                this.internal_lowerFragments(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_upperFragments) {
                this.internal_upperFragments(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findSuperTypesByID: {value: function (key) {
              return this._superTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._deployUnits.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$1 = this._superTypes.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.upperFragments, _.org.kevoree.util.Constants.Att_upperFragments, this);
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.upperBindings, _.org.kevoree.util.Constants.Att_upperBindings, this);
              visitor.visit(this.lowerBindings, _.org.kevoree.util.Constants.Att_lowerBindings, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.lowerFragments, _.org.kevoree.util.Constants.Att_lowerFragments, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ChannelType;
            }, writable: true}
          })},
          ServicePortTypeImpl: {value: Kotlin.createClass([classes.cv, classes.cq], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$factoryBean', {value: null, writable: true});
            Object.defineProperty(this, '$bean', {value: null, writable: true});
            Object.defineProperty(this, '$abstract', {value: null, writable: true});
            Object.defineProperty(this, '$synchrone', {value: null, writable: true});
            Object.defineProperty(this, '$interface', {value: null, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$dictionaryType', {value: null, writable: true});
            Object.defineProperty(this, '_superTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '_operations', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllOperationsCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.ServicePortTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1, tmp$2;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._operations) != null ? tmp$2.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            }},
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            }},
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            }},
            synchrone: {
              get: function () {
                return this.$synchrone;
              },
              set: function (iP) {
                this.internal_synchrone(iP, true);
              }
            },
            internal_synchrone: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.synchrone)) {
                var oldPath = this.path();
                this.$synchrone = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_synchrone, this.synchrone));
                }
              }
            }},
            interface: {
              get: function () {
                return this.$interface;
              },
              set: function (iP) {
                this.internal_interface(iP, true);
              }
            },
            internal_interface: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.interface)) {
                var oldPath = this.path();
                this.$interface = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_interface, this.interface));
                }
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            }},
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: {value: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            }},
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            doAddSuperTypes: {value: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            }},
            addSuperTypes: {value: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            }, writable: true},
            addAllSuperTypes: {value: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            }, writable: true},
            internal_addSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            internal_addAllSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            removeSuperTypes: {value: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            }, writable: true},
            removeAllSuperTypes: {value: function () {
              this.internal_removeAllSuperTypes(true, true);
            }, writable: true},
            internal_removeSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            internal_removeAllSuperTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            }},
            operations: {
              get: function () {
                return _.kotlin.toList(this._operations.values());
              },
              set: function (operationsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (operationsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_operations(operationsP, true, true);
              }
            },
            internal_operations: {value: function (operationsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._operations.values(), operationsP)) {
                this._operations.clear();
                {
                  var tmp$0 = operationsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._operations.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_operations, el), _.org.kevoree.util.Constants.Ref_operations);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP));
                }
              }
            }},
            doAddOperations: {value: function (operationsP) {
              var _key_ = (operationsP != null ? operationsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._operations.containsKey(_key_)) {
                this._operations.put(_key_, operationsP);
                (operationsP != null ? operationsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_operations, operationsP), _.org.kevoree.util.Constants.Ref_operations);
              }
            }},
            addOperations: {value: function (operationsP) {
              this.internal_addOperations(operationsP, true, true);
            }, writable: true},
            addAllOperations: {value: function (operationsP) {
              this.internal_addAllOperations(operationsP, true, true);
            }, writable: true},
            internal_addOperations: {value: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddOperations(operationsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP));
              }
            }},
            internal_addAllOperations: {value: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = operationsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddOperations(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = operationsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddOperations(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP));
              }
            }},
            removeOperations: {value: function (operationsP) {
              this.internal_removeOperations(operationsP, true, true);
            }, writable: true},
            removeAllOperations: {value: function () {
              this.internal_removeAllOperations(true, true);
            }, writable: true},
            internal_removeOperations: {value: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._operations.size() !== 0 && this._operations.containsKey((operationsP != null ? operationsP : Kotlin.throwNPE()).internalGetKey())) {
                this._operations.remove((operationsP != null ? operationsP : Kotlin.throwNPE()).internalGetKey());
                ((operationsP != null ? operationsP : Kotlin.throwNPE()) != null ? operationsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllOperationsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP));
                }
              }
            }},
            internal_removeAllOperations: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllOperationsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.operations) != null ? tmp$0 : Kotlin.throwNPE();
              this._operations.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, temp_els));
                this.removeAllOperationsCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_synchrone) {
                this.internal_synchrone(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_interface) {
                this.internal_interface(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_operations) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllOperations();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._operations.size() !== 0 && this._operations.containsKey(value)) {
                    var obj_1 = this._operations.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._operations.remove(value);
                    this._operations.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findSuperTypesByID: {value: function (key) {
              return this._superTypes.get(key);
            }, writable: true},
            findOperationsByID: {value: function (key) {
              return this._operations.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_operations) {
                return this.findOperationsByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_operations, _.org.kevoree.util.Constants.org_kevoree_Operation);
                {
                  var tmp$0 = this._operations.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._operations.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_operations);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_operations);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$1 = this._deployUnits.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$2 = this._superTypes.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.synchrone, _.org.kevoree.util.Constants.Att_synchrone, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.interface, _.org.kevoree.util.Constants.Att_interface, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ServicePortType;
            }, writable: true}
          })},
          NamedElementImpl: {value: Kotlin.createClass([classes.cv, classes.cl], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.NamedElementImpl.prototype */ {
            delete: {value: function () {
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NamedElement;
            }, writable: true}
          })},
          GroupImpl: {value: Kotlin.createClass([classes.cv, classes.c1c], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$metaData', {value: null, writable: true});
            Object.defineProperty(this, '$started', {value: true, writable: true});
            Object.defineProperty(this, '$typeDefinition', {value: null, writable: true});
            Object.defineProperty(this, '$dictionary', {value: null, writable: true});
            Object.defineProperty(this, '_subNodes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.GroupImpl.prototype */ {
            delete: {value: function () {
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$0;
              (tmp$0 = this._subNodes) != null ? tmp$0.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            }},
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            }},
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: {value: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            }},
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: {value: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            }},
            subNodes: {
              get: function () {
                return _.kotlin.toList(this._subNodes.values());
              },
              set: function (subNodesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (subNodesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_subNodes(subNodesP, true, true);
              }
            },
            internal_subNodes: {value: function (subNodesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._subNodes.values(), subNodesP)) {
                this._subNodes.clear();
                {
                  var tmp$0 = subNodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._subNodes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP));
                }
              }
            }},
            doAddSubNodes: {value: function (subNodesP) {
              var _key_ = (subNodesP != null ? subNodesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._subNodes.containsKey(_key_)) {
                this._subNodes.put(_key_, subNodesP);
              }
            }},
            addSubNodes: {value: function (subNodesP) {
              this.internal_addSubNodes(subNodesP, true, true);
            }, writable: true},
            addAllSubNodes: {value: function (subNodesP) {
              this.internal_addAllSubNodes(subNodesP, true, true);
            }, writable: true},
            internal_addSubNodes: {value: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSubNodes(subNodesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP));
              }
            }},
            internal_addAllSubNodes: {value: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = subNodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSubNodes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = subNodesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSubNodes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP));
              }
            }},
            removeSubNodes: {value: function (subNodesP) {
              this.internal_removeSubNodes(subNodesP, true, true);
            }, writable: true},
            removeAllSubNodes: {value: function () {
              this.internal_removeAllSubNodes(true, true);
            }, writable: true},
            internal_removeSubNodes: {value: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._subNodes.size() !== 0 && this._subNodes.containsKey((subNodesP != null ? subNodesP : Kotlin.throwNPE()).internalGetKey())) {
                this._subNodes.remove((subNodesP != null ? subNodesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP));
                }
              }
            }},
            internal_removeAllSubNodes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.subNodes) != null ? tmp$0 : Kotlin.throwNPE();
              this._subNodes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_subNodes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSubNodes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._subNodes.size() !== 0 && this._subNodes.containsKey(value)) {
                    var obj = this._subNodes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._subNodes.remove(value);
                    this._subNodes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findSubNodesByID: {value: function (key) {
              return this._subNodes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_subNodes) {
                return this.findSubNodesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_subNodes, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                {
                  var tmp$0 = this._subNodes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._subNodes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_subNodes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_subNodes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Group;
            }, writable: true}
          })},
          NodeNetworkImpl: {value: Kotlin.createClass([classes.cv, classes.cy], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_link', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllLinkCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '$initBy', {value: null, writable: true});
            Object.defineProperty(this, '$target', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.NodeNetworkImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._link) != null ? tmp$0.clear() : null;
              this.initBy = null;
              this.target = null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            link: {
              get: function () {
                return _.kotlin.toList(this._link.values());
              },
              set: function (linkP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (linkP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_link(linkP, true, true);
              }
            },
            internal_link: {value: function (linkP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._link.values(), linkP)) {
                this._link.clear();
                {
                  var tmp$0 = linkP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._link.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_link, el), _.org.kevoree.util.Constants.Ref_link);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP));
                }
              }
            }},
            doAddLink: {value: function (linkP) {
              var _key_ = (linkP != null ? linkP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._link.containsKey(_key_)) {
                this._link.put(_key_, linkP);
                (linkP != null ? linkP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_link, linkP), _.org.kevoree.util.Constants.Ref_link);
              }
            }},
            addLink: {value: function (linkP) {
              this.internal_addLink(linkP, true, true);
            }, writable: true},
            addAllLink: {value: function (linkP) {
              this.internal_addAllLink(linkP, true, true);
            }, writable: true},
            internal_addLink: {value: function (linkP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddLink(linkP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP));
              }
            }},
            internal_addAllLink: {value: function (linkP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = linkP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddLink(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = linkP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddLink(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP));
              }
            }},
            removeLink: {value: function (linkP) {
              this.internal_removeLink(linkP, true, true);
            }, writable: true},
            removeAllLink: {value: function () {
              this.internal_removeAllLink(true, true);
            }, writable: true},
            internal_removeLink: {value: function (linkP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._link.size() !== 0 && this._link.containsKey((linkP != null ? linkP : Kotlin.throwNPE()).internalGetKey())) {
                this._link.remove((linkP != null ? linkP : Kotlin.throwNPE()).internalGetKey());
                ((linkP != null ? linkP : Kotlin.throwNPE()) != null ? linkP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllLinkCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP));
                }
              }
            }},
            internal_removeAllLink: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllLinkCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.link) != null ? tmp$0 : Kotlin.throwNPE();
              this._link.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, temp_els));
                this.removeAllLinkCurrentlyProcessing = false;
              }
            }},
            initBy: {
              get: function () {
                return this.$initBy;
              },
              set: function (initByP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_initBy(initByP, true, true);
              }
            },
            internal_initBy: {value: function (initByP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$initBy, initByP)) {
                this.$initBy = initByP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_initBy, initByP));
                }
              }
            }},
            target: {
              get: function () {
                return this.$target;
              },
              set: function (targetP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_target(targetP, true, true);
              }
            },
            internal_target: {value: function (targetP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$target, targetP)) {
                this.$target = targetP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_target, targetP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_link) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addLink(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllLink(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeLink(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllLink();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._link.size() !== 0 && this._link.containsKey(value)) {
                    var obj = this._link.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._link.remove(value);
                    this._link.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_initBy) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_initBy(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_initBy(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_initBy(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_target) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_target(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_target(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_target(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findLinkByID: {value: function (key) {
              return this._link.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_link) {
                return this.findLinkByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_initBy) {
                var objFound = this.initBy;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_target) {
                var objFound_0 = this.target;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_link, _.org.kevoree.util.Constants.org_kevoree_NodeLink);
                {
                  var tmp$0 = this._link.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._link.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_link);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_link);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_initBy, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.initBy, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_initBy);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_initBy);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_target, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.target, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_target);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_target);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NodeNetwork;
            }, writable: true}
          })},
          NetworkPropertyImpl: {value: Kotlin.createClass([classes.cv, classes.cp], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$value', {value: null, writable: true});
            Object.defineProperty(this, '$lastCheck', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.NetworkPropertyImpl.prototype */ {
            delete: {value: function () {
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            value: {
              get: function () {
                return this.$value;
              },
              set: function (iP) {
                this.internal_value(iP, true);
              }
            },
            internal_value: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.value)) {
                var oldPath = this.path();
                this.$value = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_value, this.value));
                }
              }
            }},
            lastCheck: {
              get: function () {
                return this.$lastCheck;
              },
              set: function (iP) {
                this.internal_lastCheck(iP, true);
              }
            },
            internal_lastCheck: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.lastCheck)) {
                var oldPath = this.path();
                this.$lastCheck = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lastCheck, this.lastCheck));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_value) {
                this.internal_value(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lastCheck) {
                this.internal_lastCheck(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.value, _.org.kevoree.util.Constants.Att_value, this);
              visitor.visit(this.lastCheck, _.org.kevoree.util.Constants.Att_lastCheck, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NetworkProperty;
            }, writable: true}
          })},
          AdaptationPrimitiveTypeImpl: {value: Kotlin.createClass([classes.cv, classes.c1h], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.AdaptationPrimitiveTypeImpl.prototype */ {
            delete: {value: function () {
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType;
            }, writable: true}
          })},
          NodeLinkImpl: {value: Kotlin.createClass([classes.cv, classes.cz], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$networkType', {value: null, writable: true});
            Object.defineProperty(this, '$estimatedRate', {value: null, writable: true});
            Object.defineProperty(this, '$lastCheck', {value: null, writable: true});
            Object.defineProperty(this, '$zoneID', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_networkProperties', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllNetworkPropertiesCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.NodeLinkImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._networkProperties) != null ? tmp$0.clear() : null;
            }, writable: true},
            networkType: {
              get: function () {
                return this.$networkType;
              },
              set: function (iP) {
                this.internal_networkType(iP, true);
              }
            },
            internal_networkType: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.networkType)) {
                var oldPath = this.path();
                this.$networkType = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_networkType, this.networkType));
                }
              }
            }},
            estimatedRate: {
              get: function () {
                return this.$estimatedRate;
              },
              set: function (iP) {
                this.internal_estimatedRate(iP, true);
              }
            },
            internal_estimatedRate: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.estimatedRate) {
                var oldPath = this.path();
                this.$estimatedRate = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_estimatedRate, this.estimatedRate));
                }
              }
            }},
            lastCheck: {
              get: function () {
                return this.$lastCheck;
              },
              set: function (iP) {
                this.internal_lastCheck(iP, true);
              }
            },
            internal_lastCheck: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.lastCheck)) {
                var oldPath = this.path();
                this.$lastCheck = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lastCheck, this.lastCheck));
                }
              }
            }},
            zoneID: {
              get: function () {
                return this.$zoneID;
              },
              set: function (iP) {
                this.internal_zoneID(iP, true);
              }
            },
            internal_zoneID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.zoneID)) {
                var oldPath = this.path();
                this.$zoneID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_zoneID, this.zoneID));
                }
              }
            }},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            networkProperties: {
              get: function () {
                return _.kotlin.toList(this._networkProperties.values());
              },
              set: function (networkPropertiesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (networkPropertiesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_networkProperties(networkPropertiesP, true, true);
              }
            },
            internal_networkProperties: {value: function (networkPropertiesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._networkProperties.values(), networkPropertiesP)) {
                this._networkProperties.clear();
                {
                  var tmp$0 = networkPropertiesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._networkProperties.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_networkProperties, el), _.org.kevoree.util.Constants.Ref_networkProperties);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP));
                }
              }
            }},
            doAddNetworkProperties: {value: function (networkPropertiesP) {
              var _key_ = (networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._networkProperties.containsKey(_key_)) {
                this._networkProperties.put(_key_, networkPropertiesP);
                (networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP), _.org.kevoree.util.Constants.Ref_networkProperties);
              }
            }},
            addNetworkProperties: {value: function (networkPropertiesP) {
              this.internal_addNetworkProperties(networkPropertiesP, true, true);
            }, writable: true},
            addAllNetworkProperties: {value: function (networkPropertiesP) {
              this.internal_addAllNetworkProperties(networkPropertiesP, true, true);
            }, writable: true},
            internal_addNetworkProperties: {value: function (networkPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNetworkProperties(networkPropertiesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP));
              }
            }},
            internal_addAllNetworkProperties: {value: function (networkPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = networkPropertiesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNetworkProperties(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = networkPropertiesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNetworkProperties(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP));
              }
            }},
            removeNetworkProperties: {value: function (networkPropertiesP) {
              this.internal_removeNetworkProperties(networkPropertiesP, true, true);
            }, writable: true},
            removeAllNetworkProperties: {value: function () {
              this.internal_removeAllNetworkProperties(true, true);
            }, writable: true},
            internal_removeNetworkProperties: {value: function (networkPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._networkProperties.size() !== 0 && this._networkProperties.containsKey((networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).internalGetKey())) {
                this._networkProperties.remove((networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).internalGetKey());
                ((networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()) != null ? networkPropertiesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllNetworkPropertiesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP));
                }
              }
            }},
            internal_removeAllNetworkProperties: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNetworkPropertiesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.networkProperties) != null ? tmp$0 : Kotlin.throwNPE();
              this._networkProperties.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, temp_els));
                this.removeAllNetworkPropertiesCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_networkType) {
                this.internal_networkType(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_estimatedRate) {
                this.internal_estimatedRate(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lastCheck) {
                this.internal_lastCheck(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_zoneID) {
                this.internal_zoneID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_networkProperties) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addNetworkProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllNetworkProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeNetworkProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllNetworkProperties();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._networkProperties.size() !== 0 && this._networkProperties.containsKey(value)) {
                    var obj = this._networkProperties.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._networkProperties.remove(value);
                    this._networkProperties.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findNetworkPropertiesByID: {value: function (key) {
              return this._networkProperties.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_networkProperties) {
                return this.findNetworkPropertiesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_networkProperties, _.org.kevoree.util.Constants.org_kevoree_NetworkProperty);
                {
                  var tmp$0 = this._networkProperties.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._networkProperties.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_networkProperties);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_networkProperties);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.estimatedRate, _.org.kevoree.util.Constants.Att_estimatedRate, this);
              visitor.visit(this.networkType, _.org.kevoree.util.Constants.Att_networkType, this);
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.lastCheck, _.org.kevoree.util.Constants.Att_lastCheck, this);
              visitor.visit(this.zoneID, _.org.kevoree.util.Constants.Att_zoneID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NodeLink;
            }, writable: true}
          })},
          DictionaryValueImpl: {value: Kotlin.createClass([classes.cv, classes.c1a], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$value', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '$attribute', {value: null, writable: true});
            Object.defineProperty(this, '$targetNode', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.DictionaryValueImpl.prototype */ {
            delete: {value: function () {
              this.attribute = null;
              this.targetNode = null;
            }, writable: true},
            value: {
              get: function () {
                return this.$value;
              },
              set: function (iP) {
                this.internal_value(iP, true);
              }
            },
            internal_value: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.value)) {
                var oldPath = this.path();
                this.$value = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_value, this.value));
                }
              }
            }},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            attribute: {
              get: function () {
                return this.$attribute;
              },
              set: function (attributeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_attribute(attributeP, true, true);
              }
            },
            internal_attribute: {value: function (attributeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$attribute, attributeP)) {
                this.$attribute = attributeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_attribute, attributeP));
                }
              }
            }},
            targetNode: {
              get: function () {
                return this.$targetNode;
              },
              set: function (targetNodeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_targetNode(targetNodeP, true, true);
              }
            },
            internal_targetNode: {value: function (targetNodeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$targetNode, targetNodeP)) {
                this.$targetNode = targetNodeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_targetNode, targetNodeP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_value) {
                this.internal_value(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_attribute) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_attribute(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_attribute(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_attribute(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_targetNode) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_targetNode(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_targetNode(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_targetNode(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_attribute) {
                var objFound = this.attribute;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_targetNode) {
                var objFound_0 = this.targetNode;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_attribute, _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute);
                this.internal_visit(visitor, this.attribute, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_attribute);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_attribute);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_targetNode, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.targetNode, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_targetNode);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_targetNode);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.value, _.org.kevoree.util.Constants.Att_value, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryValue;
            }, writable: true}
          })},
          OperationImpl: {value: Kotlin.createClass([classes.cv, classes.c12], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '_parameters', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllParametersCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '$returnType', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.OperationImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._parameters) != null ? tmp$0.clear() : null;
              this.returnType = null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            parameters: {
              get: function () {
                return _.kotlin.toList(this._parameters.values());
              },
              set: function (parametersP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (parametersP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_parameters(parametersP, true, true);
              }
            },
            internal_parameters: {value: function (parametersP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._parameters.values(), parametersP)) {
                this._parameters.clear();
                {
                  var tmp$0 = parametersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._parameters.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_parameters, el), _.org.kevoree.util.Constants.Ref_parameters);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP));
                }
              }
            }},
            doAddParameters: {value: function (parametersP) {
              var _key_ = (parametersP != null ? parametersP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._parameters.containsKey(_key_)) {
                this._parameters.put(_key_, parametersP);
                (parametersP != null ? parametersP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_parameters, parametersP), _.org.kevoree.util.Constants.Ref_parameters);
              }
            }},
            addParameters: {value: function (parametersP) {
              this.internal_addParameters(parametersP, true, true);
            }, writable: true},
            addAllParameters: {value: function (parametersP) {
              this.internal_addAllParameters(parametersP, true, true);
            }, writable: true},
            internal_addParameters: {value: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddParameters(parametersP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP));
              }
            }},
            internal_addAllParameters: {value: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = parametersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddParameters(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = parametersP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddParameters(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP));
              }
            }},
            removeParameters: {value: function (parametersP) {
              this.internal_removeParameters(parametersP, true, true);
            }, writable: true},
            removeAllParameters: {value: function () {
              this.internal_removeAllParameters(true, true);
            }, writable: true},
            internal_removeParameters: {value: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._parameters.size() !== 0 && this._parameters.containsKey((parametersP != null ? parametersP : Kotlin.throwNPE()).internalGetKey())) {
                this._parameters.remove((parametersP != null ? parametersP : Kotlin.throwNPE()).internalGetKey());
                ((parametersP != null ? parametersP : Kotlin.throwNPE()) != null ? parametersP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllParametersCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP));
                }
              }
            }},
            internal_removeAllParameters: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllParametersCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.parameters) != null ? tmp$0 : Kotlin.throwNPE();
              this._parameters.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, temp_els));
                this.removeAllParametersCurrentlyProcessing = false;
              }
            }},
            returnType: {
              get: function () {
                return this.$returnType;
              },
              set: function (returnTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_returnType(returnTypeP, true, true);
              }
            },
            internal_returnType: {value: function (returnTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$returnType, returnTypeP)) {
                this.$returnType = returnTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_returnType, returnTypeP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_parameters) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllParameters();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._parameters.size() !== 0 && this._parameters.containsKey(value)) {
                    var obj = this._parameters.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._parameters.remove(value);
                    this._parameters.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_returnType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_returnType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_returnType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_returnType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findParametersByID: {value: function (key) {
              return this._parameters.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_parameters) {
                return this.findParametersByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_returnType) {
                var objFound = this.returnType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_parameters, _.org.kevoree.util.Constants.org_kevoree_Parameter);
                {
                  var tmp$0 = this._parameters.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._parameters.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_parameters);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_parameters);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_returnType, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                this.internal_visit(visitor, this.returnType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_returnType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_returnType);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Operation;
            }, writable: true}
          })},
          DefaultKevoreeFactory: {value: Kotlin.createClass(classes.c19, null, /** @lends _.org.kevoree.impl.DefaultKevoreeFactory.prototype */ {
            getVersion: {value: function () {
              return '2.0.12-SNAPSHOT';
            }, writable: true},
            createComponentInstance: {value: function () {
              return _.org.kevoree.impl.ComponentInstanceImpl();
            }, writable: true},
            createComponentType: {value: function () {
              return _.org.kevoree.impl.ComponentTypeImpl();
            }, writable: true},
            createContainerNode: {value: function () {
              return _.org.kevoree.impl.ContainerNodeImpl();
            }, writable: true},
            createContainerRoot: {value: function () {
              return _.org.kevoree.impl.ContainerRootImpl();
            }, writable: true},
            createPort: {value: function () {
              return _.org.kevoree.impl.PortImpl();
            }, writable: true},
            createNamespace: {value: function () {
              return _.org.kevoree.impl.NamespaceImpl();
            }, writable: true},
            createDictionary: {value: function () {
              return _.org.kevoree.impl.DictionaryImpl();
            }, writable: true},
            createDictionaryType: {value: function () {
              return _.org.kevoree.impl.DictionaryTypeImpl();
            }, writable: true},
            createDictionaryAttribute: {value: function () {
              return _.org.kevoree.impl.DictionaryAttributeImpl();
            }, writable: true},
            createDictionaryValue: {value: function () {
              return _.org.kevoree.impl.DictionaryValueImpl();
            }, writable: true},
            createCompositeType: {value: function () {
              return _.org.kevoree.impl.CompositeTypeImpl();
            }, writable: true},
            createPortTypeRef: {value: function () {
              return _.org.kevoree.impl.PortTypeRefImpl();
            }, writable: true},
            createWire: {value: function () {
              return _.org.kevoree.impl.WireImpl();
            }, writable: true},
            createServicePortType: {value: function () {
              return _.org.kevoree.impl.ServicePortTypeImpl();
            }, writable: true},
            createOperation: {value: function () {
              return _.org.kevoree.impl.OperationImpl();
            }, writable: true},
            createParameter: {value: function () {
              return _.org.kevoree.impl.ParameterImpl();
            }, writable: true},
            createTypedElement: {value: function () {
              return _.org.kevoree.impl.TypedElementImpl();
            }, writable: true},
            createMessagePortType: {value: function () {
              return _.org.kevoree.impl.MessagePortTypeImpl();
            }, writable: true},
            createRepository: {value: function () {
              return _.org.kevoree.impl.RepositoryImpl();
            }, writable: true},
            createDeployUnit: {value: function () {
              return _.org.kevoree.impl.DeployUnitImpl();
            }, writable: true},
            createTypeLibrary: {value: function () {
              return _.org.kevoree.impl.TypeLibraryImpl();
            }, writable: true},
            createNamedElement: {value: function () {
              return _.org.kevoree.impl.NamedElementImpl();
            }, writable: true},
            createIntegrationPattern: {value: function () {
              return _.org.kevoree.impl.IntegrationPatternImpl();
            }, writable: true},
            createExtraFonctionalProperty: {value: function () {
              return _.org.kevoree.impl.ExtraFonctionalPropertyImpl();
            }, writable: true},
            createPortTypeMapping: {value: function () {
              return _.org.kevoree.impl.PortTypeMappingImpl();
            }, writable: true},
            createChannel: {value: function () {
              return _.org.kevoree.impl.ChannelImpl();
            }, writable: true},
            createMBinding: {value: function () {
              return _.org.kevoree.impl.MBindingImpl();
            }, writable: true},
            createNodeNetwork: {value: function () {
              return _.org.kevoree.impl.NodeNetworkImpl();
            }, writable: true},
            createNodeLink: {value: function () {
              return _.org.kevoree.impl.NodeLinkImpl();
            }, writable: true},
            createNetworkProperty: {value: function () {
              return _.org.kevoree.impl.NetworkPropertyImpl();
            }, writable: true},
            createChannelType: {value: function () {
              return _.org.kevoree.impl.ChannelTypeImpl();
            }, writable: true},
            createInstance: {value: function () {
              return _.org.kevoree.impl.InstanceImpl();
            }, writable: true},
            createGroup: {value: function () {
              return _.org.kevoree.impl.GroupImpl();
            }, writable: true},
            createGroupType: {value: function () {
              return _.org.kevoree.impl.GroupTypeImpl();
            }, writable: true},
            createNodeType: {value: function () {
              return _.org.kevoree.impl.NodeTypeImpl();
            }, writable: true},
            createAdaptationPrimitiveType: {value: function () {
              return _.org.kevoree.impl.AdaptationPrimitiveTypeImpl();
            }, writable: true},
            createAdaptationPrimitiveTypeRef: {value: function () {
              return _.org.kevoree.impl.AdaptationPrimitiveTypeRefImpl();
            }, writable: true},
            create: {value: function (metaClassName) {
              if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ComponentInstance) {
                return this.createComponentInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ComponentInstance) {
                return this.createComponentInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ComponentType) {
                return this.createComponentType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ComponentType) {
                return this.createComponentType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ContainerNode) {
                return this.createContainerNode();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ContainerNode) {
                return this.createContainerNode();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ContainerRoot) {
                return this.createContainerRoot();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ContainerRoot) {
                return this.createContainerRoot();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Port) {
                return this.createPort();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Port) {
                return this.createPort();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Namespace) {
                return this.createNamespace();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Namespace) {
                return this.createNamespace();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Dictionary) {
                return this.createDictionary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Dictionary) {
                return this.createDictionary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryType) {
                return this.createDictionaryType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DictionaryType) {
                return this.createDictionaryType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute) {
                return this.createDictionaryAttribute();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DictionaryAttribute) {
                return this.createDictionaryAttribute();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryValue) {
                return this.createDictionaryValue();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DictionaryValue) {
                return this.createDictionaryValue();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_CompositeType) {
                return this.createCompositeType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_CompositeType) {
                return this.createCompositeType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_PortTypeRef) {
                return this.createPortTypeRef();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_PortTypeRef) {
                return this.createPortTypeRef();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Wire) {
                return this.createWire();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Wire) {
                return this.createWire();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ServicePortType) {
                return this.createServicePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ServicePortType) {
                return this.createServicePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Operation) {
                return this.createOperation();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Operation) {
                return this.createOperation();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Parameter) {
                return this.createParameter();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Parameter) {
                return this.createParameter();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_TypedElement) {
                return this.createTypedElement();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_TypedElement) {
                return this.createTypedElement();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_MessagePortType) {
                return this.createMessagePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_MessagePortType) {
                return this.createMessagePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Repository) {
                return this.createRepository();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Repository) {
                return this.createRepository();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DeployUnit) {
                return this.createDeployUnit();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DeployUnit) {
                return this.createDeployUnit();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_TypeLibrary) {
                return this.createTypeLibrary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_TypeLibrary) {
                return this.createTypeLibrary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NamedElement) {
                return this.createNamedElement();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NamedElement) {
                return this.createNamedElement();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_IntegrationPattern) {
                return this.createIntegrationPattern();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_IntegrationPattern) {
                return this.createIntegrationPattern();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty) {
                return this.createExtraFonctionalProperty();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ExtraFonctionalProperty) {
                return this.createExtraFonctionalProperty();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping) {
                return this.createPortTypeMapping();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_PortTypeMapping) {
                return this.createPortTypeMapping();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Channel) {
                return this.createChannel();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Channel) {
                return this.createChannel();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_MBinding) {
                return this.createMBinding();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_MBinding) {
                return this.createMBinding();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NodeNetwork) {
                return this.createNodeNetwork();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NodeNetwork) {
                return this.createNodeNetwork();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NodeLink) {
                return this.createNodeLink();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NodeLink) {
                return this.createNodeLink();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NetworkProperty) {
                return this.createNetworkProperty();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NetworkProperty) {
                return this.createNetworkProperty();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ChannelType) {
                return this.createChannelType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ChannelType) {
                return this.createChannelType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Instance) {
                return this.createInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Instance) {
                return this.createInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Group) {
                return this.createGroup();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Group) {
                return this.createGroup();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_GroupType) {
                return this.createGroupType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_GroupType) {
                return this.createGroupType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NodeType) {
                return this.createNodeType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NodeType) {
                return this.createNodeType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType) {
                return this.createAdaptationPrimitiveType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_AdaptationPrimitiveType) {
                return this.createAdaptationPrimitiveType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveTypeRef) {
                return this.createAdaptationPrimitiveTypeRef();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_AdaptationPrimitiveTypeRef) {
                return this.createAdaptationPrimitiveTypeRef();
              }
               else {
                return null;
              }
            }, writable: true}
          })},
          ContainerRootImpl: {value: Kotlin.createClass([classes.cv, classes.ct], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_nodes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllNodesCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_typeDefinitions', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllTypeDefinitionsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_repositories', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllRepositoriesCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_dataTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllDataTypesCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_libraries', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllLibrariesCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_hubs', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllHubsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_mBindings', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllMBindingsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllDeployUnitsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_nodeNetworks', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllNodeNetworksCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_groups', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllGroupsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_adaptationPrimitiveTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllAdaptationPrimitiveTypesCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.ContainerRootImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7, tmp$8, tmp$9, tmp$10;
              (tmp$0 = this._nodes) != null ? tmp$0.clear() : null;
              (tmp$1 = this._typeDefinitions) != null ? tmp$1.clear() : null;
              (tmp$2 = this._repositories) != null ? tmp$2.clear() : null;
              (tmp$3 = this._dataTypes) != null ? tmp$3.clear() : null;
              (tmp$4 = this._libraries) != null ? tmp$4.clear() : null;
              (tmp$5 = this._hubs) != null ? tmp$5.clear() : null;
              (tmp$6 = this._mBindings) != null ? tmp$6.clear() : null;
              (tmp$7 = this._deployUnits) != null ? tmp$7.clear() : null;
              (tmp$8 = this._nodeNetworks) != null ? tmp$8.clear() : null;
              (tmp$9 = this._groups) != null ? tmp$9.clear() : null;
              (tmp$10 = this._adaptationPrimitiveTypes) != null ? tmp$10.clear() : null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            nodes: {
              get: function () {
                return _.kotlin.toList(this._nodes.values());
              },
              set: function (nodesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (nodesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_nodes(nodesP, true, true);
              }
            },
            internal_nodes: {value: function (nodesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._nodes.values(), nodesP)) {
                this._nodes.clear();
                {
                  var tmp$0 = nodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._nodes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_nodes, el), _.org.kevoree.util.Constants.Ref_nodes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP));
                }
              }
            }},
            doAddNodes: {value: function (nodesP) {
              var _key_ = (nodesP != null ? nodesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._nodes.containsKey(_key_)) {
                this._nodes.put(_key_, nodesP);
                (nodesP != null ? nodesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_nodes, nodesP), _.org.kevoree.util.Constants.Ref_nodes);
              }
            }},
            addNodes: {value: function (nodesP) {
              this.internal_addNodes(nodesP, true, true);
            }, writable: true},
            addAllNodes: {value: function (nodesP) {
              this.internal_addAllNodes(nodesP, true, true);
            }, writable: true},
            internal_addNodes: {value: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNodes(nodesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP));
              }
            }},
            internal_addAllNodes: {value: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = nodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNodes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = nodesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNodes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP));
              }
            }},
            removeNodes: {value: function (nodesP) {
              this.internal_removeNodes(nodesP, true, true);
            }, writable: true},
            removeAllNodes: {value: function () {
              this.internal_removeAllNodes(true, true);
            }, writable: true},
            internal_removeNodes: {value: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._nodes.size() !== 0 && this._nodes.containsKey((nodesP != null ? nodesP : Kotlin.throwNPE()).internalGetKey())) {
                this._nodes.remove((nodesP != null ? nodesP : Kotlin.throwNPE()).internalGetKey());
                ((nodesP != null ? nodesP : Kotlin.throwNPE()) != null ? nodesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllNodesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP));
                }
              }
            }},
            internal_removeAllNodes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNodesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.nodes) != null ? tmp$0 : Kotlin.throwNPE();
              this._nodes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, temp_els));
                this.removeAllNodesCurrentlyProcessing = false;
              }
            }},
            typeDefinitions: {
              get: function () {
                return _.kotlin.toList(this._typeDefinitions.values());
              },
              set: function (typeDefinitionsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (typeDefinitionsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_typeDefinitions(typeDefinitionsP, true, true);
              }
            },
            internal_typeDefinitions: {value: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._typeDefinitions.values(), typeDefinitionsP)) {
                this._typeDefinitions.clear();
                {
                  var tmp$0 = typeDefinitionsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._typeDefinitions.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_typeDefinitions, el), _.org.kevoree.util.Constants.Ref_typeDefinitions);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP));
                }
              }
            }},
            doAddTypeDefinitions: {value: function (typeDefinitionsP) {
              var _key_ = (typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._typeDefinitions.containsKey(_key_)) {
                this._typeDefinitions.put(_key_, typeDefinitionsP);
                (typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP), _.org.kevoree.util.Constants.Ref_typeDefinitions);
              }
            }},
            addTypeDefinitions: {value: function (typeDefinitionsP) {
              this.internal_addTypeDefinitions(typeDefinitionsP, true, true);
            }, writable: true},
            addAllTypeDefinitions: {value: function (typeDefinitionsP) {
              this.internal_addAllTypeDefinitions(typeDefinitionsP, true, true);
            }, writable: true},
            internal_addTypeDefinitions: {value: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddTypeDefinitions(typeDefinitionsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP));
              }
            }},
            internal_addAllTypeDefinitions: {value: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = typeDefinitionsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddTypeDefinitions(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = typeDefinitionsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddTypeDefinitions(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP));
              }
            }},
            removeTypeDefinitions: {value: function (typeDefinitionsP) {
              this.internal_removeTypeDefinitions(typeDefinitionsP, true, true);
            }, writable: true},
            removeAllTypeDefinitions: {value: function () {
              this.internal_removeAllTypeDefinitions(true, true);
            }, writable: true},
            internal_removeTypeDefinitions: {value: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._typeDefinitions.size() !== 0 && this._typeDefinitions.containsKey((typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).internalGetKey())) {
                this._typeDefinitions.remove((typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).internalGetKey());
                ((typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()) != null ? typeDefinitionsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllTypeDefinitionsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP));
                }
              }
            }},
            internal_removeAllTypeDefinitions: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllTypeDefinitionsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.typeDefinitions) != null ? tmp$0 : Kotlin.throwNPE();
              this._typeDefinitions.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, temp_els));
                this.removeAllTypeDefinitionsCurrentlyProcessing = false;
              }
            }},
            repositories: {
              get: function () {
                return _.kotlin.toList(this._repositories.values());
              },
              set: function (repositoriesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (repositoriesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_repositories(repositoriesP, true, true);
              }
            },
            internal_repositories: {value: function (repositoriesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._repositories.values(), repositoriesP)) {
                this._repositories.clear();
                {
                  var tmp$0 = repositoriesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._repositories.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_repositories, el), _.org.kevoree.util.Constants.Ref_repositories);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP));
                }
              }
            }},
            doAddRepositories: {value: function (repositoriesP) {
              var _key_ = (repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._repositories.containsKey(_key_)) {
                this._repositories.put(_key_, repositoriesP);
                (repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP), _.org.kevoree.util.Constants.Ref_repositories);
              }
            }},
            addRepositories: {value: function (repositoriesP) {
              this.internal_addRepositories(repositoriesP, true, true);
            }, writable: true},
            addAllRepositories: {value: function (repositoriesP) {
              this.internal_addAllRepositories(repositoriesP, true, true);
            }, writable: true},
            internal_addRepositories: {value: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRepositories(repositoriesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP));
              }
            }},
            internal_addAllRepositories: {value: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = repositoriesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRepositories(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = repositoriesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRepositories(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP));
              }
            }},
            removeRepositories: {value: function (repositoriesP) {
              this.internal_removeRepositories(repositoriesP, true, true);
            }, writable: true},
            removeAllRepositories: {value: function () {
              this.internal_removeAllRepositories(true, true);
            }, writable: true},
            internal_removeRepositories: {value: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._repositories.size() !== 0 && this._repositories.containsKey((repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).internalGetKey())) {
                this._repositories.remove((repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).internalGetKey());
                ((repositoriesP != null ? repositoriesP : Kotlin.throwNPE()) != null ? repositoriesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRepositoriesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP));
                }
              }
            }},
            internal_removeAllRepositories: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRepositoriesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.repositories) != null ? tmp$0 : Kotlin.throwNPE();
              this._repositories.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, temp_els));
                this.removeAllRepositoriesCurrentlyProcessing = false;
              }
            }},
            dataTypes: {
              get: function () {
                return _.kotlin.toList(this._dataTypes.values());
              },
              set: function (dataTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (dataTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_dataTypes(dataTypesP, true, true);
              }
            },
            internal_dataTypes: {value: function (dataTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._dataTypes.values(), dataTypesP)) {
                this._dataTypes.clear();
                {
                  var tmp$0 = dataTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._dataTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_dataTypes, el), _.org.kevoree.util.Constants.Ref_dataTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP));
                }
              }
            }},
            doAddDataTypes: {value: function (dataTypesP) {
              var _key_ = (dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._dataTypes.containsKey(_key_)) {
                this._dataTypes.put(_key_, dataTypesP);
                (dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP), _.org.kevoree.util.Constants.Ref_dataTypes);
              }
            }},
            addDataTypes: {value: function (dataTypesP) {
              this.internal_addDataTypes(dataTypesP, true, true);
            }, writable: true},
            addAllDataTypes: {value: function (dataTypesP) {
              this.internal_addAllDataTypes(dataTypesP, true, true);
            }, writable: true},
            internal_addDataTypes: {value: function (dataTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDataTypes(dataTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP));
              }
            }},
            internal_addAllDataTypes: {value: function (dataTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = dataTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDataTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = dataTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDataTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP));
              }
            }},
            removeDataTypes: {value: function (dataTypesP) {
              this.internal_removeDataTypes(dataTypesP, true, true);
            }, writable: true},
            removeAllDataTypes: {value: function () {
              this.internal_removeAllDataTypes(true, true);
            }, writable: true},
            internal_removeDataTypes: {value: function (dataTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._dataTypes.size() !== 0 && this._dataTypes.containsKey((dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._dataTypes.remove((dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).internalGetKey());
                ((dataTypesP != null ? dataTypesP : Kotlin.throwNPE()) != null ? dataTypesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllDataTypesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP));
                }
              }
            }},
            internal_removeAllDataTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllDataTypesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.dataTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._dataTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, temp_els));
                this.removeAllDataTypesCurrentlyProcessing = false;
              }
            }},
            libraries: {
              get: function () {
                return _.kotlin.toList(this._libraries.values());
              },
              set: function (librariesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (librariesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_libraries(librariesP, true, true);
              }
            },
            internal_libraries: {value: function (librariesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._libraries.values(), librariesP)) {
                this._libraries.clear();
                {
                  var tmp$0 = librariesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._libraries.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_libraries, el), _.org.kevoree.util.Constants.Ref_libraries);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP));
                }
              }
            }},
            doAddLibraries: {value: function (librariesP) {
              var _key_ = (librariesP != null ? librariesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._libraries.containsKey(_key_)) {
                this._libraries.put(_key_, librariesP);
                (librariesP != null ? librariesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_libraries, librariesP), _.org.kevoree.util.Constants.Ref_libraries);
              }
            }},
            addLibraries: {value: function (librariesP) {
              this.internal_addLibraries(librariesP, true, true);
            }, writable: true},
            addAllLibraries: {value: function (librariesP) {
              this.internal_addAllLibraries(librariesP, true, true);
            }, writable: true},
            internal_addLibraries: {value: function (librariesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddLibraries(librariesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP));
              }
            }},
            internal_addAllLibraries: {value: function (librariesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = librariesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddLibraries(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = librariesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddLibraries(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP));
              }
            }},
            removeLibraries: {value: function (librariesP) {
              this.internal_removeLibraries(librariesP, true, true);
            }, writable: true},
            removeAllLibraries: {value: function () {
              this.internal_removeAllLibraries(true, true);
            }, writable: true},
            internal_removeLibraries: {value: function (librariesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._libraries.size() !== 0 && this._libraries.containsKey((librariesP != null ? librariesP : Kotlin.throwNPE()).internalGetKey())) {
                this._libraries.remove((librariesP != null ? librariesP : Kotlin.throwNPE()).internalGetKey());
                ((librariesP != null ? librariesP : Kotlin.throwNPE()) != null ? librariesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllLibrariesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP));
                }
              }
            }},
            internal_removeAllLibraries: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllLibrariesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.libraries) != null ? tmp$0 : Kotlin.throwNPE();
              this._libraries.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, temp_els));
                this.removeAllLibrariesCurrentlyProcessing = false;
              }
            }},
            hubs: {
              get: function () {
                return _.kotlin.toList(this._hubs.values());
              },
              set: function (hubsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (hubsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_hubs(hubsP, true, true);
              }
            },
            internal_hubs: {value: function (hubsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._hubs.values(), hubsP)) {
                this._hubs.clear();
                {
                  var tmp$0 = hubsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._hubs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_hubs, el), _.org.kevoree.util.Constants.Ref_hubs);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP));
                }
              }
            }},
            doAddHubs: {value: function (hubsP) {
              var _key_ = (hubsP != null ? hubsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._hubs.containsKey(_key_)) {
                this._hubs.put(_key_, hubsP);
                (hubsP != null ? hubsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_hubs, hubsP), _.org.kevoree.util.Constants.Ref_hubs);
              }
            }},
            addHubs: {value: function (hubsP) {
              this.internal_addHubs(hubsP, true, true);
            }, writable: true},
            addAllHubs: {value: function (hubsP) {
              this.internal_addAllHubs(hubsP, true, true);
            }, writable: true},
            internal_addHubs: {value: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddHubs(hubsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP));
              }
            }},
            internal_addAllHubs: {value: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = hubsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddHubs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = hubsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddHubs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP));
              }
            }},
            removeHubs: {value: function (hubsP) {
              this.internal_removeHubs(hubsP, true, true);
            }, writable: true},
            removeAllHubs: {value: function () {
              this.internal_removeAllHubs(true, true);
            }, writable: true},
            internal_removeHubs: {value: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._hubs.size() !== 0 && this._hubs.containsKey((hubsP != null ? hubsP : Kotlin.throwNPE()).internalGetKey())) {
                this._hubs.remove((hubsP != null ? hubsP : Kotlin.throwNPE()).internalGetKey());
                ((hubsP != null ? hubsP : Kotlin.throwNPE()) != null ? hubsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllHubsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP));
                }
              }
            }},
            internal_removeAllHubs: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllHubsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.hubs) != null ? tmp$0 : Kotlin.throwNPE();
              this._hubs.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, temp_els));
                this.removeAllHubsCurrentlyProcessing = false;
              }
            }},
            mBindings: {
              get: function () {
                return _.kotlin.toList(this._mBindings.values());
              },
              set: function (mBindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (mBindingsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_mBindings(mBindingsP, true, true);
              }
            },
            internal_mBindings: {value: function (mBindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._mBindings.values(), mBindingsP)) {
                this._mBindings.clear();
                {
                  var tmp$0 = mBindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._mBindings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_mBindings, el), _.org.kevoree.util.Constants.Ref_mBindings);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP));
                }
              }
            }},
            doAddMBindings: {value: function (mBindingsP) {
              var _key_ = (mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._mBindings.containsKey(_key_)) {
                this._mBindings.put(_key_, mBindingsP);
                (mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP), _.org.kevoree.util.Constants.Ref_mBindings);
              }
            }},
            addMBindings: {value: function (mBindingsP) {
              this.internal_addMBindings(mBindingsP, true, true);
            }, writable: true},
            addAllMBindings: {value: function (mBindingsP) {
              this.internal_addAllMBindings(mBindingsP, true, true);
            }, writable: true},
            internal_addMBindings: {value: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMBindings(mBindingsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP));
              }
            }},
            internal_addAllMBindings: {value: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = mBindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMBindings(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = mBindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP));
              }
            }},
            removeMBindings: {value: function (mBindingsP) {
              this.internal_removeMBindings(mBindingsP, true, true);
            }, writable: true},
            removeAllMBindings: {value: function () {
              this.internal_removeAllMBindings(true, true);
            }, writable: true},
            internal_removeMBindings: {value: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._mBindings.size() !== 0 && this._mBindings.containsKey((mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._mBindings.remove((mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).internalGetKey());
                ((mBindingsP != null ? mBindingsP : Kotlin.throwNPE()) != null ? mBindingsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllMBindingsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP));
                }
              }
            }},
            internal_removeAllMBindings: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMBindingsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.mBindings) != null ? tmp$0 : Kotlin.throwNPE();
              this._mBindings.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, temp_els));
                this.removeAllMBindingsCurrentlyProcessing = false;
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_deployUnits, el), _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
                (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP), _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                ((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()) != null ? deployUnitsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllDeployUnitsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllDeployUnitsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
                this.removeAllDeployUnitsCurrentlyProcessing = false;
              }
            }},
            nodeNetworks: {
              get: function () {
                return _.kotlin.toList(this._nodeNetworks.values());
              },
              set: function (nodeNetworksP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (nodeNetworksP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_nodeNetworks(nodeNetworksP, true, true);
              }
            },
            internal_nodeNetworks: {value: function (nodeNetworksP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._nodeNetworks.values(), nodeNetworksP)) {
                this._nodeNetworks.clear();
                {
                  var tmp$0 = nodeNetworksP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._nodeNetworks.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_nodeNetworks, el), _.org.kevoree.util.Constants.Ref_nodeNetworks);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP));
                }
              }
            }},
            doAddNodeNetworks: {value: function (nodeNetworksP) {
              var _key_ = (nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._nodeNetworks.containsKey(_key_)) {
                this._nodeNetworks.put(_key_, nodeNetworksP);
                (nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP), _.org.kevoree.util.Constants.Ref_nodeNetworks);
              }
            }},
            addNodeNetworks: {value: function (nodeNetworksP) {
              this.internal_addNodeNetworks(nodeNetworksP, true, true);
            }, writable: true},
            addAllNodeNetworks: {value: function (nodeNetworksP) {
              this.internal_addAllNodeNetworks(nodeNetworksP, true, true);
            }, writable: true},
            internal_addNodeNetworks: {value: function (nodeNetworksP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNodeNetworks(nodeNetworksP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP));
              }
            }},
            internal_addAllNodeNetworks: {value: function (nodeNetworksP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = nodeNetworksP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNodeNetworks(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = nodeNetworksP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNodeNetworks(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP));
              }
            }},
            removeNodeNetworks: {value: function (nodeNetworksP) {
              this.internal_removeNodeNetworks(nodeNetworksP, true, true);
            }, writable: true},
            removeAllNodeNetworks: {value: function () {
              this.internal_removeAllNodeNetworks(true, true);
            }, writable: true},
            internal_removeNodeNetworks: {value: function (nodeNetworksP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._nodeNetworks.size() !== 0 && this._nodeNetworks.containsKey((nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).internalGetKey())) {
                this._nodeNetworks.remove((nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).internalGetKey());
                ((nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()) != null ? nodeNetworksP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllNodeNetworksCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP));
                }
              }
            }},
            internal_removeAllNodeNetworks: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNodeNetworksCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.nodeNetworks) != null ? tmp$0 : Kotlin.throwNPE();
              this._nodeNetworks.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, temp_els));
                this.removeAllNodeNetworksCurrentlyProcessing = false;
              }
            }},
            groups: {
              get: function () {
                return _.kotlin.toList(this._groups.values());
              },
              set: function (groupsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (groupsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_groups(groupsP, true, true);
              }
            },
            internal_groups: {value: function (groupsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._groups.values(), groupsP)) {
                this._groups.clear();
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._groups.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_groups, el), _.org.kevoree.util.Constants.Ref_groups);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP));
                }
              }
            }},
            doAddGroups: {value: function (groupsP) {
              var _key_ = (groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._groups.containsKey(_key_)) {
                this._groups.put(_key_, groupsP);
                (groupsP != null ? groupsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_groups, groupsP), _.org.kevoree.util.Constants.Ref_groups);
              }
            }},
            addGroups: {value: function (groupsP) {
              this.internal_addGroups(groupsP, true, true);
            }, writable: true},
            addAllGroups: {value: function (groupsP) {
              this.internal_addAllGroups(groupsP, true, true);
            }, writable: true},
            internal_addGroups: {value: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGroups(groupsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP));
              }
            }},
            internal_addAllGroups: {value: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGroups(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = groupsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGroups(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP));
              }
            }},
            removeGroups: {value: function (groupsP) {
              this.internal_removeGroups(groupsP, true, true);
            }, writable: true},
            removeAllGroups: {value: function () {
              this.internal_removeAllGroups(true, true);
            }, writable: true},
            internal_removeGroups: {value: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._groups.size() !== 0 && this._groups.containsKey((groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey())) {
                this._groups.remove((groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey());
                ((groupsP != null ? groupsP : Kotlin.throwNPE()) != null ? groupsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllGroupsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP));
                }
              }
            }},
            internal_removeAllGroups: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllGroupsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.groups) != null ? tmp$0 : Kotlin.throwNPE();
              this._groups.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, temp_els));
                this.removeAllGroupsCurrentlyProcessing = false;
              }
            }},
            adaptationPrimitiveTypes: {
              get: function () {
                return _.kotlin.toList(this._adaptationPrimitiveTypes.values());
              },
              set: function (adaptationPrimitiveTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (adaptationPrimitiveTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_adaptationPrimitiveTypes(adaptationPrimitiveTypesP, true, true);
              }
            },
            internal_adaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._adaptationPrimitiveTypes.values(), adaptationPrimitiveTypesP)) {
                this._adaptationPrimitiveTypes.clear();
                {
                  var tmp$0 = adaptationPrimitiveTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._adaptationPrimitiveTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, el), _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP));
                }
              }
            }},
            doAddAdaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP) {
              var _key_ = (adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._adaptationPrimitiveTypes.containsKey(_key_)) {
                this._adaptationPrimitiveTypes.put(_key_, adaptationPrimitiveTypesP);
                (adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP), _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes);
              }
            }},
            addAdaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP) {
              this.internal_addAdaptationPrimitiveTypes(adaptationPrimitiveTypesP, true, true);
            }, writable: true},
            addAllAdaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP) {
              this.internal_addAllAdaptationPrimitiveTypes(adaptationPrimitiveTypesP, true, true);
            }, writable: true},
            internal_addAdaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddAdaptationPrimitiveTypes(adaptationPrimitiveTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP));
              }
            }},
            internal_addAllAdaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = adaptationPrimitiveTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddAdaptationPrimitiveTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = adaptationPrimitiveTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddAdaptationPrimitiveTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP));
              }
            }},
            removeAdaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP) {
              this.internal_removeAdaptationPrimitiveTypes(adaptationPrimitiveTypesP, true, true);
            }, writable: true},
            removeAllAdaptationPrimitiveTypes: {value: function () {
              this.internal_removeAllAdaptationPrimitiveTypes(true, true);
            }, writable: true},
            internal_removeAdaptationPrimitiveTypes: {value: function (adaptationPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._adaptationPrimitiveTypes.size() !== 0 && this._adaptationPrimitiveTypes.containsKey((adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._adaptationPrimitiveTypes.remove((adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey());
                ((adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()) != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllAdaptationPrimitiveTypesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP));
                }
              }
            }},
            internal_removeAllAdaptationPrimitiveTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllAdaptationPrimitiveTypesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.adaptationPrimitiveTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._adaptationPrimitiveTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, temp_els));
                this.removeAllAdaptationPrimitiveTypesCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_nodes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllNodes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._nodes.size() !== 0 && this._nodes.containsKey(value)) {
                    var obj = this._nodes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._nodes.remove(value);
                    this._nodes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinitions) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllTypeDefinitions();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._typeDefinitions.size() !== 0 && this._typeDefinitions.containsKey(value)) {
                    var obj_0 = this._typeDefinitions.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._typeDefinitions.remove(value);
                    this._typeDefinitions.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_repositories) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRepositories();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._repositories.size() !== 0 && this._repositories.containsKey(value)) {
                    var obj_1 = this._repositories.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._repositories.remove(value);
                    this._repositories.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dataTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDataTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDataTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDataTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDataTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._dataTypes.size() !== 0 && this._dataTypes.containsKey(value)) {
                    var obj_2 = this._dataTypes.get(value);
                    var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_2 == null) {
                      throw new Error('Key newed to null ' + obj_2);
                    }
                    this._dataTypes.remove(value);
                    this._dataTypes.put(objNewKey_2, obj_2);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_libraries) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addLibraries(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllLibraries(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeLibraries(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllLibraries();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._libraries.size() !== 0 && this._libraries.containsKey(value)) {
                    var obj_3 = this._libraries.get(value);
                    var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_3 == null) {
                      throw new Error('Key newed to null ' + obj_3);
                    }
                    this._libraries.remove(value);
                    this._libraries.put(objNewKey_3, obj_3);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_hubs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllHubs();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._hubs.size() !== 0 && this._hubs.containsKey(value)) {
                    var obj_4 = this._hubs.get(value);
                    var objNewKey_4 = (obj_4 != null ? obj_4 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_4 == null) {
                      throw new Error('Key newed to null ' + obj_4);
                    }
                    this._hubs.remove(value);
                    this._hubs.put(objNewKey_4, obj_4);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_mBindings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllMBindings();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._mBindings.size() !== 0 && this._mBindings.containsKey(value)) {
                    var obj_5 = this._mBindings.get(value);
                    var objNewKey_5 = (obj_5 != null ? obj_5 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_5 == null) {
                      throw new Error('Key newed to null ' + obj_5);
                    }
                    this._mBindings.remove(value);
                    this._mBindings.put(objNewKey_5, obj_5);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj_6 = this._deployUnits.get(value);
                    var objNewKey_6 = (obj_6 != null ? obj_6 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_6 == null) {
                      throw new Error('Key newed to null ' + obj_6);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey_6, obj_6);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_nodeNetworks) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addNodeNetworks(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllNodeNetworks(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeNodeNetworks(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllNodeNetworks();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._nodeNetworks.size() !== 0 && this._nodeNetworks.containsKey(value)) {
                    var obj_7 = this._nodeNetworks.get(value);
                    var objNewKey_7 = (obj_7 != null ? obj_7 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_7 == null) {
                      throw new Error('Key newed to null ' + obj_7);
                    }
                    this._nodeNetworks.remove(value);
                    this._nodeNetworks.put(objNewKey_7, obj_7);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_groups) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllGroups();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._groups.size() !== 0 && this._groups.containsKey(value)) {
                    var obj_8 = this._groups.get(value);
                    var objNewKey_8 = (obj_8 != null ? obj_8 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_8 == null) {
                      throw new Error('Key newed to null ' + obj_8);
                    }
                    this._groups.remove(value);
                    this._groups.put(objNewKey_8, obj_8);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addAdaptationPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllAdaptationPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeAdaptationPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllAdaptationPrimitiveTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._adaptationPrimitiveTypes.size() !== 0 && this._adaptationPrimitiveTypes.containsKey(value)) {
                    var obj_9 = this._adaptationPrimitiveTypes.get(value);
                    var objNewKey_9 = (obj_9 != null ? obj_9 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_9 == null) {
                      throw new Error('Key newed to null ' + obj_9);
                    }
                    this._adaptationPrimitiveTypes.remove(value);
                    this._adaptationPrimitiveTypes.put(objNewKey_9, obj_9);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findNodesByID: {value: function (key) {
              return this._nodes.get(key);
            }, writable: true},
            findTypeDefinitionsByID: {value: function (key) {
              return this._typeDefinitions.get(key);
            }, writable: true},
            findRepositoriesByID: {value: function (key) {
              return this._repositories.get(key);
            }, writable: true},
            findDataTypesByID: {value: function (key) {
              return this._dataTypes.get(key);
            }, writable: true},
            findLibrariesByID: {value: function (key) {
              return this._libraries.get(key);
            }, writable: true},
            findHubsByID: {value: function (key) {
              return this._hubs.get(key);
            }, writable: true},
            findMBindingsByID: {value: function (key) {
              return this._mBindings.get(key);
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findNodeNetworksByID: {value: function (key) {
              return this._nodeNetworks.get(key);
            }, writable: true},
            findGroupsByID: {value: function (key) {
              return this._groups.get(key);
            }, writable: true},
            findAdaptationPrimitiveTypesByID: {value: function (key) {
              return this._adaptationPrimitiveTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_nodes) {
                return this.findNodesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinitions) {
                return this.findTypeDefinitionsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_repositories) {
                return this.findRepositoriesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dataTypes) {
                return this.findDataTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_libraries) {
                return this.findLibrariesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_hubs) {
                return this.findHubsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_mBindings) {
                return this.findMBindingsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_nodeNetworks) {
                return this.findNodeNetworksByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_groups) {
                return this.findGroupsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes) {
                return this.findAdaptationPrimitiveTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_nodes, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                {
                  var tmp$0 = this._nodes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._nodes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_nodes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_nodes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinitions, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$1 = this._typeDefinitions.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._typeDefinitions.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinitions);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinitions);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_repositories, _.org.kevoree.util.Constants.org_kevoree_Repository);
                {
                  var tmp$2 = this._repositories.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._repositories.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_repositories);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_repositories);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dataTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$3 = this._dataTypes.keySet().iterator();
                  while (tmp$3.hasNext()) {
                    var KMFLoopEntryKey_2 = tmp$3.next();
                    this.internal_visit(visitor, this._dataTypes.get(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dataTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dataTypes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_libraries, _.org.kevoree.util.Constants.org_kevoree_TypeLibrary);
                {
                  var tmp$4 = this._libraries.keySet().iterator();
                  while (tmp$4.hasNext()) {
                    var KMFLoopEntryKey_3 = tmp$4.next();
                    this.internal_visit(visitor, this._libraries.get(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_libraries);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_libraries);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hubs, _.org.kevoree.util.Constants.org_kevoree_Channel);
                {
                  var tmp$5 = this._hubs.keySet().iterator();
                  while (tmp$5.hasNext()) {
                    var KMFLoopEntryKey_4 = tmp$5.next();
                    this.internal_visit(visitor, this._hubs.get(KMFLoopEntryKey_4), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hubs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hubs);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_mBindings, _.org.kevoree.util.Constants.org_kevoree_MBinding);
                {
                  var tmp$6 = this._mBindings.keySet().iterator();
                  while (tmp$6.hasNext()) {
                    var KMFLoopEntryKey_5 = tmp$6.next();
                    this.internal_visit(visitor, this._mBindings.get(KMFLoopEntryKey_5), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_mBindings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_mBindings);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$7 = this._deployUnits.keySet().iterator();
                  while (tmp$7.hasNext()) {
                    var KMFLoopEntryKey_6 = tmp$7.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_6), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_nodeNetworks, _.org.kevoree.util.Constants.org_kevoree_NodeNetwork);
                {
                  var tmp$8 = this._nodeNetworks.keySet().iterator();
                  while (tmp$8.hasNext()) {
                    var KMFLoopEntryKey_7 = tmp$8.next();
                    this.internal_visit(visitor, this._nodeNetworks.get(KMFLoopEntryKey_7), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_nodeNetworks);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_nodeNetworks);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_groups, _.org.kevoree.util.Constants.org_kevoree_Group);
                {
                  var tmp$9 = this._groups.keySet().iterator();
                  while (tmp$9.hasNext()) {
                    var KMFLoopEntryKey_8 = tmp$9.next();
                    this.internal_visit(visitor, this._groups.get(KMFLoopEntryKey_8), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_groups);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_groups);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType);
                {
                  var tmp$10 = this._adaptationPrimitiveTypes.keySet().iterator();
                  while (tmp$10.hasNext()) {
                    var KMFLoopEntryKey_9 = tmp$10.next();
                    this.internal_visit(visitor, this._adaptationPrimitiveTypes.get(KMFLoopEntryKey_9), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ContainerRoot;
            }, writable: true}
          })},
          PortImpl: {value: Kotlin.createClass([classes.cv, classes.c1j], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_bindings', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$portTypeRef', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.PortImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._bindings) != null ? tmp$0.clear() : null;
              this.portTypeRef = null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            bindings: {
              get: function () {
                return _.kotlin.toList(this._bindings.values());
              },
              set: function (bindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (bindingsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_bindings(bindingsP, true, true);
              }
            },
            internal_bindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._bindings.values(), bindingsP)) {
                this.internal_removeAllBindings(true, false);
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._bindings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
                }
              }
            }},
            doAddBindings: {value: function (bindingsP) {
              var _key_ = (bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._bindings.containsKey(_key_)) {
                this._bindings.put(_key_, bindingsP);
              }
            }},
            addBindings: {value: function (bindingsP) {
              this.internal_addBindings(bindingsP, true, true);
            }, writable: true},
            addAllBindings: {value: function (bindingsP) {
              this.internal_addAllBindings(bindingsP, true, true);
            }, writable: true},
            internal_addBindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddBindings(bindingsP);
              if (setOpposite) {
                (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
              }
            }},
            internal_addAllBindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddBindings(el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = bindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
              }
            }},
            removeBindings: {value: function (bindingsP) {
              this.internal_removeBindings(bindingsP, true, true);
            }, writable: true},
            removeAllBindings: {value: function () {
              this.internal_removeAllBindings(true, true);
            }, writable: true},
            internal_removeBindings: {value: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._bindings.size() !== 0 && this._bindings.containsKey((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._bindings.remove((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
                }
                if (setOpposite) {
                  (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, null, false, fireEvents);
                }
              }
            }},
            internal_removeAllBindings: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.bindings) != null ? tmp$0 : Kotlin.throwNPE();
              if (setOpposite) {
                {
                  var tmp$1 = (temp_els != null ? temp_els : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var el = tmp$1.next();
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, null, false, fireEvents);
                  }
                }
              }
              this._bindings.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, temp_els));
              }
            }},
            portTypeRef: {
              get: function () {
                return this.$portTypeRef;
              },
              set: function (portTypeRefP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_portTypeRef(portTypeRefP, true, true);
              }
            },
            internal_portTypeRef: {value: function (portTypeRefP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$portTypeRef, portTypeRefP)) {
                this.$portTypeRef = portTypeRefP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypeRef, portTypeRefP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_bindings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.internal_removeAllBindings(setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._bindings.size() !== 0 && this._bindings.containsKey(value)) {
                    var obj = this._bindings.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._bindings.remove(value);
                    this._bindings.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_portTypeRef) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_portTypeRef(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_portTypeRef(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_portTypeRef(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findBindingsByID: {value: function (key) {
              return this._bindings.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_bindings) {
                return this.findBindingsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_portTypeRef) {
                var objFound = this.portTypeRef;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_bindings, _.org.kevoree.util.Constants.org_kevoree_MBinding);
                {
                  var tmp$0 = this._bindings.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._bindings.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_bindings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_bindings);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_portTypeRef, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                this.internal_visit(visitor, this.portTypeRef, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_portTypeRef);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_portTypeRef);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Port;
            }, writable: true}
          })},
          RepositoryImpl: {value: Kotlin.createClass([classes.cv, classes.co], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$url', {value: null, writable: true});
            Object.defineProperty(this, '_units', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.RepositoryImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._units) != null ? tmp$0.clear() : null;
            }, writable: true},
            url: {
              get: function () {
                return this.$url;
              },
              set: function (iP) {
                this.internal_url(iP, true);
              }
            },
            internal_url: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.url)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$url = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_url, this.url));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_url, this.path()));
                }
              }
            }},
            units: {
              get: function () {
                return _.kotlin.toList(this._units.values());
              },
              set: function (unitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (unitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_units(unitsP, true, true);
              }
            },
            internal_units: {value: function (unitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._units.values(), unitsP)) {
                this._units.clear();
                {
                  var tmp$0 = unitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._units.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP));
                }
              }
            }},
            doAddUnits: {value: function (unitsP) {
              var _key_ = (unitsP != null ? unitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._units.containsKey(_key_)) {
                this._units.put(_key_, unitsP);
              }
            }},
            addUnits: {value: function (unitsP) {
              this.internal_addUnits(unitsP, true, true);
            }, writable: true},
            addAllUnits: {value: function (unitsP) {
              this.internal_addAllUnits(unitsP, true, true);
            }, writable: true},
            internal_addUnits: {value: function (unitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddUnits(unitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP));
              }
            }},
            internal_addAllUnits: {value: function (unitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = unitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = unitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP));
              }
            }},
            removeUnits: {value: function (unitsP) {
              this.internal_removeUnits(unitsP, true, true);
            }, writable: true},
            removeAllUnits: {value: function () {
              this.internal_removeAllUnits(true, true);
            }, writable: true},
            internal_removeUnits: {value: function (unitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._units.size() !== 0 && this._units.containsKey((unitsP != null ? unitsP : Kotlin.throwNPE()).internalGetKey())) {
                this._units.remove((unitsP != null ? unitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP));
                }
              }
            }},
            internal_removeAllUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.units) != null ? tmp$0 : Kotlin.throwNPE();
              this._units.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_url) {
                this.internal_url(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_units) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._units.size() !== 0 && this._units.containsKey(value)) {
                    var obj = this._units.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._units.remove(value);
                    this._units.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.url;
            }, writable: true},
            findUnitsByID: {value: function (key) {
              return this._units.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_units) {
                return this.findUnitsByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_units, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._units.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._units.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_units);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_units);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.url, _.org.kevoree.util.Constants.Att_url, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Repository;
            }, writable: true}
          })},
          DictionaryImpl: {value: Kotlin.createClass([classes.cv, classes.c1l], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_values', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllValuesCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.DictionaryImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._values) != null ? tmp$0.clear() : null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            values: {
              get: function () {
                return _.kotlin.toList(this._values.values());
              },
              set: function (valuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (valuesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_values(valuesP, true, true);
              }
            },
            internal_values: {value: function (valuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._values.values(), valuesP)) {
                this._values.clear();
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._values.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_values, el), _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP));
                }
              }
            }},
            doAddValues: {value: function (valuesP) {
              var _key_ = (valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._values.containsKey(_key_)) {
                this._values.put(_key_, valuesP);
                (valuesP != null ? valuesP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_values, valuesP), _.org.kevoree.util.Constants.Ref_values);
              }
            }},
            addValues: {value: function (valuesP) {
              this.internal_addValues(valuesP, true, true);
            }, writable: true},
            addAllValues: {value: function (valuesP) {
              this.internal_addAllValues(valuesP, true, true);
            }, writable: true},
            internal_addValues: {value: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddValues(valuesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP));
              }
            }},
            internal_addAllValues: {value: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = valuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP));
              }
            }},
            removeValues: {value: function (valuesP) {
              this.internal_removeValues(valuesP, true, true);
            }, writable: true},
            removeAllValues: {value: function () {
              this.internal_removeAllValues(true, true);
            }, writable: true},
            internal_removeValues: {value: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._values.size() !== 0 && this._values.containsKey((valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey())) {
                this._values.remove((valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey());
                ((valuesP != null ? valuesP : Kotlin.throwNPE()) != null ? valuesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP));
                }
              }
            }},
            internal_removeAllValues: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllValuesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.values) != null ? tmp$0 : Kotlin.throwNPE();
              this._values.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, temp_els));
                this.removeAllValuesCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_values) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllValues();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._values.size() !== 0 && this._values.containsKey(value)) {
                    var obj = this._values.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._values.remove(value);
                    this._values.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findValuesByID: {value: function (key) {
              return this._values.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_values) {
                return this.findValuesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_values, _.org.kevoree.util.Constants.org_kevoree_DictionaryValue);
                {
                  var tmp$0 = this._values.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._values.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_values);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Dictionary;
            }, writable: true}
          })},
          TypeLibraryImpl: {value: Kotlin.createClass([classes.cv, classes.c1i], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '_subTypes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.TypeLibraryImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._subTypes) != null ? tmp$0.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            subTypes: {
              get: function () {
                return _.kotlin.toList(this._subTypes.values());
              },
              set: function (subTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (subTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_subTypes(subTypesP, true, true);
              }
            },
            internal_subTypes: {value: function (subTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._subTypes.values(), subTypesP)) {
                this._subTypes.clear();
                {
                  var tmp$0 = subTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._subTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP));
                }
              }
            }},
            doAddSubTypes: {value: function (subTypesP) {
              var _key_ = (subTypesP != null ? subTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._subTypes.containsKey(_key_)) {
                this._subTypes.put(_key_, subTypesP);
              }
            }},
            addSubTypes: {value: function (subTypesP) {
              this.internal_addSubTypes(subTypesP, true, true);
            }, writable: true},
            addAllSubTypes: {value: function (subTypesP) {
              this.internal_addAllSubTypes(subTypesP, true, true);
            }, writable: true},
            internal_addSubTypes: {value: function (subTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSubTypes(subTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP));
              }
            }},
            internal_addAllSubTypes: {value: function (subTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = subTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSubTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = subTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSubTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP));
              }
            }},
            removeSubTypes: {value: function (subTypesP) {
              this.internal_removeSubTypes(subTypesP, true, true);
            }, writable: true},
            removeAllSubTypes: {value: function () {
              this.internal_removeAllSubTypes(true, true);
            }, writable: true},
            internal_removeSubTypes: {value: function (subTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._subTypes.size() !== 0 && this._subTypes.containsKey((subTypesP != null ? subTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._subTypes.remove((subTypesP != null ? subTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP));
                }
              }
            }},
            internal_removeAllSubTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.subTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._subTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_subTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSubTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSubTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSubTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSubTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._subTypes.size() !== 0 && this._subTypes.containsKey(value)) {
                    var obj = this._subTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._subTypes.remove(value);
                    this._subTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findSubTypesByID: {value: function (key) {
              return this._subTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_subTypes) {
                return this.findSubTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_subTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$0 = this._subTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._subTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_subTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_subTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_TypeLibrary;
            }, writable: true}
          })},
          PortTypeMappingImpl: {value: Kotlin.createClass([classes.cv, classes.c1b], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$beanMethodName', {value: null, writable: true});
            Object.defineProperty(this, '$serviceMethodName', {value: null, writable: true});
            Object.defineProperty(this, '$paramTypes', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
          }, /** @lends _.org.kevoree.impl.PortTypeMappingImpl.prototype */ {
            delete: {value: function () {
            }, writable: true},
            beanMethodName: {
              get: function () {
                return this.$beanMethodName;
              },
              set: function (iP) {
                this.internal_beanMethodName(iP, true);
              }
            },
            internal_beanMethodName: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.beanMethodName)) {
                var oldPath = this.path();
                this.$beanMethodName = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_beanMethodName, this.beanMethodName));
                }
              }
            }},
            serviceMethodName: {
              get: function () {
                return this.$serviceMethodName;
              },
              set: function (iP) {
                this.internal_serviceMethodName(iP, true);
              }
            },
            internal_serviceMethodName: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.serviceMethodName)) {
                var oldPath = this.path();
                this.$serviceMethodName = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_serviceMethodName, this.serviceMethodName));
                }
              }
            }},
            paramTypes: {
              get: function () {
                return this.$paramTypes;
              },
              set: function (iP) {
                this.internal_paramTypes(iP, true);
              }
            },
            internal_paramTypes: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.paramTypes)) {
                var oldPath = this.path();
                this.$paramTypes = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_paramTypes, this.paramTypes));
                }
              }
            }},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_beanMethodName) {
                this.internal_beanMethodName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_serviceMethodName) {
                this.internal_serviceMethodName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_paramTypes) {
                this.internal_paramTypes(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.paramTypes, _.org.kevoree.util.Constants.Att_paramTypes, this);
              visitor.visit(this.serviceMethodName, _.org.kevoree.util.Constants.Att_serviceMethodName, this);
              visitor.visit(this.beanMethodName, _.org.kevoree.util.Constants.Att_beanMethodName, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping;
            }, writable: true}
          })},
          WireImpl: {value: Kotlin.createClass([classes.cv, classes.cm], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_ports', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.WireImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._ports) != null ? tmp$0.clear() : null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            ports: {
              get: function () {
                return _.kotlin.toList(this._ports.values());
              },
              set: function (portsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (portsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_ports(portsP, true, true);
              }
            },
            internal_ports: {value: function (portsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._ports.values(), portsP)) {
                this._ports.clear();
                {
                  var tmp$0 = portsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._ports.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, portsP));
                }
              }
            }},
            doAddPorts: {value: function (portsP) {
              var _key_ = (portsP != null ? portsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._ports.containsKey(_key_)) {
                this._ports.put(_key_, portsP);
              }
            }},
            addPorts: {value: function (portsP) {
              this.internal_addPorts(portsP, true, true);
            }, writable: true},
            addAllPorts: {value: function (portsP) {
              this.internal_addAllPorts(portsP, true, true);
            }, writable: true},
            internal_addPorts: {value: function (portsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddPorts(portsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, portsP));
              }
            }},
            internal_addAllPorts: {value: function (portsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = portsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddPorts(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = portsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddPorts(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, portsP));
              }
            }},
            removePorts: {value: function (portsP) {
              this.internal_removePorts(portsP, true, true);
            }, writable: true},
            removeAllPorts: {value: function () {
              this.internal_removeAllPorts(true, true);
            }, writable: true},
            internal_removePorts: {value: function (portsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._ports) === 2 && this._ports.containsKey((portsP != null ? portsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of portsP must contain at least 2 element. Can not remove sizeof(portsP)=' + _.kotlin.get_size(this._ports));
              }
               else {
                this._ports.remove((portsP != null ? portsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, portsP));
                }
              }
            }},
            internal_removeAllPorts: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.ports) != null ? tmp$0 : Kotlin.throwNPE();
              this._ports.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_ports) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addPorts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllPorts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removePorts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllPorts();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._ports.size() !== 0 && this._ports.containsKey(value)) {
                    var obj = this._ports.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._ports.remove(value);
                    this._ports.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findPortsByID: {value: function (key) {
              return this._ports.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_ports) {
                return this.findPortsByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_ports, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$0 = this._ports.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._ports.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_ports);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_ports);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Wire;
            }, writable: true}
          })},
          MBindingImpl: {value: Kotlin.createClass([classes.cv, classes.c10], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '$port', {value: null, writable: true});
            Object.defineProperty(this, '$hub', {value: null, writable: true});
          }, /** @lends _.org.kevoree.impl.MBindingImpl.prototype */ {
            delete: {value: function () {
              this.port = null;
              this.hub = null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            port: {
              get: function () {
                return this.$port;
              },
              set: function (portP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_port(portP, true, true);
              }
            },
            internal_port: {value: function (portP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$port, portP)) {
                if (setOpposite) {
                  if (this.$port != null) {
                    var tmp$0;
                    ((tmp$0 = this.$port) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                  if (portP != null) {
                    portP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                }
                this.$port = portP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_port, portP));
                }
              }
            }},
            hub: {
              get: function () {
                return this.$hub;
              },
              set: function (hubP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_hub(hubP, true, true);
              }
            },
            internal_hub: {value: function (hubP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$hub, hubP)) {
                if (setOpposite) {
                  if (this.$hub != null) {
                    var tmp$0;
                    ((tmp$0 = this.$hub) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                  if (hubP != null) {
                    hubP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                }
                this.$hub = hubP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hub, hubP));
                }
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_port) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_port(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_port(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_port(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_hub) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_hub(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_hub(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_hub(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_port) {
                var objFound = this.port;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_hub) {
                var objFound_0 = this.hub;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_port, _.org.kevoree.util.Constants.org_kevoree_Port);
                this.internal_visit(visitor, this.port, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_port);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_port);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hub, _.org.kevoree.util.Constants.org_kevoree_Channel);
                this.internal_visit(visitor, this.hub, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hub);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hub);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_MBinding;
            }, writable: true}
          })},
          ComponentTypeImpl: {value: Kotlin.createClass([classes.cv, classes.c1g], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$factoryBean', {value: null, writable: true});
            Object.defineProperty(this, '$bean', {value: null, writable: true});
            Object.defineProperty(this, '$abstract', {value: null, writable: true});
            Object.defineProperty(this, '$startMethod', {value: null, writable: true});
            Object.defineProperty(this, '$stopMethod', {value: null, writable: true});
            Object.defineProperty(this, '$updateMethod', {value: null, writable: true});
            Object.defineProperty(this, '_deployUnits', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '$dictionaryType', {value: null, writable: true});
            Object.defineProperty(this, '_superTypes', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, '_required', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllRequiredCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '_integrationPatterns', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllIntegrationPatternsCurrentlyProcessing', {value: false, writable: true});
            Object.defineProperty(this, '$extraFonctionalProperties', {value: null, writable: true});
            Object.defineProperty(this, '_provided', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllProvidedCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.ComponentTypeImpl.prototype */ {
            delete: {value: function () {
              var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._required) != null ? tmp$2.clear() : null;
              (tmp$3 = this._integrationPatterns) != null ? tmp$3.clear() : null;
              this.extraFonctionalProperties = null;
              (tmp$4 = this._provided) != null ? tmp$4.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            }},
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            }},
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            }},
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            }},
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            }},
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            }},
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            doAddDeployUnits: {value: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            }},
            addDeployUnits: {value: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            addAllDeployUnits: {value: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            internal_addDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            internal_addAllDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            }},
            removeDeployUnits: {value: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            }, writable: true},
            removeAllDeployUnits: {value: function () {
              this.internal_removeAllDeployUnits(true, true);
            }, writable: true},
            internal_removeDeployUnits: {value: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            }},
            internal_removeAllDeployUnits: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            }},
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: {value: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            }},
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            doAddSuperTypes: {value: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            }},
            addSuperTypes: {value: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            }, writable: true},
            addAllSuperTypes: {value: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            }, writable: true},
            internal_addSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            internal_addAllSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            }},
            removeSuperTypes: {value: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            }, writable: true},
            removeAllSuperTypes: {value: function () {
              this.internal_removeAllSuperTypes(true, true);
            }, writable: true},
            internal_removeSuperTypes: {value: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            }},
            internal_removeAllSuperTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            }},
            required: {
              get: function () {
                return _.kotlin.toList(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: {value: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            }},
            doAddRequired: {value: function (requiredP) {
              var _key_ = (requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey(_key_)) {
                this._required.put(_key_, requiredP);
                (requiredP != null ? requiredP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
              }
            }},
            addRequired: {value: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
            }, writable: true},
            addAllRequired: {value: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
            }, writable: true},
            internal_addRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            }},
            internal_addAllRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            }},
            removeRequired: {value: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
            }, writable: true},
            removeAllRequired: {value: function () {
              this.internal_removeAllRequired(true, true);
            }, writable: true},
            internal_removeRequired: {value: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey())) {
                this._required.remove((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey());
                ((requiredP != null ? requiredP : Kotlin.throwNPE()) != null ? requiredP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            }},
            internal_removeAllRequired: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.required) != null ? tmp$0 : Kotlin.throwNPE();
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            }},
            integrationPatterns: {
              get: function () {
                return _.kotlin.toList(this._integrationPatterns.values());
              },
              set: function (integrationPatternsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (integrationPatternsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_integrationPatterns(integrationPatternsP, true, true);
              }
            },
            internal_integrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._integrationPatterns.values(), integrationPatternsP)) {
                this._integrationPatterns.clear();
                {
                  var tmp$0 = integrationPatternsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._integrationPatterns.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_integrationPatterns, el), _.org.kevoree.util.Constants.Ref_integrationPatterns);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
                }
              }
            }},
            doAddIntegrationPatterns: {value: function (integrationPatternsP) {
              var _key_ = (integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._integrationPatterns.containsKey(_key_)) {
                this._integrationPatterns.put(_key_, integrationPatternsP);
                (integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP), _.org.kevoree.util.Constants.Ref_integrationPatterns);
              }
            }},
            addIntegrationPatterns: {value: function (integrationPatternsP) {
              this.internal_addIntegrationPatterns(integrationPatternsP, true, true);
            }, writable: true},
            addAllIntegrationPatterns: {value: function (integrationPatternsP) {
              this.internal_addAllIntegrationPatterns(integrationPatternsP, true, true);
            }, writable: true},
            internal_addIntegrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddIntegrationPatterns(integrationPatternsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
              }
            }},
            internal_addAllIntegrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = integrationPatternsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddIntegrationPatterns(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = integrationPatternsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddIntegrationPatterns(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
              }
            }},
            removeIntegrationPatterns: {value: function (integrationPatternsP) {
              this.internal_removeIntegrationPatterns(integrationPatternsP, true, true);
            }, writable: true},
            removeAllIntegrationPatterns: {value: function () {
              this.internal_removeAllIntegrationPatterns(true, true);
            }, writable: true},
            internal_removeIntegrationPatterns: {value: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._integrationPatterns.size() !== 0 && this._integrationPatterns.containsKey((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey())) {
                this._integrationPatterns.remove((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey());
                ((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()) != null ? integrationPatternsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllIntegrationPatternsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
                }
              }
            }},
            internal_removeAllIntegrationPatterns: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllIntegrationPatternsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.integrationPatterns) != null ? tmp$0 : Kotlin.throwNPE();
              this._integrationPatterns.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, temp_els));
                this.removeAllIntegrationPatternsCurrentlyProcessing = false;
              }
            }},
            extraFonctionalProperties: {
              get: function () {
                return this.$extraFonctionalProperties;
              },
              set: function (extraFonctionalPropertiesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_extraFonctionalProperties(extraFonctionalPropertiesP, true, true);
              }
            },
            internal_extraFonctionalProperties: {value: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$extraFonctionalProperties, extraFonctionalPropertiesP)) {
                if (this.$extraFonctionalProperties != null) {
                  var tmp$0;
                  (((tmp$0 = this.$extraFonctionalProperties) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (extraFonctionalPropertiesP != null) {
                  (extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                }
                this.$extraFonctionalProperties = extraFonctionalPropertiesP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
                }
              }
            }},
            provided: {
              get: function () {
                return _.kotlin.toList(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: {value: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            }},
            doAddProvided: {value: function (providedP) {
              var _key_ = (providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey(_key_)) {
                this._provided.put(_key_, providedP);
                (providedP != null ? providedP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
              }
            }},
            addProvided: {value: function (providedP) {
              this.internal_addProvided(providedP, true, true);
            }, writable: true},
            addAllProvided: {value: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
            }, writable: true},
            internal_addProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            }},
            internal_addAllProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            }},
            removeProvided: {value: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
            }, writable: true},
            removeAllProvided: {value: function () {
              this.internal_removeAllProvided(true, true);
            }, writable: true},
            internal_removeProvided: {value: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey())) {
                this._provided.remove((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey());
                ((providedP != null ? providedP : Kotlin.throwNPE()) != null ? providedP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            }},
            internal_removeAllProvided: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.provided) != null ? tmp$0 : Kotlin.throwNPE();
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRequired();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._required.size() !== 0 && this._required.containsKey(value)) {
                    var obj_1 = this._required.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._required.remove(value);
                    this._required.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_integrationPatterns) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllIntegrationPatterns();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._integrationPatterns.size() !== 0 && this._integrationPatterns.containsKey(value)) {
                    var obj_2 = this._integrationPatterns.get(value);
                    var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_2 == null) {
                      throw new Error('Key newed to null ' + obj_2);
                    }
                    this._integrationPatterns.remove(value);
                    this._integrationPatterns.put(objNewKey_2, obj_2);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_extraFonctionalProperties(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_extraFonctionalProperties(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_extraFonctionalProperties(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllProvided();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._provided.size() !== 0 && this._provided.containsKey(value)) {
                    var obj_3 = this._provided.get(value);
                    var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_3 == null) {
                      throw new Error('Key newed to null ' + obj_3);
                    }
                    this._provided.remove(value);
                    this._provided.put(objNewKey_3, obj_3);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findDeployUnitsByID: {value: function (key) {
              return this._deployUnits.get(key);
            }, writable: true},
            findSuperTypesByID: {value: function (key) {
              return this._superTypes.get(key);
            }, writable: true},
            findRequiredByID: {value: function (key) {
              return this._required.get(key);
            }, writable: true},
            findIntegrationPatternsByID: {value: function (key) {
              return this._integrationPatterns.get(key);
            }, writable: true},
            findProvidedByID: {value: function (key) {
              return this._provided.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                return this.findRequiredByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_integrationPatterns) {
                return this.findIntegrationPatternsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                var objFound_0 = this.extraFonctionalProperties;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                return this.findProvidedByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$0 = this._required.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._required.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_integrationPatterns, _.org.kevoree.util.Constants.org_kevoree_IntegrationPattern);
                {
                  var tmp$1 = this._integrationPatterns.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._integrationPatterns.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_integrationPatterns);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_integrationPatterns);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties, _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty);
                this.internal_visit(visitor, this.extraFonctionalProperties, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$2 = this._provided.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._provided.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$3 = this._deployUnits.keySet().iterator();
                  while (tmp$3.hasNext()) {
                    var KMFLoopEntryKey_2 = tmp$3.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$4 = this._superTypes.keySet().iterator();
                  while (tmp$4.hasNext()) {
                    var KMFLoopEntryKey_3 = tmp$4.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ComponentType;
            }, writable: true}
          })},
          ExtraFonctionalPropertyImpl: {value: Kotlin.createClass([classes.cv, classes.c1d], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$generated_KMF_ID', {value: '' + Math.random() + (new Date()).getTime(), writable: true});
            Object.defineProperty(this, '_portTypes', {value: Kotlin.PrimitiveHashMap(0)});
          }, /** @lends _.org.kevoree.impl.ExtraFonctionalPropertyImpl.prototype */ {
            delete: {value: function () {
              var tmp$0;
              (tmp$0 = this._portTypes) != null ? tmp$0.clear() : null;
            }, writable: true},
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            }},
            portTypes: {
              get: function () {
                return _.kotlin.toList(this._portTypes.values());
              },
              set: function (portTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (portTypesP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_portTypes(portTypesP, true, true);
              }
            },
            internal_portTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._portTypes.values(), portTypesP)) {
                this._portTypes.clear();
                {
                  var tmp$0 = portTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._portTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
                }
              }
            }},
            doAddPortTypes: {value: function (portTypesP) {
              var _key_ = (portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._portTypes.containsKey(_key_)) {
                this._portTypes.put(_key_, portTypesP);
              }
            }},
            addPortTypes: {value: function (portTypesP) {
              this.internal_addPortTypes(portTypesP, true, true);
            }, writable: true},
            addAllPortTypes: {value: function (portTypesP) {
              this.internal_addAllPortTypes(portTypesP, true, true);
            }, writable: true},
            internal_addPortTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddPortTypes(portTypesP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
              }
            }},
            internal_addAllPortTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = portTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddPortTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = portTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddPortTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
              }
            }},
            removePortTypes: {value: function (portTypesP) {
              this.internal_removePortTypes(portTypesP, true, true);
            }, writable: true},
            removeAllPortTypes: {value: function () {
              this.internal_removeAllPortTypes(true, true);
            }, writable: true},
            internal_removePortTypes: {value: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._portTypes.size() !== 0 && this._portTypes.containsKey((portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._portTypes.remove((portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
                }
              }
            }},
            internal_removeAllPortTypes: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.portTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._portTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, temp_els));
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_portTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addPortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllPortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removePortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllPortTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._portTypes.size() !== 0 && this._portTypes.containsKey(value)) {
                    var obj = this._portTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._portTypes.remove(value);
                    this._portTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.generated_KMF_ID;
            }, writable: true},
            findPortTypesByID: {value: function (key) {
              return this._portTypes.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_portTypes) {
                return this.findPortTypesByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_portTypes, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$0 = this._portTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._portTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_portTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_portTypes);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty;
            }, writable: true}
          })},
          PortTypeRefImpl: {value: Kotlin.createClass([classes.cv, classes.c16], function () {
            Object.defineProperty(this, 'internal_eContainer', {value: null, writable: true});
            Object.defineProperty(this, 'internal_containmentRefName', {value: null, writable: true});
            Object.defineProperty(this, 'internal_unsetCmd', {value: null, writable: true});
            Object.defineProperty(this, 'internal_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_recursive_readOnlyElem', {value: false, writable: true});
            Object.defineProperty(this, 'internal_modelElementListeners', {value: null, writable: true});
            Object.defineProperty(this, 'internal_modelTreeListeners', {value: null, writable: true});
            Object.defineProperty(this, 'path_cache', {value: null, writable: true});
            Object.defineProperty(this, '$name', {value: null, writable: true});
            Object.defineProperty(this, '$optional', {value: null, writable: true});
            Object.defineProperty(this, '$noDependency', {value: null, writable: true});
            Object.defineProperty(this, '$ref', {value: null, writable: true});
            Object.defineProperty(this, '_mappings', {value: Kotlin.PrimitiveHashMap(0)});
            Object.defineProperty(this, 'removeAllMappingsCurrentlyProcessing', {value: false, writable: true});
          }, /** @lends _.org.kevoree.impl.PortTypeRefImpl.prototype */ {
            delete: {value: function () {
              this.ref = null;
              var tmp$0;
              (tmp$0 = this._mappings) != null ? tmp$0.clear() : null;
            }, writable: true},
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            }},
            optional: {
              get: function () {
                return this.$optional;
              },
              set: function (iP) {
                this.internal_optional(iP, true);
              }
            },
            internal_optional: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.optional)) {
                var oldPath = this.path();
                this.$optional = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_optional, this.optional));
                }
              }
            }},
            noDependency: {
              get: function () {
                return this.$noDependency;
              },
              set: function (iP) {
                this.internal_noDependency(iP, true);
              }
            },
            internal_noDependency: {value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.noDependency)) {
                var oldPath = this.path();
                this.$noDependency = iP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_noDependency, this.noDependency));
                }
              }
            }},
            ref: {
              get: function () {
                return this.$ref;
              },
              set: function (refP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_ref(refP, true, true);
              }
            },
            internal_ref: {value: function (refP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$ref, refP)) {
                this.$ref = refP;
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ref, refP));
                }
              }
            }},
            mappings: {
              get: function () {
                return _.kotlin.toList(this._mappings.values());
              },
              set: function (mappingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (mappingsP == null) {
                  throw Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_mappings(mappingsP, true, true);
              }
            },
            internal_mappings: {value: function (mappingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._mappings.values(), mappingsP)) {
                this._mappings.clear();
                {
                  var tmp$0 = mappingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._mappings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_mappings, el), _.org.kevoree.util.Constants.Ref_mappings);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP));
                }
              }
            }},
            doAddMappings: {value: function (mappingsP) {
              var _key_ = (mappingsP != null ? mappingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._mappings.containsKey(_key_)) {
                this._mappings.put(_key_, mappingsP);
                (mappingsP != null ? mappingsP : Kotlin.throwNPE()).setEContainer(this, _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_mappings, mappingsP), _.org.kevoree.util.Constants.Ref_mappings);
              }
            }},
            addMappings: {value: function (mappingsP) {
              this.internal_addMappings(mappingsP, true, true);
            }, writable: true},
            addAllMappings: {value: function (mappingsP) {
              this.internal_addAllMappings(mappingsP, true, true);
            }, writable: true},
            internal_addMappings: {value: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMappings(mappingsP);
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP));
              }
            }},
            internal_addAllMappings: {value: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = mappingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMappings(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = mappingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMappings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP));
              }
            }},
            removeMappings: {value: function (mappingsP) {
              this.internal_removeMappings(mappingsP, true, true);
            }, writable: true},
            removeAllMappings: {value: function () {
              this.internal_removeAllMappings(true, true);
            }, writable: true},
            internal_removeMappings: {value: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._mappings.size() !== 0 && this._mappings.containsKey((mappingsP != null ? mappingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._mappings.remove((mappingsP != null ? mappingsP : Kotlin.throwNPE()).internalGetKey());
                ((mappingsP != null ? mappingsP : Kotlin.throwNPE()) != null ? mappingsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllMappingsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP));
                }
              }
            }},
            internal_removeAllMappings: {value: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMappingsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.mappings) != null ? tmp$0 : Kotlin.throwNPE();
              this._mappings.clear();
              if (fireEvents) {
                this.fireModelEvent(_.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, temp_els));
                this.removeAllMappingsCurrentlyProcessing = false;
              }
            }},
            reflexiveMutator: {value: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_optional) {
                this.internal_optional(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_noDependency) {
                this.internal_noDependency(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_ref) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_ref(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_ref(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_ref(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_mappings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllMappings();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._mappings.size() !== 0 && this._mappings.containsKey(value)) {
                    var obj = this._mappings.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._mappings.remove(value);
                    this._mappings.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            }, writable: true},
            internalGetKey: {value: function () {
              return this.name;
            }, writable: true},
            findMappingsByID: {value: function (key) {
              return this._mappings.get(key);
            }, writable: true},
            findByID: {value: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_ref) {
                var objFound = this.ref;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_mappings) {
                return this.findMappingsByID(idP);
              }
               else {
                return null;
              }
            }, writable: true},
            visit: {value: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_mappings, _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping);
                {
                  var tmp$0 = this._mappings.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._mappings.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_mappings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_mappings);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_ref, _.org.kevoree.util.Constants.org_kevoree_PortType);
                this.internal_visit(visitor, this.ref, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_ref);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_ref);
              }
              visitor.endVisitElem(this);
            }, writable: true},
            visitAttributes: {value: function (visitor) {
              visitor.visit(this.noDependency, _.org.kevoree.util.Constants.Att_noDependency, this);
              visitor.visit(this.optional, _.org.kevoree.util.Constants.Att_optional, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            }, writable: true},
            metaClassName: {value: function () {
              return _.org.kevoree.util.Constants.org_kevoree_PortTypeRef;
            }, writable: true}
          })}
        }),
        modeling: Kotlin.definePackage(null, {
          api: Kotlin.definePackage(null, {
            ModelLoader: {value: classes.c4},
            KMFFactory: {value: classes.c5},
            ModelCloner: {value: classes.c8},
            ModelSerializer: {value: classes.ca},
            KMFContainer: {value: classes.ci},
            xmi: Kotlin.definePackage(function () {
              Object.defineProperty(this, 'Token', {value: Kotlin.createObject(null, function () {
                Object.defineProperty(this, 'XML_HEADER', {value: 0});
                Object.defineProperty(this, 'END_DOCUMENT', {value: 1});
                Object.defineProperty(this, 'START_TAG', {value: 2});
                Object.defineProperty(this, 'END_TAG', {value: 3});
                Object.defineProperty(this, 'COMMENT', {value: 4});
                Object.defineProperty(this, 'SINGLETON_TAG', {value: 5});
              })});
            }, {
              XMIModelLoader: {value: classes.c6},
              LoadingContext: {value: Kotlin.createClass(null, function () {
                Object.defineProperty(this, 'xmiReader', {value: null, writable: true});
                Object.defineProperty(this, 'loadedRoots', {value: Kotlin.ArrayList(0), writable: true});
                Object.defineProperty(this, 'map', {value: Kotlin.PrimitiveHashMap(0)});
                Object.defineProperty(this, 'elementsCount', {value: Kotlin.PrimitiveHashMap(0)});
                Object.defineProperty(this, 'resolvers', {value: Kotlin.ArrayList(0)});
                Object.defineProperty(this, 'stats', {value: Kotlin.PrimitiveHashMap(0)});
                Object.defineProperty(this, 'oppositesAlreadySet', {value: Kotlin.PrimitiveHashMap(0)});
              }, /** @lends _.org.kevoree.modeling.api.xmi.LoadingContext.prototype */ {
                isOppositeAlreadySet: {value: function (localRef, oppositeRef) {
                  var res = this.oppositesAlreadySet.get(oppositeRef + '_' + localRef) != null || this.oppositesAlreadySet.get(localRef + '_' + oppositeRef) != null;
                  return res;
                }},
                storeOppositeRelation: {value: function (localRef, oppositeRef) {
                  this.oppositesAlreadySet.put(localRef + '_' + oppositeRef, true);
                }}
              })},
              XMIResolveCommand: {value: Kotlin.createClass(null, function (context, target, mutatorType, refName, ref) {
                Object.defineProperty(this, 'context', {value: context});
                Object.defineProperty(this, 'target', {value: target});
                Object.defineProperty(this, 'mutatorType', {value: mutatorType});
                Object.defineProperty(this, 'refName', {value: refName});
                Object.defineProperty(this, 'ref', {value: ref});
              }, /** @lends _.org.kevoree.modeling.api.xmi.XMIResolveCommand.prototype */ {
                run: {value: function () {
                  var referencedElement = this.context.map.get(this.ref);
                  if (referencedElement != null) {
                    this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                    return;
                  }
                  if (Kotlin.equals(this.ref, '/0/') || Kotlin.equals(this.ref, '/')) {
                    referencedElement = this.context.map.get('/0');
                    if (referencedElement != null) {
                      this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                      return;
                    }
                  }
                  throw new Error('KMF Load error : reference ' + this.ref + ' not found in map when trying to  ' + this.mutatorType + ' ' + this.refName + '  on ' + Kotlin.toString(this.target));
                }}
              })},
              ReferencesVisitor: {value: Kotlin.createClass(classes.cj, function $fun(ostream, addressTable, elementsCount) {
                Object.defineProperty(this, 'ostream', {value: ostream});
                Object.defineProperty(this, 'addressTable', {value: addressTable});
                Object.defineProperty(this, 'elementsCount', {value: elementsCount});
                $fun.baseInitializer.call(this);
                Object.defineProperty(this, 'value', {value: null, writable: true});
              }, /** @lends _.org.kevoree.modeling.api.xmi.ReferencesVisitor.prototype */ {
                beginVisitElem: {value: function (elem) {
                }, writable: true},
                endVisitElem: {value: function (elem) {
                }, writable: true},
                beginVisitRef: {value: function (refName, refType) {
                }, writable: true},
                endVisitRef: {value: function (refName) {
                  if (this.value != null) {
                    this.ostream.print(' ' + refName + '="' + Kotlin.toString(this.value) + '"');
                    this.value = null;
                  }
                }, writable: true},
                visit: {value: function (elem, refNameInParent, parent) {
                  var adjustedAddress = this.addressTable.get(elem);
                  if (this.value == null) {
                    this.value = adjustedAddress;
                  }
                   else {
                    this.value = _.jet.plus(this.value, ' ' + adjustedAddress);
                  }
                }, writable: true}
              })},
              AttributesVisitor: {value: Kotlin.createClass(classes.ck, function (ostream) {
                Object.defineProperty(this, 'ostream', {value: ostream});
              }, /** @lends _.org.kevoree.modeling.api.xmi.AttributesVisitor.prototype */ {
                visit: {value: function (value, name, parent) {
                  if (value != null) {
                    this.ostream.print(' ' + name + '="');
                    this.escapeXml(this.ostream, Kotlin.toString(value));
                    this.ostream.print('"');
                  }
                }, writable: true},
                escapeXml: {value: function (ostream, chain) {
                  if (chain == null) {
                    return;
                  }
                  var i = 0;
                  var max = chain.length;
                  while (i < max) {
                    var c = chain.charAt(i);
                    if (c === '"') {
                      ostream.print('&quot;');
                    }
                     else if (c === '&') {
                      ostream.print('&amp;');
                    }
                     else if (c === "'") {
                      ostream.print('&apos;');
                    }
                     else if (c === '<') {
                      ostream.print('&lt;');
                    }
                     else if (c === '>') {
                      ostream.print('&gt;');
                    }
                     else {
                      ostream.print_0(c);
                    }
                    i = i + 1;
                  }
                }}
              })},
              ModelSerializationVisitor: {value: Kotlin.createClass(classes.cj, function $fun(ostream, addressTable, elementsCount) {
                Object.defineProperty(this, 'ostream', {value: ostream});
                Object.defineProperty(this, 'addressTable', {value: addressTable});
                Object.defineProperty(this, 'elementsCount', {value: elementsCount});
                $fun.baseInitializer.call(this);
                Object.defineProperty(this, 'attributeVisitor', {value: _.org.kevoree.modeling.api.xmi.AttributesVisitor(this.ostream)});
                Object.defineProperty(this, 'referenceVisitor', {value: _.org.kevoree.modeling.api.xmi.ReferencesVisitor(this.ostream, this.addressTable, this.elementsCount)});
              }, /** @lends _.org.kevoree.modeling.api.xmi.ModelSerializationVisitor.prototype */ {
                beginVisitElem: {value: function (elem) {
                }, writable: true},
                endVisitElem: {value: function (elem) {
                }, writable: true},
                beginVisitRef: {value: function (refName, refType) {
                }, writable: true},
                endVisitRef: {value: function (refName) {
                }, writable: true},
                visit: {value: function (elem, refNameInParent, parent) {
                  this.ostream.print_0('<');
                  this.ostream.print(refNameInParent);
                  this.ostream.print(' xsi:type="' + this.formatMetaClassName(elem.metaClassName()) + '"');
                  elem.visitAttributes(this.attributeVisitor);
                  elem.visit(this.referenceVisitor, false, false, true);
                  this.ostream.println_0('>');
                  elem.visit(this, false, true, false);
                  this.ostream.print('<\/');
                  this.ostream.print(refNameInParent);
                  this.ostream.print_0('>');
                  this.ostream.println_1();
                }, writable: true},
                formatMetaClassName: {value: function (metaClassName) {
                  var lastPoint = _.js.lastIndexOf_0(metaClassName, '.');
                  var pack = metaClassName.substring(0, lastPoint);
                  var cls = metaClassName.substring(lastPoint + 1);
                  return pack + ':' + cls;
                }}
              })},
              ModelAddressVisitor: {value: Kotlin.createClass(classes.cj, function $fun(addressTable, elementsCount, packageList) {
                Object.defineProperty(this, 'addressTable', {value: addressTable});
                Object.defineProperty(this, 'elementsCount', {value: elementsCount});
                Object.defineProperty(this, 'packageList', {value: packageList});
                $fun.baseInitializer.call(this);
              }, /** @lends _.org.kevoree.modeling.api.xmi.ModelAddressVisitor.prototype */ {
                beginVisitElem: {value: function (elem) {
                }, writable: true},
                endVisitElem: {value: function (elem) {
                }, writable: true},
                beginVisitRef: {value: function (refName, refType) {
                }, writable: true},
                endVisitRef: {value: function (refName) {
                }, writable: true},
                visit: {value: function (elem, refNameInParent, parent) {
                  var tmp$0;
                  var parentXmiAddress = (tmp$0 = this.addressTable.get(parent)) != null ? tmp$0 : Kotlin.throwNPE();
                  var i = this.elementsCount.get(parentXmiAddress + '/@' + refNameInParent) !== null ? this.elementsCount.get(parentXmiAddress + '/@' + refNameInParent) : 0;
                  this.addressTable.put(elem, parentXmiAddress + '/@' + refNameInParent + '.' + i);
                  this.elementsCount.put(parentXmiAddress + '/@' + refNameInParent, i + 1);
                  var pack = elem.metaClassName().substring(0, _.js.lastIndexOf_0(elem.metaClassName(), '.'));
                  if (!this.packageList.contains(pack))
                    this.packageList.add(pack);
                }, writable: true}
              })},
              XMIModelSerializer: {value: classes.c7},
              XmlParser: {value: Kotlin.createClass(null, function (inputStream) {
                Object.defineProperty(this, 'inputStream', {value: inputStream});
                Object.defineProperty(this, 'bytes', {value: this.inputStream.readBytes()});
                Object.defineProperty(this, 'index', {value: -1, writable: true});
                Object.defineProperty(this, 'currentChar', {value: null, writable: true});
                Object.defineProperty(this, 'xmlVersion', {value: null, writable: true});
                Object.defineProperty(this, 'xmlCharset', {value: null, writable: true});
                Object.defineProperty(this, 'tagName', {value: '', writable: true});
                Object.defineProperty(this, 'tagPrefix', {value: null, writable: true});
                Object.defineProperty(this, 'attributesNames', {value: Kotlin.ArrayList(0), writable: true});
                Object.defineProperty(this, 'attributesPrefixes', {value: Kotlin.ArrayList(0), writable: true});
                Object.defineProperty(this, 'attributesValues', {value: Kotlin.ArrayList(0), writable: true});
                Object.defineProperty(this, 'attributeName', {value: _.java.lang.StringBuilder(), writable: true});
                Object.defineProperty(this, 'attributePrefix', {value: null, writable: true});
                Object.defineProperty(this, 'attributeValue', {value: _.java.lang.StringBuilder(), writable: true});
                Object.defineProperty(this, 'readSingleton', {value: false, writable: true});
              }, /** @lends _.org.kevoree.modeling.api.xmi.XmlParser.prototype */ {
                hasNext: {value: function () {
                  return this.bytes.length - this.index > 2;
                }},
                getLocalName: {value: function () {
                  return this.tagName;
                }},
                getAttributeCount: {value: function () {
                  return this.attributesNames.size();
                }},
                getAttributeLocalName: {value: function (i) {
                  return this.attributesNames.get(i);
                }},
                getAttributePrefix: {value: function (i) {
                  return this.attributesPrefixes.get(i);
                }},
                getAttributeValue: {value: function (i) {
                  return this.attributesValues.get(i);
                }},
                readChar: {value: function () {
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[this.index = this.index + 1, this.index]);
                }},
                next: {value: function () {
                  if (this.readSingleton) {
                    this.readSingleton = false;
                    return _.org.kevoree.modeling.api.xmi.Token.END_TAG;
                  }
                  if (!this.hasNext()) {
                    return _.org.kevoree.modeling.api.xmi.Token.END_DOCUMENT;
                  }
                  this.attributesNames.clear();
                  this.attributesPrefixes.clear();
                  this.attributesValues.clear();
                  this.read_lessThan();
                  this.currentChar = this.readChar();
                  if (this.currentChar === '?') {
                    this.currentChar = this.readChar();
                    this.read_xmlHeader();
                    return _.org.kevoree.modeling.api.xmi.Token.XML_HEADER;
                  }
                   else if (this.currentChar === '!') {
                    do {
                      this.currentChar = this.readChar();
                    }
                     while (this.currentChar !== '>');
                    return _.org.kevoree.modeling.api.xmi.Token.COMMENT;
                  }
                   else if (this.currentChar === '/') {
                    this.currentChar = this.readChar();
                    this.read_closingTag();
                    return _.org.kevoree.modeling.api.xmi.Token.END_TAG;
                  }
                   else {
                    this.read_openTag();
                    if (this.currentChar === '/') {
                      this.read_upperThan();
                      this.readSingleton = true;
                    }
                    return _.org.kevoree.modeling.api.xmi.Token.START_TAG;
                  }
                }},
                read_lessThan: {value: function () {
                  do {
                    this.currentChar = this.readChar();
                  }
                   while (this.currentChar !== '<');
                }},
                read_upperThan: {value: function () {
                  while (this.currentChar !== '>') {
                    this.currentChar = this.readChar();
                  }
                }},
                read_xmlHeader: {value: function () {
                  this.read_tagName();
                  this.read_attributes();
                  this.read_upperThan();
                }},
                read_closingTag: {value: function () {
                  this.read_tagName();
                  this.read_upperThan();
                }},
                read_openTag: {value: function () {
                  this.read_tagName();
                  if (this.currentChar !== '>') {
                    this.read_attributes();
                  }
                }},
                read_tagName: {value: function () {
                  this.tagName = '' + this.currentChar;
                  this.tagPrefix = null;
                  this.currentChar = this.readChar();
                  while (this.currentChar !== ' ' && this.currentChar !== '>') {
                    if (this.currentChar === ':') {
                      this.tagPrefix = this.tagName;
                      this.tagName = '';
                    }
                     else {
                      this.tagName = this.tagName + this.currentChar;
                    }
                    this.currentChar = this.readChar();
                  }
                }},
                read_attributes: {value: function () {
                  var end_of_tag = false;
                  while (this.currentChar === ' ') {
                    this.currentChar = this.readChar();
                  }
                  while (!end_of_tag) {
                    while (this.currentChar !== '=') {
                      if (this.currentChar === ':') {
                        this.attributePrefix = this.attributeName.toString();
                        this.attributeName.delete(0, this.attributeName.length());
                      }
                       else {
                        var tmp$0;
                        this.attributeName.append_0((tmp$0 = this.currentChar) != null ? tmp$0 : Kotlin.throwNPE());
                      }
                      this.currentChar = this.readChar();
                    }
                    do {
                      this.currentChar = this.readChar();
                    }
                     while (this.currentChar !== '"');
                    this.currentChar = this.readChar();
                    while (this.currentChar !== '"') {
                      var tmp$1;
                      this.attributeValue.append_0((tmp$1 = this.currentChar) != null ? tmp$1 : Kotlin.throwNPE());
                      this.currentChar = this.readChar();
                    }
                    this.attributesNames.add(this.attributeName.toString());
                    this.attributesPrefixes.add(this.attributePrefix);
                    this.attributesValues.add(this.attributeValue.toString());
                    this.attributeName.delete(0, this.attributeName.length());
                    this.attributePrefix = null;
                    this.attributeValue.delete(0, this.attributeValue.length());
                    do {
                      this.currentChar = this.readChar();
                      if (this.currentChar === '?' || this.currentChar === '/' || this.currentChar === '-' || this.currentChar === '>') {
                        end_of_tag = true;
                      }
                    }
                     while (!end_of_tag && this.currentChar === ' ');
                  }
                }}
              })}
            }),
            compare: Kotlin.definePackage(null, {
              ModelCompare: {value: classes.c9}
            }),
            json: Kotlin.definePackage(function () {
              Object.defineProperty(this, 'Type', {value: Kotlin.createObject(null, function () {
                Object.defineProperty(this, 'VALUE', {value: 0});
                Object.defineProperty(this, 'LEFT_BRACE', {value: 1});
                Object.defineProperty(this, 'RIGHT_BRACE', {value: 2});
                Object.defineProperty(this, 'LEFT_BRACKET', {value: 3});
                Object.defineProperty(this, 'RIGHT_BRACKET', {value: 4});
                Object.defineProperty(this, 'COMMA', {value: 5});
                Object.defineProperty(this, 'COLON', {value: 6});
                Object.defineProperty(this, 'EOF', {value: 42});
              })});
            }, {
              Token: {value: Kotlin.createClass(null, function (tokenType, value) {
                Object.defineProperty(this, 'tokenType', {value: tokenType});
                Object.defineProperty(this, 'value', {value: value});
              }, /** @lends _.org.kevoree.modeling.api.json.Token.prototype */ {
                toString: {value: function () {
                  var tmp$0;
                  if (this.value != null) {
                    tmp$0 = ' (' + this.value + ')';
                  }
                   else {
                    tmp$0 = '';
                  }
                  var v = tmp$0;
                  var result = Kotlin.toString(this.tokenType) + v;
                  return result;
                }}
              })},
              Lexer: {value: Kotlin.createClass(null, function (inputStream) {
                Object.defineProperty(this, 'inputStream', {value: inputStream});
                Object.defineProperty(this, 'bytes', {value: this.inputStream.readBytes()});
                Object.defineProperty(this, 'EOF', {value: _.org.kevoree.modeling.api.json.Token(_.org.kevoree.modeling.api.json.Type.EOF, null)});
                Object.defineProperty(this, 'index', {value: 0, writable: true});
                Object.defineProperty(this, 'BOOLEAN_LETTERS', {value: null, writable: true});
                Object.defineProperty(this, 'DIGIT', {value: null, writable: true});
              }, /** @lends _.org.kevoree.modeling.api.json.Lexer.prototype */ {
                isSpace: {value: function (c) {
                  return c === ' ' || c === '\r' || c === '\n' || c === '\t';
                }},
                nextChar: {value: function () {
                  var tmp$0, tmp$1;
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[tmp$0 = this.index, tmp$1 = tmp$0, this.index = tmp$0 + 1, tmp$1]);
                }},
                peekChar: {value: function () {
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[this.index]);
                }},
                isDone: {value: function () {
                  return this.index >= this.bytes.length;
                }},
                isBooleanLetter: {value: function (c) {
                  if (this.BOOLEAN_LETTERS == null) {
                    this.BOOLEAN_LETTERS = Kotlin.PrimitiveHashSet();
                    var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7;
                    ((tmp$0 = this.BOOLEAN_LETTERS) != null ? tmp$0 : Kotlin.throwNPE()).add('f');
                    ((tmp$1 = this.BOOLEAN_LETTERS) != null ? tmp$1 : Kotlin.throwNPE()).add('a');
                    ((tmp$2 = this.BOOLEAN_LETTERS) != null ? tmp$2 : Kotlin.throwNPE()).add('l');
                    ((tmp$3 = this.BOOLEAN_LETTERS) != null ? tmp$3 : Kotlin.throwNPE()).add('s');
                    ((tmp$4 = this.BOOLEAN_LETTERS) != null ? tmp$4 : Kotlin.throwNPE()).add('e');
                    ((tmp$5 = this.BOOLEAN_LETTERS) != null ? tmp$5 : Kotlin.throwNPE()).add('t');
                    ((tmp$6 = this.BOOLEAN_LETTERS) != null ? tmp$6 : Kotlin.throwNPE()).add('r');
                    ((tmp$7 = this.BOOLEAN_LETTERS) != null ? tmp$7 : Kotlin.throwNPE()).add('u');
                  }
                  var tmp$8;
                  return ((tmp$8 = this.BOOLEAN_LETTERS) != null ? tmp$8 : Kotlin.throwNPE()).contains(c);
                }},
                isDigit: {value: function (c) {
                  if (this.DIGIT == null) {
                    this.DIGIT = Kotlin.PrimitiveHashSet();
                    var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7, tmp$8, tmp$9;
                    ((tmp$0 = this.DIGIT) != null ? tmp$0 : Kotlin.throwNPE()).add('0');
                    ((tmp$1 = this.DIGIT) != null ? tmp$1 : Kotlin.throwNPE()).add('1');
                    ((tmp$2 = this.DIGIT) != null ? tmp$2 : Kotlin.throwNPE()).add('2');
                    ((tmp$3 = this.DIGIT) != null ? tmp$3 : Kotlin.throwNPE()).add('3');
                    ((tmp$4 = this.DIGIT) != null ? tmp$4 : Kotlin.throwNPE()).add('4');
                    ((tmp$5 = this.DIGIT) != null ? tmp$5 : Kotlin.throwNPE()).add('5');
                    ((tmp$6 = this.DIGIT) != null ? tmp$6 : Kotlin.throwNPE()).add('6');
                    ((tmp$7 = this.DIGIT) != null ? tmp$7 : Kotlin.throwNPE()).add('7');
                    ((tmp$8 = this.DIGIT) != null ? tmp$8 : Kotlin.throwNPE()).add('8');
                    ((tmp$9 = this.DIGIT) != null ? tmp$9 : Kotlin.throwNPE()).add('9');
                  }
                  var tmp$10;
                  return ((tmp$10 = this.DIGIT) != null ? tmp$10 : Kotlin.throwNPE()).contains(c);
                }},
                isValueLetter: {value: function (c) {
                  return c === '-' || c === '+' || c === '.' || this.isDigit(c) || this.isBooleanLetter(c);
                }},
                nextToken: {value: function () {
                  if (this.isDone()) {
                    return this.EOF;
                  }
                  var tokenType = _.org.kevoree.modeling.api.json.Type.EOF;
                  var c = this.nextChar();
                  var currentValue = _.java.lang.StringBuilder();
                  var jsonValue = null;
                  while (!this.isDone() && this.isSpace(c)) {
                    c = this.nextChar();
                  }
                  if ('"' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.VALUE;
                    if (!this.isDone()) {
                      c = this.nextChar();
                      while (this.index < this.bytes.length && c !== '"') {
                        currentValue.append_0(c);
                        if (c === '\\' && this.index < this.bytes.length) {
                          c = this.nextChar();
                          currentValue.append_0(c);
                        }
                        c = this.nextChar();
                      }
                      jsonValue = currentValue.toString();
                    }
                     else {
                      throw Kotlin.RuntimeException('Unterminated string');
                    }
                  }
                   else if ('{' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.LEFT_BRACE;
                  }
                   else if ('}' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE;
                  }
                   else if ('[' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET;
                  }
                   else if (']' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET;
                  }
                   else if (':' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.COLON;
                  }
                   else if (',' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.COMMA;
                  }
                   else if (!this.isDone()) {
                    while (this.isValueLetter(c)) {
                      currentValue.append_0(c);
                      if (!this.isValueLetter(this.peekChar())) {
                        break;
                      }
                       else {
                        c = this.nextChar();
                      }
                    }
                    var v = currentValue.toString();
                    if (Kotlin.equals('true', v.toLowerCase())) {
                      jsonValue = true;
                    }
                     else if (Kotlin.equals('false', v.toLowerCase())) {
                      jsonValue = false;
                    }
                     else {
                      jsonValue = v.toLowerCase();
                    }
                    tokenType = _.org.kevoree.modeling.api.json.Type.VALUE;
                  }
                   else {
                    tokenType = _.org.kevoree.modeling.api.json.Type.EOF;
                  }
                  return _.org.kevoree.modeling.api.json.Token(tokenType, jsonValue);
                }}
              })},
              JSONModelLoader: {value: classes.cb},
              ResolveCommand: {value: Kotlin.createClass(null, function (roots, ref, currentRootElem, refName) {
                Object.defineProperty(this, 'roots', {value: roots});
                Object.defineProperty(this, 'ref', {value: ref});
                Object.defineProperty(this, 'currentRootElem', {value: currentRootElem});
                Object.defineProperty(this, 'refName', {value: refName});
              }, /** @lends _.org.kevoree.modeling.api.json.ResolveCommand.prototype */ {
                run: {value: function () {
                  var referencedElement = null;
                  var i = 0;
                  while (referencedElement == null && i < this.roots.size()) {
                    referencedElement = this.roots.get(i++).findByPath(this.ref);
                  }
                  if (referencedElement != null) {
                    this.currentRootElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, this.refName, referencedElement, false, false);
                  }
                   else {
                    throw new Error('Unresolved ' + this.ref);
                  }
                }}
              })},
              ModelReferenceVisitor: {value: Kotlin.createClass(classes.cj, function $fun(out) {
                Object.defineProperty(this, 'out', {value: out});
                $fun.baseInitializer.call(this);
                Object.defineProperty(this, 'isFirst', {value: true, writable: true});
              }, /** @lends _.org.kevoree.modeling.api.json.ModelReferenceVisitor.prototype */ {
                beginVisitRef: {value: function (refName, refType) {
                  this.out.print(',"' + refName + '":[');
                  this.isFirst = true;
                }, writable: true},
                endVisitRef: {value: function (refName) {
                  this.out.print(']');
                }, writable: true},
                visit: {value: function (elem, refNameInParent, parent) {
                  if (!this.isFirst) {
                    this.out.print(',');
                  }
                   else {
                    this.isFirst = false;
                  }
                  this.out.print('"' + elem.path() + '"');
                }, writable: true}
              })},
              JSONModelSerializer: {value: classes.cc}
            }),
            events: Kotlin.definePackage(null, {
              ModelElementListener: {value: classes.cd},
              ModelEvent: {value: Kotlin.createClass(null, function (internal_sourcePath, internal_etype, internal_elementAttributeType, internal_elementAttributeName, internal_value) {
                Object.defineProperty(this, 'internal_sourcePath', {value: internal_sourcePath});
                Object.defineProperty(this, 'internal_etype', {value: internal_etype});
                Object.defineProperty(this, 'internal_elementAttributeType', {value: internal_elementAttributeType});
                Object.defineProperty(this, 'internal_elementAttributeName', {value: internal_elementAttributeName});
                Object.defineProperty(this, 'internal_value', {value: internal_value});
              }, /** @lends _.org.kevoree.modeling.api.events.ModelEvent.prototype */ {
                getSourcePath: {value: function () {
                  return this.internal_sourcePath;
                }},
                getType: {value: function () {
                  return this.internal_etype;
                }},
                getElementAttributeType: {value: function () {
                  return this.internal_elementAttributeType;
                }},
                getElementAttributeName: {value: function () {
                  return this.internal_elementAttributeName;
                }},
                getValue: {value: function () {
                  return this.internal_value;
                }},
                toString: {value: function () {
                  return 'ModelEvent[src:' + this.getSourcePath() + ', type:' + this.getType() + ', elementAttributeType:' + this.getElementAttributeType() + ', elementAttributeName:' + this.getElementAttributeName() + ', value:' + this.getValue() + ']';
                }}
              })},
              ModelTreeListener: {value: classes.ce}
            }),
            trace: Kotlin.definePackage(null, {
              TraceConverter: {value: classes.cf},
              ModelTrace: {value: classes.cg},
              ModelAddTrace: {value: Kotlin.createClass(classes.cg, function (srcPath, refName, previousPath, typeName) {
                Object.defineProperty(this, 'srcPath', {value: srcPath});
                Object.defineProperty(this, 'refName', {value: refName});
                Object.defineProperty(this, 'previousPath', {value: previousPath});
                Object.defineProperty(this, 'typeName', {value: typeName});
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelAddTrace.prototype */ {
                toString: {value: function () {
                  var buffer = _.java.lang.StringBuilder();
                  buffer.append('{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.ADD + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '"');
                  if (this.previousPath != null) {
                    buffer.append(', "previouspath" : "' + this.previousPath + '"');
                  }
                  if (this.typeName != null) {
                    buffer.append(', "typename" : "' + this.typeName + '"');
                  }
                  buffer.append('}');
                  return buffer.toString();
                }, writable: true}
              })},
              ModelAddAllTrace: {value: Kotlin.createClass(classes.cg, function (srcPath, refName, previousPath, typeName) {
                Object.defineProperty(this, 'srcPath', {value: srcPath});
                Object.defineProperty(this, 'refName', {value: refName});
                Object.defineProperty(this, 'previousPath', {value: previousPath});
                Object.defineProperty(this, 'typeName', {value: typeName});
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelAddAllTrace.prototype */ {
                mkString: {value: function (ss) {
                  if (ss == null) {
                    return null;
                  }
                  var buffer = _.java.lang.StringBuilder();
                  var isFirst = true;
                  {
                    var tmp$0 = ss.iterator();
                    while (tmp$0.hasNext()) {
                      var s = tmp$0.next();
                      if (!isFirst) {
                        buffer.append(',');
                      }
                      buffer.append(s);
                      isFirst = false;
                    }
                  }
                  return buffer.toString();
                }},
                toString: {value: function () {
                  var buffer = _.java.lang.StringBuilder();
                  buffer.append('{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.ADD_ALL + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '"');
                  if (this.previousPath != null) {
                    buffer.append(', "previouspath" : "' + this.mkString(this.previousPath) + '"');
                  }
                  if (this.typeName != null) {
                    buffer.append(', "typename" : "' + this.mkString(this.typeName) + '"');
                  }
                  buffer.append('}');
                  return buffer.toString();
                }, writable: true}
              })},
              ModelRemoveTrace: {value: Kotlin.createClass(classes.cg, function (srcPath, refName, objPath) {
                Object.defineProperty(this, 'srcPath', {value: srcPath});
                Object.defineProperty(this, 'refName', {value: refName});
                Object.defineProperty(this, 'objPath', {value: objPath});
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelRemoveTrace.prototype */ {
                toString: {value: function () {
                  return '{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.REMOVE + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '", "objpath" : "' + this.objPath + '" }';
                }, writable: true}
              })},
              ModelRemoveAllTrace: {value: Kotlin.createClass(classes.cg, function (srcPath, refName) {
                Object.defineProperty(this, 'srcPath', {value: srcPath});
                Object.defineProperty(this, 'refName', {value: refName});
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace.prototype */ {
                toString: {value: function () {
                  return '{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '" }';
                }, writable: true}
              })},
              ModelSetTrace: {value: Kotlin.createClass(classes.cg, function (srcPath, refName, objPath, content, typeName) {
                Object.defineProperty(this, 'srcPath', {value: srcPath});
                Object.defineProperty(this, 'refName', {value: refName});
                Object.defineProperty(this, 'objPath', {value: objPath});
                Object.defineProperty(this, 'content', {value: content});
                Object.defineProperty(this, 'typeName', {value: typeName});
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelSetTrace.prototype */ {
                toString: {value: function () {
                  var buffer = _.java.lang.StringBuilder();
                  buffer.append('{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.SET + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '"');
                  if (this.objPath != null) {
                    buffer.append(', "objpath" : "' + this.objPath + '"');
                  }
                  if (this.content != null) {
                    buffer.append(', "content" : "' + this.content + '"');
                  }
                  if (this.typeName != null) {
                    buffer.append(', "typename" : "' + this.typeName + '"');
                  }
                  buffer.append('}');
                  return buffer.toString();
                }, writable: true}
              })},
              DefaultTraceConverter: {value: Kotlin.createClass(classes.cf, function () {
                Object.defineProperty(this, 'metaClassNameEquivalence_1', {value: Kotlin.PrimitiveHashMap(0), writable: true});
                Object.defineProperty(this, 'metaClassNameEquivalence_2', {value: Kotlin.PrimitiveHashMap(0), writable: true});
                Object.defineProperty(this, 'attNameEquivalence_1', {value: Kotlin.PrimitiveHashMap(0), writable: true});
                Object.defineProperty(this, 'attNameEquivalence_2', {value: Kotlin.PrimitiveHashMap(0), writable: true});
              }, /** @lends _.org.kevoree.modeling.api.trace.DefaultTraceConverter.prototype */ {
                addMetaClassEquivalence: {value: function (name1, name2) {
                  this.metaClassNameEquivalence_1.put(name1, name2);
                  this.metaClassNameEquivalence_2.put(name2, name2);
                }},
                addAttEquivalence: {value: function (name1, name2) {
                  var fqnArray_1 = Kotlin.splitString(name1, '#');
                  var fqnArray_2 = Kotlin.splitString(name1, '#');
                  this.attNameEquivalence_1.put(name1, name2);
                  this.attNameEquivalence_2.put(name2, name2);
                }},
                convert: {value: function (trace) {
                  if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddTrace)) {
                    var addTrace = trace != null ? trace : Kotlin.throwNPE();
                    var newTrace = _.org.kevoree.modeling.api.trace.ModelAddTrace(addTrace.srcPath, addTrace.refName, addTrace.previousPath, this.tryConvertClassName(addTrace.typeName));
                    return newTrace;
                  }
                   else if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelSetTrace)) {
                    var setTrace = trace != null ? trace : Kotlin.throwNPE();
                    var newTrace_0 = _.org.kevoree.modeling.api.trace.ModelSetTrace(setTrace.srcPath, setTrace.refName, setTrace.objPath, setTrace.content, this.tryConvertClassName(setTrace.typeName));
                    return newTrace_0;
                  }
                   else {
                    return trace;
                  }
                }, writable: true},
                tryConvertPath: {value: function (previousPath) {
                  if (previousPath == null) {
                    return null;
                  }
                  return previousPath;
                }},
                tryConvertClassName: {value: function (previousClassName) {
                  if (previousClassName == null) {
                    return null;
                  }
                  if (this.metaClassNameEquivalence_1.containsKey(previousClassName)) {
                    var tmp$0;
                    return (tmp$0 = this.metaClassNameEquivalence_1.get(previousClassName)) != null ? tmp$0 : Kotlin.throwNPE();
                  }
                  if (this.metaClassNameEquivalence_2.containsKey(previousClassName)) {
                    var tmp$1;
                    return (tmp$1 = this.metaClassNameEquivalence_2.get(previousClassName)) != null ? tmp$1 : Kotlin.throwNPE();
                  }
                  return previousClassName;
                }},
                tryConvertAttName: {value: function (previousAttName) {
                  if (previousAttName == null) {
                    return null;
                  }
                  var FQNattName = previousAttName;
                  if (this.attNameEquivalence_1.containsKey(FQNattName)) {
                    var tmp$0;
                    return (tmp$0 = this.attNameEquivalence_1.get(FQNattName)) != null ? tmp$0 : Kotlin.throwNPE();
                  }
                  if (this.attNameEquivalence_2.containsKey(FQNattName)) {
                    var tmp$1;
                    return (tmp$1 = this.attNameEquivalence_2.get(FQNattName)) != null ? tmp$1 : Kotlin.throwNPE();
                  }
                  return previousAttName;
                }}
              })},
              ModelTraceApplicator: {value: Kotlin.createClass(null, function (targetModel, factory) {
                Object.defineProperty(this, 'targetModel', {value: targetModel});
                Object.defineProperty(this, 'factory', {value: factory});
                Object.defineProperty(this, 'pendingObj', {value: null, writable: true});
                Object.defineProperty(this, 'pendingParent', {value: null, writable: true});
                Object.defineProperty(this, 'pendingParentRefName', {value: null, writable: true});
                Object.defineProperty(this, 'pendingObjPath', {value: null, writable: true});
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelTraceApplicator.prototype */ {
                tryClosePending: {value: function (srcPath) {
                  if (this.pendingObj != null && !Kotlin.equals(this.pendingObjPath, srcPath)) {
                    var tmp$0, tmp$1;
                    ((tmp$0 = this.pendingParent) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, (tmp$1 = this.pendingParentRefName) != null ? tmp$1 : Kotlin.throwNPE(), this.pendingObj, true, true);
                    this.pendingObj = null;
                    this.pendingObjPath = null;
                    this.pendingParentRefName = null;
                    this.pendingParent = null;
                  }
                }},
                createOrAdd: {value: function (previousPath, target, refName, potentialTypeName) {
                  var tmp$0;
                  if (previousPath != null) {
                    tmp$0 = this.targetModel.findByPath(previousPath);
                  }
                   else {
                    tmp$0 = null;
                  }
                  var targetElem = tmp$0;
                  if (targetElem != null) {
                    target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, refName, targetElem, true, true);
                  }
                   else {
                    this.pendingObj = this.factory.create(potentialTypeName != null ? potentialTypeName : Kotlin.throwNPE());
                    this.pendingObjPath = previousPath;
                    this.pendingParentRefName = refName;
                    this.pendingParent = target;
                  }
                }},
                applyTraceOnModel: {value: function (traceSeq) {
                  {
                    var tmp$0 = traceSeq.traces.iterator();
                    while (tmp$0.hasNext()) {
                      var trace = tmp$0.next();
                      var target = this.targetModel;
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddTrace)) {
                        var castedTrace = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(null);
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          var tmp$1;
                          target = (tmp$1 = this.targetModel.findByPath(castedTrace.srcPath)) != null ? tmp$1 : Kotlin.throwNPE();
                        }
                        this.createOrAdd(castedTrace.previousPath, target, castedTrace.refName, castedTrace.typeName);
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddAllTrace)) {
                        var castedTrace_0 = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(null);
                        var i = 0;
                        var tmp$2;
                        {
                          var tmp$3 = ((tmp$2 = castedTrace_0.previousPath) != null ? tmp$2 : Kotlin.throwNPE()).iterator();
                          while (tmp$3.hasNext()) {
                            var path = tmp$3.next();
                            var tmp$4;
                            this.createOrAdd(path, target, castedTrace_0.refName, ((tmp$4 = castedTrace_0.typeName) != null ? tmp$4 : Kotlin.throwNPE()).get(i));
                            i++;
                          }
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelRemoveTrace)) {
                        var castedTrace_1 = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(trace.srcPath);
                        var tempTarget = this.targetModel;
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          tempTarget = this.targetModel.findByPath(castedTrace_1.srcPath);
                        }
                        if (tempTarget != null) {
                          (tempTarget != null ? tempTarget : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE, castedTrace_1.refName, this.targetModel.findByPath(castedTrace_1.objPath), true, true);
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace)) {
                        var castedTrace_2 = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(trace.srcPath);
                        var tempTarget_0 = this.targetModel;
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          tempTarget_0 = this.targetModel.findByPath(castedTrace_2.srcPath);
                        }
                        if (tempTarget_0 != null) {
                          (tempTarget_0 != null ? tempTarget_0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, castedTrace_2.refName, null, true, true);
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelSetTrace)) {
                        var castedTrace_3 = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(trace.srcPath);
                        if (!Kotlin.equals(trace.srcPath, '') && !Kotlin.equals(castedTrace_3.srcPath, this.pendingObjPath)) {
                          var tempObject = this.targetModel.findByPath(castedTrace_3.srcPath);
                          if (tempObject == null) {
                            throw new Error('Set Trace source not found for path : ' + castedTrace_3.srcPath + '/ pending ' + this.pendingObjPath + '\n' + trace.toString());
                          }
                          target = tempObject != null ? tempObject : Kotlin.throwNPE();
                        }
                         else {
                          if (Kotlin.equals(castedTrace_3.srcPath, this.pendingObjPath) && this.pendingObj != null) {
                            var tmp$5;
                            target = (tmp$5 = this.pendingObj) != null ? tmp$5 : Kotlin.throwNPE();
                          }
                        }
                        if (castedTrace_3.content != null) {
                          target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, castedTrace_3.refName, castedTrace_3.content, true, true);
                        }
                         else {
                          var tmp$7;
                          if (castedTrace_3.objPath != null) {
                            var tmp$6;
                            tmp$7 = this.targetModel.findByPath((tmp$6 = castedTrace_3.objPath) != null ? tmp$6 : Kotlin.throwNPE());
                          }
                           else {
                            tmp$7 = null;
                          }
                          var targetContentPath = tmp$7;
                          if (targetContentPath != null) {
                            target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, castedTrace_3.refName, targetContentPath, true, true);
                          }
                           else {
                            if (castedTrace_3.typeName != null && !Kotlin.equals(castedTrace_3.typeName, '')) {
                              this.createOrAdd(castedTrace_3.objPath, target, castedTrace_3.refName, castedTrace_3.typeName);
                            }
                             else {
                              target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, castedTrace_3.refName, targetContentPath, true, true);
                            }
                          }
                        }
                      }
                    }
                  }
                  this.tryClosePending(null);
                }}
              })},
              Event2Trace: {value: Kotlin.createClass(null, function (compare) {
                Object.defineProperty(this, 'compare', {value: compare});
              }, /** @lends _.org.kevoree.modeling.api.trace.Event2Trace.prototype */ {
                convert: {value: function (event) {
                  var result = Kotlin.ArrayList(0);
                  var tmp$0 = event.getType();
                  if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                    var tmp$1, tmp$2, tmp$3, tmp$4;
                    result.add(_.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$1 = event.getSourcePath()) != null ? tmp$1 : Kotlin.throwNPE(), (tmp$2 = event.getElementAttributeName()) != null ? tmp$2 : Kotlin.throwNPE(), (tmp$4 = ((tmp$3 = event.getValue()) != null ? tmp$3 : Kotlin.throwNPE()).path()) != null ? tmp$4 : Kotlin.throwNPE()));
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                    var tmp$5, tmp$6;
                    result.add(_.org.kevoree.modeling.api.trace.ModelRemoveAllTrace((tmp$5 = event.getSourcePath()) != null ? tmp$5 : Kotlin.throwNPE(), (tmp$6 = event.getElementAttributeName()) != null ? tmp$6 : Kotlin.throwNPE()));
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                    var tmp$7, tmp$8, tmp$9;
                    var casted = (tmp$7 = event.getValue()) != null ? tmp$7 : Kotlin.throwNPE();
                    var traces = this.compare.inter(casted, casted);
                    result.add(_.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$8 = event.getSourcePath()) != null ? tmp$8 : Kotlin.throwNPE(), (tmp$9 = event.getElementAttributeName()) != null ? tmp$9 : Kotlin.throwNPE(), casted.path(), casted.metaClassName()));
                    result.addAll(traces.traces);
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                    var tmp$10;
                    var casted_0 = (tmp$10 = event.getValue()) != null ? tmp$10 : Kotlin.throwNPE();
                    {
                      var tmp$11 = (casted_0 != null ? casted_0 : Kotlin.throwNPE()).iterator();
                      while (tmp$11.hasNext()) {
                        var elem = tmp$11.next();
                        var elemCasted = elem != null ? elem : Kotlin.throwNPE();
                        var traces_0 = this.compare.inter(elemCasted, elemCasted);
                        var tmp$12, tmp$13;
                        result.add(_.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$12 = event.getSourcePath()) != null ? tmp$12 : Kotlin.throwNPE(), (tmp$13 = event.getElementAttributeName()) != null ? tmp$13 : Kotlin.throwNPE(), elemCasted.path(), elemCasted.metaClassName()));
                        result.addAll(traces_0.traces);
                      }
                    }
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.SET) {
                    if (event.getElementAttributeType() === _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE) {
                      var tmp$14, tmp$15;
                      result.add(_.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$14 = event.getSourcePath()) != null ? tmp$14 : Kotlin.throwNPE(), (tmp$15 = event.getElementAttributeName()) != null ? tmp$15 : Kotlin.throwNPE(), null, Kotlin.toString(event.getValue()), null));
                    }
                     else {
                      var tmp$16, tmp$17, tmp$18;
                      result.add(_.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$16 = event.getSourcePath()) != null ? tmp$16 : Kotlin.throwNPE(), (tmp$17 = event.getElementAttributeName()) != null ? tmp$17 : Kotlin.throwNPE(), ((tmp$18 = event.getValue()) != null ? tmp$18 : Kotlin.throwNPE()).path(), null, null));
                    }
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  }
                   else {
                    throw new Error("Can't convert event : " + event);
                  }
                  return this.compare.createSequence().populate(result);
                }}
              })},
              TraceSequence: {value: classes.ch}
            }),
            util: Kotlin.definePackage(function () {
              Object.defineProperty(this, 'ElementAttributeType', {value: Kotlin.createObject(null, function () {
                Object.defineProperty(this, 'ATTRIBUTE', {value: 0});
                Object.defineProperty(this, 'REFERENCE', {value: 1});
                Object.defineProperty(this, 'CONTAINMENT', {value: 2});
              })});
              Object.defineProperty(this, 'ActionType', {value: Kotlin.createObject(null, function () {
                Object.defineProperty(this, 'SET', {value: 0});
                Object.defineProperty(this, 'ADD', {value: 1});
                Object.defineProperty(this, 'REMOVE', {value: 2});
                Object.defineProperty(this, 'ADD_ALL', {value: 3});
                Object.defineProperty(this, 'REMOVE_ALL', {value: 4});
                Object.defineProperty(this, 'RENEW_INDEX', {value: 5});
              })});
              Object.defineProperty(this, 'ByteConverter', {value: Kotlin.createObject(null, null, {
                toChar: {value: function (b) {
                  return b != null ? b : Kotlin.throwNPE();
                }},
                fromChar: {value: function (b) {
                  return b != null ? b : Kotlin.throwNPE();
                }},
                byteArrayInputStreamFromString: {value: function (str) {
                  var bytes = Kotlin.numberArrayOfSize(str.length);
                  var i = 0;
                  while (i < str.length) {
                    var tmp$0;
                    bytes[i] = (tmp$0 = str.charAt(i)) != null ? tmp$0 : Kotlin.throwNPE();
                    i = i + 1;
                  }
                  return _.java.io.ByteArrayInputStream(bytes);
                }}
              })});
            }, {
              ModelVisitor: {value: classes.cj},
              ModelAttributeVisitor: {value: classes.ck}
            })
          })
        }),
        log: Kotlin.definePackage(function () {
          Object.defineProperty(this, 'Log', {value: Kotlin.createObject(null, function () {
            Object.defineProperty(this, 'LEVEL_NONE', {value: 6});
            Object.defineProperty(this, 'LEVEL_ERROR', {value: 5});
            Object.defineProperty(this, 'LEVEL_WARN', {value: 4});
            Object.defineProperty(this, 'LEVEL_INFO', {value: 3});
            Object.defineProperty(this, 'LEVEL_DEBUG', {value: 2});
            Object.defineProperty(this, 'LEVEL_TRACE', {value: 1});
            Object.defineProperty(this, 'level', {value: this.LEVEL_INFO, writable: true});
            Object.defineProperty(this, 'ERROR', {value: this.level <= this.LEVEL_ERROR, writable: true});
            Object.defineProperty(this, 'WARN', {value: this.level <= this.LEVEL_WARN, writable: true});
            Object.defineProperty(this, 'INFO', {value: this.level <= this.LEVEL_INFO, writable: true});
            Object.defineProperty(this, 'DEBUG', {value: this.level <= this.LEVEL_DEBUG, writable: true});
            Object.defineProperty(this, 'TRACE', {value: this.level <= this.LEVEL_TRACE, writable: true});
            Object.defineProperty(this, 'logger', {value: _.org.kevoree.log.Logger(), writable: true});
            Object.defineProperty(this, 'beginParam', {value: '{'});
            Object.defineProperty(this, 'endParam', {value: '}'});
          }, {
            set: {value: function (level) {
              _.org.kevoree.log.Log.level = level;
              this.ERROR = level <= this.LEVEL_ERROR;
              this.WARN = level <= this.LEVEL_WARN;
              this.INFO = level <= this.LEVEL_INFO;
              this.DEBUG = level <= this.LEVEL_DEBUG;
              this.TRACE = level <= this.LEVEL_TRACE;
            }},
            NONE: {value: function () {
              this.set(this.LEVEL_NONE);
            }},
            ERROR_0: {value: function () {
              this.set(this.LEVEL_ERROR);
            }},
            WARN_0: {value: function () {
              this.set(this.LEVEL_WARN);
            }},
            INFO_0: {value: function () {
              this.set(this.LEVEL_INFO);
            }},
            DEBUG_0: {value: function () {
              this.set(this.LEVEL_DEBUG);
            }},
            TRACE_0: {value: function () {
              this.set(this.LEVEL_TRACE);
            }},
            setLogger: {value: function (logger) {
              _.org.kevoree.log.Log.logger = logger;
            }},
            processMessage: {value: function (message, p1, p2, p3, p4, p5) {
              if (p1 == null) {
                return message;
              }
              var buffer = _.java.lang.StringBuilder();
              var previousCharfound = false;
              var param = 0;
              var i = 0;
              while (i < message.length) {
                var currentChar = message.charAt(i);
                if (previousCharfound) {
                  if (currentChar === this.endParam) {
                    param++;
                    if (param === 1) {
                      buffer = _.java.lang.StringBuilder();
                      buffer.append(message.substring(0, i - 1));
                      buffer.append(Kotlin.toString(p1 != null ? p1 : Kotlin.throwNPE()));
                    }
                     else if (param === 2) {
                      buffer.append(Kotlin.toString(p2 != null ? p2 : Kotlin.throwNPE()));
                    }
                     else if (param === 3) {
                      buffer.append(Kotlin.toString(p3 != null ? p3 : Kotlin.throwNPE()));
                    }
                     else if (param === 4) {
                      buffer.append(Kotlin.toString(p4 != null ? p4 : Kotlin.throwNPE()));
                    }
                     else if (param === 5) {
                      buffer.append(Kotlin.toString(p5 != null ? p5 : Kotlin.throwNPE()));
                    }
                     else {
                    }
                    previousCharfound = false;
                  }
                   else {
                    if (buffer != null) {
                      message.charAt(i - 1);
                      buffer.append_0(currentChar);
                    }
                    previousCharfound = false;
                  }
                }
                 else {
                  if (currentChar === this.beginParam) {
                    previousCharfound = true;
                  }
                   else {
                    if (buffer != null) {
                      buffer.append_0(currentChar);
                    }
                  }
                }
                i = i + 1;
              }
              if (buffer != null) {
                return buffer.toString();
              }
               else {
                return message;
              }
            }},
            error: {value: function (message, ex, p1, p2, p3, p4, p5) {
              if (this.ERROR) {
                this.internal_error(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            }},
            error_0: {value: function (message, p1, p2, p3, p4, p5) {
              if (this.ERROR) {
                this.internal_error(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            }},
            internal_error: {value: function (message, ex) {
              this.logger.log(this.LEVEL_ERROR, message, ex);
            }},
            warn: {value: function (message, ex, p1, p2, p3, p4, p5) {
              if (this.WARN) {
                this.internal_warn(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            }},
            warn_0: {value: function (message, p1, p2, p3, p4, p5) {
              if (this.WARN) {
                this.internal_warn(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            }},
            internal_warn: {value: function (message, ex) {
              this.logger.log(this.LEVEL_WARN, message, ex);
            }},
            info: {value: function (message, ex, p1, p2, p3, p4, p5) {
              if (this.INFO) {
                this.internal_info(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            }},
            info_0: {value: function (message, p1, p2, p3, p4, p5) {
              if (this.INFO) {
                this.internal_info(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            }},
            internal_info: {value: function (message, ex) {
              this.logger.log(this.LEVEL_INFO, message, ex);
            }},
            debug: {value: function (message, ex, p1, p2, p3, p4, p5) {
              if (this.DEBUG) {
                this.internal_debug(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            }},
            debug_0: {value: function (message, p1, p2, p3, p4, p5) {
              if (this.DEBUG) {
                this.internal_debug(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            }},
            internal_debug: {value: function (message, ex) {
              this.logger.log(this.LEVEL_DEBUG, message, ex);
            }},
            trace: {value: function (message, ex, p1, p2, p3, p4, p5) {
              if (this.TRACE) {
                this.internal_trace(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            }},
            trace_0: {value: function (message, p1, p2, p3, p4, p5) {
              if (this.TRACE) {
                this.internal_trace(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            }},
            internal_trace: {value: function (message, ex) {
              this.logger.log(this.LEVEL_TRACE, message, ex);
            }}
          })});
        }, {
          Logger: {value: Kotlin.createClass(null, function () {
            Object.defineProperty(this, 'firstLogTime', {value: (new Date()).getTime()});
            Object.defineProperty(this, 'error_msg', {value: ' ERROR: '});
            Object.defineProperty(this, 'warn_msg', {value: ' WARN: '});
            Object.defineProperty(this, 'info_msg', {value: ' INFO: '});
            Object.defineProperty(this, 'debug_msg', {value: ' DEBUG: '});
            Object.defineProperty(this, 'trace_msg', {value: ' TRACE: '});
            Object.defineProperty(this, 'category', {value: null, writable: true});
          }, /** @lends _.org.kevoree.log.Logger.prototype */ {
            setCategory: {value: function (category) {
              this.category = category;
            }},
            log: {value: function (level, message, ex) {
              var builder = _.java.lang.StringBuilder();
              var time = (new Date()).getTime() - this.firstLogTime;
              var minutes = time / (1000 * 60) | 0;
              var seconds = (time / 1000 | 0) % 60;
              if (minutes <= 9)
                builder.append_0('0');
              builder.append(Kotlin.toString(minutes));
              builder.append_0(':');
              if (seconds <= 9)
                builder.append_0('0');
              builder.append(Kotlin.toString(seconds));
              if (level === _.org.kevoree.log.Log.LEVEL_ERROR) {
                builder.append(this.error_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_WARN) {
                builder.append(this.warn_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_INFO) {
                builder.append(this.info_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_DEBUG) {
                builder.append(this.debug_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_TRACE) {
                builder.append(this.trace_msg);
              }
               else {
              }
              if (this.category != null) {
                builder.append_0('[');
                var tmp$0;
                builder.append(((tmp$0 = this.category) != null ? tmp$0 : Kotlin.throwNPE()).toString());
                builder.append('] ');
              }
              builder.append(message);
              if (ex != null) {
                builder.append(Kotlin.toString(ex.getMessage()));
              }
              this.print(builder.toString());
            }},
            print: {value: function (message) {
              Kotlin.println(message);
            }}
          })}
        }),
        container: Kotlin.definePackage(null, {
          KMFContainerImpl: {value: classes.cv},
          RemoveFromContainerCommand: {value: Kotlin.createClass(null, function (target, mutatorType, refName, element) {
            Object.defineProperty(this, 'target', {value: target});
            Object.defineProperty(this, 'mutatorType', {value: mutatorType});
            Object.defineProperty(this, 'refName', {value: refName});
            Object.defineProperty(this, 'element', {value: element});
          }, /** @lends _.org.kevoree.container.RemoveFromContainerCommand.prototype */ {
            run: {value: function () {
              this.target.reflexiveMutator(this.mutatorType, this.refName, this.element, true, true);
            }}
          })}
        }),
        serializer: Kotlin.definePackage(null, {
          XMIModelSerializer: {value: Kotlin.createClass(classes.c7, function $fun() {
            $fun.baseInitializer.call(this);
          })},
          JSONModelSerializer: {value: Kotlin.createClass(classes.cc, function $fun() {
            $fun.baseInitializer.call(this);
          })}
        }),
        cloner: Kotlin.definePackage(null, {
          DefaultModelCloner: {value: Kotlin.createClass(classes.c8, function () {
            Object.defineProperty(this, 'mainFactory', {value: _.org.kevoree.factory.MainFactory(), writable: true});
          }, /** @lends _.org.kevoree.cloner.DefaultModelCloner.prototype */ {
            createContext: {value: function () {
              return Kotlin.ComplexHashMap(0);
            }, writable: true}
          })}
        }),
        compare: Kotlin.definePackage(null, {
          DefaultModelCompare: {value: Kotlin.createClass(classes.c9, null, /** @lends _.org.kevoree.compare.DefaultModelCompare.prototype */ {
            createSequence: {value: function () {
              return _.org.kevoree.trace.DefaultTraceSequence();
            }, writable: true}
          })}
        }),
        factory: Kotlin.definePackage(function () {
          Object.defineProperty(this, 'Package', {value: Kotlin.createObject(null, function () {
            Object.defineProperty(this, 'ORG_KEVOREE', {value: 0});
          }, {
            getPackageForName: {value: function (metaClassName) {
              if (metaClassName.startsWith('org.kevoree')) {
                return 0;
              }
              return -1;
            }}
          })});
        }, {
          MainFactory: {value: Kotlin.createClass(classes.c5, function () {
            Object.defineProperty(this, 'factories', {value: Kotlin.arrayFromFun(1, function (i) {
              return null;
            }), writable: true});
            this.factories[_.org.kevoree.factory.Package.ORG_KEVOREE] = _.org.kevoree.impl.DefaultKevoreeFactory();
          }, /** @lends _.org.kevoree.factory.MainFactory.prototype */ {
            getFactoryForPackage: {value: function (pack) {
              return this.factories[pack];
            }},
            getKevoreeFactory: {value: function () {
              var tmp$0;
              return (tmp$0 = this.factories[_.org.kevoree.factory.Package.ORG_KEVOREE]) != null ? tmp$0 : Kotlin.throwNPE();
            }},
            setKevoreeFactory: {value: function (fct) {
              this.factories[_.org.kevoree.factory.Package.ORG_KEVOREE] = fct;
            }},
            create: {value: function (metaClassName) {
              var pack = _.org.kevoree.factory.Package.getPackageForName(metaClassName);
              if (pack !== -1) {
                var tmp$0;
                return (tmp$0 = this.getFactoryForPackage(pack)) != null ? tmp$0.create(metaClassName) : null;
              }
               else {
                var tmp$1, tmp$2, tmp$3, tmp$4;
                {
                  tmp$1 = Kotlin.arrayIndices(this.factories), tmp$2 = tmp$1.get_start(), tmp$3 = tmp$1.get_end(), tmp$4 = tmp$1.get_increment();
                  for (var i = tmp$2; i <= tmp$3; i += tmp$4) {
                    var tmp$5;
                    var obj = ((tmp$5 = this.factories[i]) != null ? tmp$5 : Kotlin.throwNPE()).create(metaClassName);
                    if (obj != null) {
                      return obj;
                    }
                  }
                }
                return null;
              }
            }, writable: true}
          })}
        }),
        trace: Kotlin.definePackage(null, {
          DefaultTraceSequence: {value: Kotlin.createClass(classes.ch, function () {
            Object.defineProperty(this, 'traces', {value: Kotlin.ArrayList(0), writable: true});
            Object.defineProperty(this, 'factory', {value: _.org.kevoree.factory.MainFactory(), writable: true});
          })}
        }),
        util: Kotlin.definePackage(function () {
          Object.defineProperty(this, 'Constants', {value: Kotlin.createObject(null, function () {
            Object.defineProperty(this, 'UNKNOWN_MUTATION_TYPE_EXCEPTION', {value: 'Unknown mutation type: '});
            Object.defineProperty(this, 'READ_ONLY_EXCEPTION', {value: 'This model is ReadOnly. Elements are not modifiable.'});
            Object.defineProperty(this, 'LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION', {value: 'The list in parameter of the setter cannot be null. Use removeAll to empty a collection.'});
            Object.defineProperty(this, 'ELEMENT_HAS_NO_KEY_IN_COLLECTION', {value: 'Cannot set the collection, because at least one element of it has no key!'});
            Object.defineProperty(this, 'EMPTY_KEY', {value: 'Key empty : please set the attribute key before adding the object.'});
            Object.defineProperty(this, 'KMFQL_CONTAINED', {value: 'contained'});
            Object.defineProperty(this, 'org_kevoree_Instance', {value: 'org.kevoree.Instance'});
            Object.defineProperty(this, 'Ref_superTypes', {value: 'superTypes'});
            Object.defineProperty(this, 'Ref_ports', {value: 'ports'});
            Object.defineProperty(this, 'Att_started', {value: 'started'});
            Object.defineProperty(this, 'org_kevoree_NodeNetwork', {value: 'org.kevoree.NodeNetwork'});
            Object.defineProperty(this, 'org_kevoree_TypedElement', {value: 'org.kevoree.TypedElement'});
            Object.defineProperty(this, 'Ref_hub', {value: 'hub'});
            Object.defineProperty(this, 'Ref_defaultValues', {value: 'defaultValues'});
            Object.defineProperty(this, 'Ref_dataTypes', {value: 'dataTypes'});
            Object.defineProperty(this, 'Att_factoryBean', {value: 'factoryBean'});
            Object.defineProperty(this, 'Ref_port', {value: 'port'});
            Object.defineProperty(this, 'Ref_returnType', {value: 'returnType'});
            Object.defineProperty(this, 'CN_AdaptationPrimitiveType', {value: 'AdaptationPrimitiveType'});
            Object.defineProperty(this, 'CN_Dictionary', {value: 'Dictionary'});
            Object.defineProperty(this, 'Ref_portTypeRef', {value: 'portTypeRef'});
            Object.defineProperty(this, 'CN_ContainerRoot', {value: 'ContainerRoot'});
            Object.defineProperty(this, 'CN_Operation', {value: 'Operation'});
            Object.defineProperty(this, 'CN_PortType', {value: 'PortType'});
            Object.defineProperty(this, 'Att_networkType', {value: 'networkType'});
            Object.defineProperty(this, 'Ref_values', {value: 'values'});
            Object.defineProperty(this, 'Ref_initBy', {value: 'initBy'});
            Object.defineProperty(this, 'Ref_link', {value: 'link'});
            Object.defineProperty(this, 'org_kevoree_ContainerRoot', {value: 'org.kevoree.ContainerRoot'});
            Object.defineProperty(this, 'CN_Group', {value: 'Group'});
            Object.defineProperty(this, 'Ref_hosts', {value: 'hosts'});
            Object.defineProperty(this, 'Att_interface', {value: 'interface'});
            Object.defineProperty(this, 'org_kevoree_MBinding', {value: 'org.kevoree.MBinding'});
            Object.defineProperty(this, 'Ref_subTypes', {value: 'subTypes'});
            Object.defineProperty(this, 'Ref_groups', {value: 'groups'});
            Object.defineProperty(this, 'org_kevoree_Group', {value: 'org.kevoree.Group'});
            Object.defineProperty(this, 'Att_type', {value: 'type'});
            Object.defineProperty(this, 'CN_TypedElement', {value: 'TypedElement'});
            Object.defineProperty(this, 'Ref_dictionary', {value: 'dictionary'});
            Object.defineProperty(this, 'Att_updateMethod', {value: 'updateMethod'});
            Object.defineProperty(this, 'Ref_integrationPatterns', {value: 'integrationPatterns'});
            Object.defineProperty(this, 'org_kevoree_DeployUnit', {value: 'org.kevoree.DeployUnit'});
            Object.defineProperty(this, 'Att_unitName', {value: 'unitName'});
            Object.defineProperty(this, 'Ref_hubs', {value: 'hubs'});
            Object.defineProperty(this, 'Ref_parent', {value: 'parent'});
            Object.defineProperty(this, 'Ref_mappings', {value: 'mappings'});
            Object.defineProperty(this, 'Ref_attributes', {value: 'attributes'});
            Object.defineProperty(this, 'Att_hashcode', {value: 'hashcode'});
            Object.defineProperty(this, 'Att_lowerFragments', {value: 'lowerFragments'});
            Object.defineProperty(this, 'Ref_targetNodeType', {value: 'targetNodeType'});
            Object.defineProperty(this, 'Att_datatype', {value: 'datatype'});
            Object.defineProperty(this, 'Ref_type', {value: 'type'});
            Object.defineProperty(this, 'org_kevoree_LifeCycleTypeDefinition', {value: 'org.kevoree.LifeCycleTypeDefinition'});
            Object.defineProperty(this, 'Att_abstract', {value: 'abstract'});
            Object.defineProperty(this, 'org_kevoree_AdaptationPrimitiveType', {value: 'org.kevoree.AdaptationPrimitiveType'});
            Object.defineProperty(this, 'Att_version', {value: 'version'});
            Object.defineProperty(this, 'CN_Namespace', {value: 'Namespace'});
            Object.defineProperty(this, 'org_kevoree_ContainerNode', {value: 'org.kevoree.ContainerNode'});
            Object.defineProperty(this, 'Ref_components', {value: 'components'});
            Object.defineProperty(this, 'org_kevoree_AdaptationPrimitiveTypeRef', {value: 'org.kevoree.AdaptationPrimitiveTypeRef'});
            Object.defineProperty(this, 'Att_stopMethod', {value: 'stopMethod'});
            Object.defineProperty(this, 'CN_ExtraFonctionalProperty', {value: 'ExtraFonctionalProperty'});
            Object.defineProperty(this, 'Ref_childs', {value: 'childs'});
            Object.defineProperty(this, 'CN_ChannelType', {value: 'ChannelType'});
            Object.defineProperty(this, 'CN_GroupType', {value: 'GroupType'});
            Object.defineProperty(this, 'Ref_typeDefinitions', {value: 'typeDefinitions'});
            Object.defineProperty(this, 'Ref_genericTypes', {value: 'genericTypes'});
            Object.defineProperty(this, 'CN_CompositeType', {value: 'CompositeType'});
            Object.defineProperty(this, 'Ref_requiredLibs', {value: 'requiredLibs'});
            Object.defineProperty(this, 'CN_PortTypeRef', {value: 'PortTypeRef'});
            Object.defineProperty(this, 'Att_maxTime', {value: 'maxTime'});
            Object.defineProperty(this, 'org_kevoree_DictionaryValue', {value: 'org.kevoree.DictionaryValue'});
            Object.defineProperty(this, 'Ref_units', {value: 'units'});
            Object.defineProperty(this, 'CN_DeployUnit', {value: 'DeployUnit'});
            Object.defineProperty(this, 'org_kevoree_NodeLink', {value: 'org.kevoree.NodeLink'});
            Object.defineProperty(this, 'org_kevoree_Parameter', {value: 'org.kevoree.Parameter'});
            Object.defineProperty(this, 'org_kevoree_Repository', {value: 'org.kevoree.Repository'});
            Object.defineProperty(this, 'CN_NamedElement', {value: 'NamedElement'});
            Object.defineProperty(this, 'Att_serviceMethodName', {value: 'serviceMethodName'});
            Object.defineProperty(this, 'CN_Instance', {value: 'Instance'});
            Object.defineProperty(this, 'Ref_networkProperties', {value: 'networkProperties'});
            Object.defineProperty(this, 'CN_AdaptationPrimitiveTypeRef', {value: 'AdaptationPrimitiveTypeRef'});
            Object.defineProperty(this, 'Att_name', {value: 'name'});
            Object.defineProperty(this, 'CN_Repository', {value: 'Repository'});
            Object.defineProperty(this, 'CN_ComponentType', {value: 'ComponentType'});
            Object.defineProperty(this, 'Att_order', {value: 'order'});
            Object.defineProperty(this, 'Att_startMethod', {value: 'startMethod'});
            Object.defineProperty(this, 'Att_lowerBindings', {value: 'lowerBindings'});
            Object.defineProperty(this, 'org_kevoree_CompositeType', {value: 'org.kevoree.CompositeType'});
            Object.defineProperty(this, 'org_kevoree_GroupType', {value: 'org.kevoree.GroupType'});
            Object.defineProperty(this, 'org_kevoree_Operation', {value: 'org.kevoree.Operation'});
            Object.defineProperty(this, 'CN_Port', {value: 'Port'});
            Object.defineProperty(this, 'Att_optional', {value: 'optional'});
            Object.defineProperty(this, 'Ref_targetNode', {value: 'targetNode'});
            Object.defineProperty(this, 'Ref_attribute', {value: 'attribute'});
            Object.defineProperty(this, 'Att_metaData', {value: 'metaData'});
            Object.defineProperty(this, 'Att_beanMethodName', {value: 'beanMethodName'});
            Object.defineProperty(this, 'org_kevoree_TypeDefinition', {value: 'org.kevoree.TypeDefinition'});
            Object.defineProperty(this, 'Ref_target', {value: 'target'});
            Object.defineProperty(this, 'org_kevoree_TypeLibrary', {value: 'org.kevoree.TypeLibrary'});
            Object.defineProperty(this, 'Att_paramTypes', {value: 'paramTypes'});
            Object.defineProperty(this, 'CN_MBinding', {value: 'MBinding'});
            Object.defineProperty(this, 'Att_noDependency', {value: 'noDependency'});
            Object.defineProperty(this, 'CN_NodeLink', {value: 'NodeLink'});
            Object.defineProperty(this, 'CN_PortTypeMapping', {value: 'PortTypeMapping'});
            Object.defineProperty(this, 'Ref_provided', {value: 'provided'});
            Object.defineProperty(this, 'org_kevoree_PortTypeMapping', {value: 'org.kevoree.PortTypeMapping'});
            Object.defineProperty(this, 'Ref_dictionaryType', {value: 'dictionaryType'});
            Object.defineProperty(this, 'CN_ComponentInstance', {value: 'ComponentInstance'});
            Object.defineProperty(this, 'Att_zoneID', {value: 'zoneID'});
            Object.defineProperty(this, 'Att_upperBindings', {value: 'upperBindings'});
            Object.defineProperty(this, 'Ref_host', {value: 'host'});
            Object.defineProperty(this, 'CN_TypeLibrary', {value: 'TypeLibrary'});
            Object.defineProperty(this, 'Ref_adaptationPrimitiveTypes', {value: 'adaptationPrimitiveTypes'});
            Object.defineProperty(this, 'Att_url', {value: 'url'});
            Object.defineProperty(this, 'Ref_namespace', {value: 'namespace'});
            Object.defineProperty(this, 'org_kevoree_NodeType', {value: 'org.kevoree.NodeType'});
            Object.defineProperty(this, 'Ref_managedPrimitiveTypes', {value: 'managedPrimitiveTypes'});
            Object.defineProperty(this, 'CN_LifeCycleTypeDefinition', {value: 'LifeCycleTypeDefinition'});
            Object.defineProperty(this, 'CN_ServicePortType', {value: 'ServicePortType'});
            Object.defineProperty(this, 'CN_NodeNetwork', {value: 'NodeNetwork'});
            Object.defineProperty(this, 'Att_state', {value: 'state'});
            Object.defineProperty(this, 'Att_fragmentDependant', {value: 'fragmentDependant'});
            Object.defineProperty(this, 'org_kevoree_ServicePortType', {value: 'org.kevoree.ServicePortType'});
            Object.defineProperty(this, 'org_kevoree_PortType', {value: 'org.kevoree.PortType'});
            Object.defineProperty(this, 'CN_MessagePortType', {value: 'MessagePortType'});
            Object.defineProperty(this, 'Ref_operations', {value: 'operations'});
            Object.defineProperty(this, 'CN_DictionaryAttribute', {value: 'DictionaryAttribute'});
            Object.defineProperty(this, 'Att_generated_KMF_ID', {value: 'generated_KMF_ID'});
            Object.defineProperty(this, 'org_kevoree_NamedElement', {value: 'org.kevoree.NamedElement'});
            Object.defineProperty(this, 'CN_TypeDefinition', {value: 'TypeDefinition'});
            Object.defineProperty(this, 'org_kevoree_ComponentType', {value: 'org.kevoree.ComponentType'});
            Object.defineProperty(this, 'Ref_mBindings', {value: 'mBindings'});
            Object.defineProperty(this, 'Ref_subNodes', {value: 'subNodes'});
            Object.defineProperty(this, 'Ref_nodes', {value: 'nodes'});
            Object.defineProperty(this, 'org_kevoree_ChannelType', {value: 'org.kevoree.ChannelType'});
            Object.defineProperty(this, 'Ref_nodeNetworks', {value: 'nodeNetworks'});
            Object.defineProperty(this, 'Ref_parameters', {value: 'parameters'});
            Object.defineProperty(this, 'Ref_portTypes', {value: 'portTypes'});
            Object.defineProperty(this, 'Att_estimatedRate', {value: 'estimatedRate'});
            Object.defineProperty(this, 'Att_value', {value: 'value'});
            Object.defineProperty(this, 'org_kevoree_NetworkProperty', {value: 'org.kevoree.NetworkProperty'});
            Object.defineProperty(this, 'org_kevoree_Port', {value: 'org.kevoree.Port'});
            Object.defineProperty(this, 'Ref_managedPrimitiveTypeRefs', {value: 'managedPrimitiveTypeRefs'});
            Object.defineProperty(this, 'org_kevoree_ComponentInstance', {value: 'org.kevoree.ComponentInstance'});
            Object.defineProperty(this, 'org_kevoree_IntegrationPattern', {value: 'org.kevoree.IntegrationPattern'});
            Object.defineProperty(this, 'org_kevoree_DictionaryAttribute', {value: 'org.kevoree.DictionaryAttribute'});
            Object.defineProperty(this, 'Ref_wires', {value: 'wires'});
            Object.defineProperty(this, 'org_kevoree_Namespace', {value: 'org.kevoree.Namespace'});
            Object.defineProperty(this, 'Ref_typeDefinition', {value: 'typeDefinition'});
            Object.defineProperty(this, 'org_kevoree_Channel', {value: 'org.kevoree.Channel'});
            Object.defineProperty(this, 'Ref_deployUnits', {value: 'deployUnits'});
            Object.defineProperty(this, 'org_kevoree_Wire', {value: 'org.kevoree.Wire'});
            Object.defineProperty(this, 'org_kevoree_Dictionary', {value: 'org.kevoree.Dictionary'});
            Object.defineProperty(this, 'Att_synchrone', {value: 'synchrone'});
            Object.defineProperty(this, 'CN_Wire', {value: 'Wire'});
            Object.defineProperty(this, 'Ref_repositories', {value: 'repositories'});
            Object.defineProperty(this, 'Ref_required', {value: 'required'});
            Object.defineProperty(this, 'org_kevoree_ExtraFonctionalProperty', {value: 'org.kevoree.ExtraFonctionalProperty'});
            Object.defineProperty(this, 'Att_lastCheck', {value: 'lastCheck'});
            Object.defineProperty(this, 'Ref_libraries', {value: 'libraries'});
            Object.defineProperty(this, 'Att_upperFragments', {value: 'upperFragments'});
            Object.defineProperty(this, 'CN_IntegrationPattern', {value: 'IntegrationPattern'});
            Object.defineProperty(this, 'CN_ContainerNode', {value: 'ContainerNode'});
            Object.defineProperty(this, 'Att_groupName', {value: 'groupName'});
            Object.defineProperty(this, 'CN_Parameter', {value: 'Parameter'});
            Object.defineProperty(this, 'CN_DictionaryValue', {value: 'DictionaryValue'});
            Object.defineProperty(this, 'org_kevoree_PortTypeRef', {value: 'org.kevoree.PortTypeRef'});
            Object.defineProperty(this, 'Ref_filters', {value: 'filters'});
            Object.defineProperty(this, 'CN_NetworkProperty', {value: 'NetworkProperty'});
            Object.defineProperty(this, 'org_kevoree_DictionaryType', {value: 'org.kevoree.DictionaryType'});
            Object.defineProperty(this, 'CN_NodeType', {value: 'NodeType'});
            Object.defineProperty(this, 'Att_bean', {value: 'bean'});
            Object.defineProperty(this, 'CN_Channel', {value: 'Channel'});
            Object.defineProperty(this, 'Ref_bindings', {value: 'bindings'});
            Object.defineProperty(this, 'Ref_ref', {value: 'ref'});
            Object.defineProperty(this, 'CN_DictionaryType', {value: 'DictionaryType'});
            Object.defineProperty(this, 'Ref_extraFonctionalProperties', {value: 'extraFonctionalProperties'});
            Object.defineProperty(this, 'org_kevoree_MessagePortType', {value: 'org.kevoree.MessagePortType'});
          })});
        }, {
        })
      }),
      w3c: Kotlin.definePackage(null, {
        dom: Kotlin.definePackage(null, {
          events: Kotlin.definePackage(null, {
            EventListener: {value: classes.c1p}
          })
        })
      })
    }),
    js: Kotlin.definePackage(null, {
      toChar: {value: function ($receiver) {
        return $receiver != null ? $receiver : Kotlin.throwNPE();
      }},
      lastIndexOf: {value: function ($receiver, ch, fromIndex) {
        return $receiver.lastIndexOf(Kotlin.toString(ch), fromIndex);
      }},
      lastIndexOf_0: {value: function ($receiver, ch) {
        return $receiver.lastIndexOf(Kotlin.toString(ch));
      }},
      indexOf: {value: function ($receiver, ch) {
        return $receiver.indexOf(Kotlin.toString(ch));
      }},
      indexOf_0: {value: function ($receiver, ch, fromIndex) {
        return $receiver.indexOf(Kotlin.toString(ch), fromIndex);
      }},
      matches: {value: function ($receiver, regex) {
        var result = $receiver.match(regex);
        return result != null && result.length > 0;
      }},
      capitalize: {value: function ($receiver) {
        return _.kotlin.isNotEmpty($receiver) ? $receiver.substring(0, 1).toUpperCase() + $receiver.substring(1) : $receiver;
      }},
      decapitalize: {value: function ($receiver) {
        return _.kotlin.isNotEmpty($receiver) ? $receiver.substring(0, 1).toLowerCase() + $receiver.substring(1) : $receiver;
      }}
    }),
    java: Kotlin.definePackage(null, {
      lang: Kotlin.definePackage(null, {
        StringBuilder: {value: Kotlin.createClass(null, function () {
          Object.defineProperty(this, 'content', {value: '', writable: true});
        }, /** @lends _.java.lang.StringBuilder.prototype */ {
          append: {value: function (sub) {
            this.content = this.content + sub;
          }},
          append_0: {value: function (sub) {
            this.content = this.content + sub;
          }},
          delete: {value: function (startIndex, endIndex) {
            this.content = '';
          }},
          length: {value: function () {
            return this.content.length;
          }},
          toString: {value: function () {
            return this.content;
          }}
        })}
      }),
      io: Kotlin.definePackage(null, {
        InputStream: {value: classes.c1n},
        OutputStream: {value: classes.c1o},
        BufferedOutputStream: {value: Kotlin.createClass(classes.c1o, function (oo) {
          Object.defineProperty(this, 'oo', {value: oo});
        }, /** @lends _.java.io.BufferedOutputStream.prototype */ {
          write: {value: function (s) {
            var tmp$0;
            ((tmp$0 = this.oo) != null ? tmp$0 : Kotlin.throwNPE()).result = s;
          }}
        })},
        ByteArrayInputStream: {value: Kotlin.createClass(classes.c1n, function (inputBytes) {
          Object.defineProperty(this, 'inputBytes', {value: inputBytes});
        }, /** @lends _.java.io.ByteArrayInputStream.prototype */ {
          readBytes: {value: function () {
            return this.inputBytes;
          }, writable: true}
        })},
        ByteArrayOutputStream: {value: Kotlin.createClass(classes.c1o, function () {
          Object.defineProperty(this, 'result', {value: '', writable: true});
        }, /** @lends _.java.io.ByteArrayOutputStream.prototype */ {
          flush: {value: function () {
          }},
          close: {value: function () {
          }},
          toString: {value: function () {
            return this.result;
          }}
        })},
        PrintStream: {value: Kotlin.createClass(null, function (oo, autoflush) {
          Object.defineProperty(this, 'oo', {value: oo});
          Object.defineProperty(this, 'result', {value: '', writable: true});
        }, /** @lends _.java.io.PrintStream.prototype */ {
          println_1: {value: function () {
            this.result = this.result + '\n';
          }},
          print: {value: function (s) {
            this.result = this.result + s;
          }},
          println: {value: function (s) {
            this.print(s);
            this.println_1();
          }},
          print_0: {value: function (s) {
            this.result = this.result + s;
          }},
          print_1: {value: function (s) {
            this.result = this.result + s;
          }},
          print_2: {value: function (s) {
            this.result = this.result + s;
          }},
          print_3: {value: function (s) {
            if (s) {
              this.result = this.result + 'true';
            }
             else {
              this.result = this.result + 'false';
            }
          }},
          println_0: {value: function (s) {
            this.print_0(s);
            this.println_1();
          }},
          flush: {value: function () {
            var tmp$0;
            ((tmp$0 = this.oo) != null ? tmp$0 : Kotlin.throwNPE()).write(this.result);
          }},
          close: {value: function () {
          }}
        })}
      }),
      util: Kotlin.definePackage(null, {
        Collections: Kotlin.definePackage(null, {
        })
      })
    })
  });
  Kotlin.defineModule('org.kevoree.model.js', _);
}());
if(typeof(module)!='undefined'){module.exports = Kotlin.modules['org.kevoree.model.js'];}

},{}],8:[function(require,module,exports){
module.exports.KevoreeLogger  = require('./lib/KevoreeLogger');
},{"./lib/KevoreeLogger":9}],9:[function(require,module,exports){
var Class = require('pseudoclass');

var KevoreeLogger = Class({
    toString: 'KevoreeLogger',

    construct: function (tag) {
        this.tag = tag;
    },

    info: function () {
        var template = '[INFO] %s: ' + (arguments[0] || '');
        var args = [template, this.tag];
        for (var i=1; i < arguments.length; i++) args.push(arguments[i]);
        console.log.apply(this, args);
    },

    warn: function (msg) {
        var template = '[WARN] %s: ' + (arguments[0] || '');
        var args = [template, this.tag];
        for (var i=1; i < arguments.length; i++) args.push(arguments[i]);
        console.log.apply(this, args);
    },

    error: function (msg) {
        var template = '[ERROR] %s: ' + (arguments[0] || '');
        var args = [template, this.tag];
        for (var i=1; i < arguments.length; i++) args.push(arguments[i]);
        console.log.apply(this, args);
    },

    debug: function (msg) {
        var template = '[DEBUG] %s: ' + (arguments[0] || '');
        var args = [template, this.tag];
        for (var i=1; i < arguments.length; i++) args.push(arguments[i]);
        console.log.apply(this, args);
    }
});

module.exports = KevoreeLogger;
},{"pseudoclass":10}],10:[function(require,module,exports){
/*
	Class - JavaScript inheritance

	Construction:
		Setup and construction should happen in the construct() method.
		The construct() method is automatically chained, so all construct() methods defined by superclass methods will be called first.

	Initialization:
		Initialziation that needs to happen after all construct() methods have been called should be done in the init() method.
		The init() method is not automatically chained, so you must call _super() if you intend to call the superclass' init method.
		init() is not passed any arguments

	Destruction:
		Teardown and destruction should happen in the destruct() method. The destruct() method is also chained.

	Mixins:
		An array of mixins can be provided with the mixins[] property. An object or the prototype of a class should be provided, not a constructor.
		Mixins can be added at any time by calling this.mixin(properties)

	Usage:
		var MyClass = Class(properties);
		var MyClass = new Class(properties);
		var MyClass = Class.extend(properties);

	Credits:
		Inspired by Simple JavaScript Inheritance by John Resig http://ejohn.org/

	Usage differences:
		construct() is used to setup instances and is automatically chained so superclass construct() methods run automatically
		destruct() is used  to tear down instances. destruct() is also chained
		init(), if defined, is called after construction is complete and is not chained
		toString() can be defined as a string or a function
		mixin() is provided to mix properties into an instance
		properties.mixins as an array results in each of the provided objects being mixed in (last object wins)
		_super is passed as an argument (not as this._super) and can be used asynchronously
*/
(function(global) {
	// Used for default initialization methods
	var noop = function() {};

	// Given a function, the superTest RE will match if _super is the first argument to a function
	// The function will be serialized, then the serialized string will be searched for _super
	// If the environment isn't capable of function serialization, make it so superTest.test always returns true
	var superTest = /xyz/.test(function(){return 'xyz';}) ? /\(\s*_super\b/ : { test: function() { return true; } };

	// Remove the _super function from the passed arguments array
	var removeSuper = function(args, _super) {
		// For performance, first check if at least one argument was passed
		if (args && args.length && args[0] === _super)
			args = Array.prototype.slice.call(args, 1);
		return args;
	};

	// Bind an overriding method such that it gets the overridden method as its first argument
	var superify = function(name, func, superPrototype, isStatic) {
		var _super;

		// We redefine _super.apply so _super is stripped from the passed arguments array
		// This allows implementors to call _super.apply(this, arguments) without manually stripping off _super
		if (isStatic) {
			// Static binding: If the passed superPrototype is modified, the bound function will still call the ORIGINAL method
			// This comes into play when functions are mixed into an object that already has a function by that name (i.e. two mixins are used)
			var superFunc = superPrototype[name];
			_super = function _superStatic() {
				return superFunc.apply(this, arguments);
			};

			_super.apply = function _applier(context, args) {
				return Function.prototype.apply.call(superFunc, context, removeSuper(args, _super));
			};
		}
		else {
			// Dynamic binding: If the passed superPrototype is modified, the bound function will call the NEW method
			// This comes into play when functions are mixed into a class at declaration time
			_super = function _superDynamic() {
				return superPrototype[name].apply(this, arguments);
			};

			_super.apply = function _applier(context, args) {
				return Function.prototype.apply.call(superPrototype[name], context, removeSuper(args, _super));
			};
		}

		// Name the function for better stack traces
		return function _passSuper() {
			// Add the super function to the start of the arguments array
			var args = Array.prototype.slice.call(arguments);
			args.unshift(_super);

			// Call the function with the modified arguments
			return func.apply(this, args);
		};
	};

	// Mix the provided properties into the current context with the ability to call overridden methods with _super()
	var mixin = function(properties, superPrototype) {
		// Use this instance
		superPrototype = superPrototype || this.constructor && this.constructor.prototype;
		
		// Copy the properties onto the new prototype
		for (var name in properties) {
			// Never mix construct or destruct
			if (name === 'construct' || name === 'destruct')
				continue;

			// Check if the function uses _super
			// It should be a function, the super prototype should have a function by the same name
			// And finally, the function should take _super as its first argument
			var usesSuper = superPrototype && typeof properties[name] === 'function' && typeof superPrototype[name] === 'function' && superTest.test(properties[name]);

			if (usesSuper) {
				// Wrap the function such that _super will be passed accordingly
				if (this.hasOwnProperty(name))
					this[name] = superify(name, properties[name], this, true);
				else
					this[name] = superify(name, properties[name], superPrototype, false);
			}
			else {
				// Directly assign the property
				this[name] = properties[name];
			}
		}
	};

	// The base Class implementation acts as extend alias, with the exception that it can take properties.extend as the Class to extend
	var Class = function(properties) {
		// If a class-like object is passed as properties.extend, just call extend on it
		if (properties && properties.extend)
			return properties.extend.extend(properties);

		// Otherwise, just create a new class with the passed properties
		return Class.extend(properties);
	};
	
	// Add the mixin method to all classes created with Class
	Class.prototype.mixin = mixin;
	
	// Creates a new Class that inherits from this class
	// Give the function a name so it can refer to itself without arguments.callee
	Class.extend = function extend(properties) {
		var superPrototype = this.prototype;
		
		// Create an object with the prototype of the superclass
		var prototype = Object.create(superPrototype);
		
		if (properties) {
			// Mix the new properties into the class prototype
			// This does not copy construct and destruct
			mixin.call(prototype, properties, superPrototype);
			
			// Mix in all the mixins
			// This also does not copy construct and destruct
			if (Array.isArray(properties.mixins)) {
				for (var i = 0, ni = properties.mixins.length; i < ni; i++) {
					// Mixins should be _super enabled, with the methods defined in the prototype as the superclass methods
					mixin.call(prototype, properties.mixins[i], prototype);
				}
			}
			
			// Chain the construct() method (supermost executes first) if necessary
			if (properties.construct && superPrototype.construct) {
				prototype.construct = function() {
					superPrototype.construct.apply(this, arguments);
					properties.construct.apply(this, arguments);
				};
			}
			else if (properties.construct)
				prototype.construct = properties.construct;
			
			// Chain the destruct() method in reverse order (supermost executes last) if necessary
			if (properties.destruct && superPrototype.destruct) {
				prototype.destruct = function() {
					properties.destruct.apply(this, arguments);
					superPrototype.destruct.apply(this, arguments);
				};
			}
			else if (properties.destruct)
				prototype.destruct = properties.destruct;
			
			// Allow definition of toString as a string (turn it into a function)
			if (typeof properties.toString === 'string') {
				var className = properties.toString;
				prototype.toString = function() { return className; };
			}
		}

		// Define construct and init as noops if undefined
		// This serves to avoid conditionals inside of the constructor
		if (typeof prototype.construct !== 'function')
			prototype.construct = noop;
		if (typeof prototype.init !== 'function')
			prototype.init = noop;

		// The constructor handles creating an instance of the class, applying mixins, and calling construct() and init() methods
		function Class() {
			// Optimization: Requiring the new keyword and avoiding usage of Object.create() increases performance by 5x
			if (this instanceof Class === false) {
				throw new Error('Cannot create instance without new operator');
			}
			
			// Optimization: Avoiding conditionals in constructor increases performance of instantiation by 2x
			this.construct.apply(this, arguments);
			this.init();
		}

		// Assign prototype.constructor to the constructor itself
		// This allows instances to refer to this.constructor.prototype
		// This also allows creation of new instances using instance.constructor()
		prototype.constructor = Class;

		// Store the superPrototype
		// It will be accessible on an instance as follows:
		//	instance.superPrototype
		//	instance.constructor.prototype.superPrototype
		prototype.superPrototype = superPrototype;

		// Store the extended class' prototype as the prototype of the constructor
		Class.prototype = prototype;

		// Add extend() as a static method on the constructor
		Class.extend = extend;

		return Class;
	};
	
	if (typeof module !== 'undefined' && module.exports) {
		// Node.js Support
		module.exports = Class;
	}
	else if (typeof global.define === 'function') {
		(function(define) {
			// AMD Support
			define(function() { return Class; });
		}(global.define));
	}
	else {
		// Browser support
		global.Class = Class;
	}
}(this));

},{}],11:[function(require,module,exports){


//
// The shims in this file are not fully implemented shims for the ES5
// features, but do work for the particular usecases there is in
// the other modules.
//

var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

// Array.isArray is supported in IE9
function isArray(xs) {
  return toString.call(xs) === '[object Array]';
}
exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

// Array.prototype.indexOf is supported in IE9
exports.indexOf = function indexOf(xs, x) {
  if (xs.indexOf) return xs.indexOf(x);
  for (var i = 0; i < xs.length; i++) {
    if (x === xs[i]) return i;
  }
  return -1;
};

// Array.prototype.filter is supported in IE9
exports.filter = function filter(xs, fn) {
  if (xs.filter) return xs.filter(fn);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (fn(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
};

// Array.prototype.forEach is supported in IE9
exports.forEach = function forEach(xs, fn, self) {
  if (xs.forEach) return xs.forEach(fn, self);
  for (var i = 0; i < xs.length; i++) {
    fn.call(self, xs[i], i, xs);
  }
};

// Array.prototype.map is supported in IE9
exports.map = function map(xs, fn) {
  if (xs.map) return xs.map(fn);
  var out = new Array(xs.length);
  for (var i = 0; i < xs.length; i++) {
    out[i] = fn(xs[i], i, xs);
  }
  return out;
};

// Array.prototype.reduce is supported in IE9
exports.reduce = function reduce(array, callback, opt_initialValue) {
  if (array.reduce) return array.reduce(callback, opt_initialValue);
  var value, isValueSet = false;

  if (2 < arguments.length) {
    value = opt_initialValue;
    isValueSet = true;
  }
  for (var i = 0, l = array.length; l > i; ++i) {
    if (array.hasOwnProperty(i)) {
      if (isValueSet) {
        value = callback(value, array[i], i, array);
      }
      else {
        value = array[i];
        isValueSet = true;
      }
    }
  }

  return value;
};

// String.prototype.substr - negative index don't work in IE8
if ('ab'.substr(-1) !== 'b') {
  exports.substr = function (str, start, length) {
    // did we get a negative start, calculate how much it is from the beginning of the string
    if (start < 0) start = str.length + start;

    // call the original function
    return str.substr(start, length);
  };
} else {
  exports.substr = function (str, start, length) {
    return str.substr(start, length);
  };
}

// String.prototype.trim is supported in IE9
exports.trim = function (str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
};

// Function.prototype.bind is supported in IE9
exports.bind = function () {
  var args = Array.prototype.slice.call(arguments);
  var fn = args.shift();
  if (fn.bind) return fn.bind.apply(fn, args);
  var self = args.shift();
  return function () {
    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
  };
};

// Object.create is supported in IE9
function create(prototype, properties) {
  var object;
  if (prototype === null) {
    object = { '__proto__' : null };
  }
  else {
    if (typeof prototype !== 'object') {
      throw new TypeError(
        'typeof prototype[' + (typeof prototype) + '] != \'object\''
      );
    }
    var Type = function () {};
    Type.prototype = prototype;
    object = new Type();
    object.__proto__ = prototype;
  }
  if (typeof properties !== 'undefined' && Object.defineProperties) {
    Object.defineProperties(object, properties);
  }
  return object;
}
exports.create = typeof Object.create === 'function' ? Object.create : create;

// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
// they do show a description and number property on Error objects
function notObject(object) {
  return ((typeof object != "object" && typeof object != "function") || object === null);
}

function keysShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.keys called on a non-object");
  }

  var result = [];
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// getOwnPropertyNames is almost the same as Object.keys one key feature
//  is that it returns hidden properties, since that can't be implemented,
//  this feature gets reduced so it just shows the length property on arrays
function propertyShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
  }

  var result = keysShim(object);
  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
    result.push('length');
  }
  return result;
}

var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
  Object.getOwnPropertyNames : propertyShim;

if (new Error().hasOwnProperty('description')) {
  var ERROR_PROPERTY_FILTER = function (obj, array) {
    if (toString.call(obj) === '[object Error]') {
      array = exports.filter(array, function (name) {
        return name !== 'description' && name !== 'number' && name !== 'message';
      });
    }
    return array;
  };

  exports.keys = function (object) {
    return ERROR_PROPERTY_FILTER(object, keys(object));
  };
  exports.getOwnPropertyNames = function (object) {
    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
  };
} else {
  exports.keys = keys;
  exports.getOwnPropertyNames = getOwnPropertyNames;
}

// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
function valueObject(value, key) {
  return { value: value[key] };
}

if (typeof Object.getOwnPropertyDescriptor === 'function') {
  try {
    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  } catch (e) {
    // IE8 dom element issue - use a try catch and default to valueObject
    exports.getOwnPropertyDescriptor = function (value, key) {
      try {
        return Object.getOwnPropertyDescriptor(value, key);
      } catch (e) {
        return valueObject(value, key);
      }
    };
  }
} else {
  exports.getOwnPropertyDescriptor = valueObject;
}

},{}],12:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;
var util = require('util');
var shims = require('_shims');
var timers = require('timers');
var Readable = require('_stream_readable');
var Writable = require('_stream_writable');

util.inherits(Duplex, Readable);

shims.forEach(shims.keys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  timers.setImmediate(shims.bind(this.end, this));
}

},{"_shims":11,"_stream_readable":14,"_stream_writable":16,"timers":22,"util":24}],13:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('_stream_transform');
var util = require('util');
util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"_stream_transform":15,"util":24}],14:[function(require,module,exports){
var process=require("__browserify_process");// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;
Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;
var Stream = require('stream');
var shims = require('_shims');
var Buffer = require('buffer').Buffer;
var timers = require('timers');
var util = require('util');
var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || n === null) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode &&
      !er) {
    console.log('chunk: ', chunk);
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    timers.setImmediate(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    timers.setImmediate(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    timers.setImmediate(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  // check for listeners before emit removes one-time listeners.
  var errListeners = EE.listenerCount(dest, 'error');
  function onerror(er) {
    unpipe();
    if (errListeners === 0 && EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  dest.once('error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    timers.setImmediate(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      shims.forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = shims.indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      timers.setImmediate(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  shims.forEach(events, function(ev) {
    stream.on(ev, shims.bind(self.emit, self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    timers.setImmediate(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

},{"__browserify_process":49,"_shims":11,"buffer":26,"events":18,"stream":20,"string_decoder":21,"timers":22,"util":24}],15:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('_stream_duplex');
var util = require('util');
util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"_stream_duplex":12,"util":24}],16:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;
Writable.WritableState = WritableState;

var util = require('util');
var Stream = require('stream');
var timers = require('timers');
var Buffer = require('buffer').Buffer;

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];
}

function Writable(options) {
  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  timers.setImmediate(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    timers.setImmediate(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  state.needDrain = !ret;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    timers.setImmediate(function() {
      cb(er);
    });
  else
    cb(er);

  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      timers.setImmediate(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      timers.setImmediate(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

},{"buffer":26,"stream":20,"timers":22,"util":24}],17:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// UTILITY
var util = require('util');
var shims = require('_shims');
var pSlice = Array.prototype.slice;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  this.message = options.message || getMessage(this);
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = shims.keys(a),
        kb = shims.keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};
},{"_shims":11,"util":24}],18:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util');

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!util.isNumber(n) || n < 0)
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (util.isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        throw TypeError('Uncaught, unspecified "error" event.');
      }
      return false;
    }
  }

  handler = this._events[type];

  if (util.isUndefined(handler))
    return false;

  if (util.isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (util.isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              util.isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (util.isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (util.isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!util.isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      console.trace();
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  function g() {
    this.removeListener(type, g);
    listener.apply(this, arguments);
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (util.isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (util.isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (util.isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (util.isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (util.isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};
},{"util":24}],19:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// Query String Utilities

var QueryString = exports;
var util = require('util');
var shims = require('_shims');
var Buffer = require('buffer').Buffer;

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}


function charCode(c) {
  return c.charCodeAt(0);
}


// a safe fast alternative to decodeURIComponent
QueryString.unescapeBuffer = function(s, decodeSpaces) {
  var out = new Buffer(s.length);
  var state = 'CHAR'; // states: CHAR, HEX0, HEX1
  var n, m, hexchar;

  for (var inIndex = 0, outIndex = 0; inIndex <= s.length; inIndex++) {
    var c = s.charCodeAt(inIndex);
    switch (state) {
      case 'CHAR':
        switch (c) {
          case charCode('%'):
            n = 0;
            m = 0;
            state = 'HEX0';
            break;
          case charCode('+'):
            if (decodeSpaces) c = charCode(' ');
            // pass thru
          default:
            out[outIndex++] = c;
            break;
        }
        break;

      case 'HEX0':
        state = 'HEX1';
        hexchar = c;
        if (charCode('0') <= c && c <= charCode('9')) {
          n = c - charCode('0');
        } else if (charCode('a') <= c && c <= charCode('f')) {
          n = c - charCode('a') + 10;
        } else if (charCode('A') <= c && c <= charCode('F')) {
          n = c - charCode('A') + 10;
        } else {
          out[outIndex++] = charCode('%');
          out[outIndex++] = c;
          state = 'CHAR';
          break;
        }
        break;

      case 'HEX1':
        state = 'CHAR';
        if (charCode('0') <= c && c <= charCode('9')) {
          m = c - charCode('0');
        } else if (charCode('a') <= c && c <= charCode('f')) {
          m = c - charCode('a') + 10;
        } else if (charCode('A') <= c && c <= charCode('F')) {
          m = c - charCode('A') + 10;
        } else {
          out[outIndex++] = charCode('%');
          out[outIndex++] = hexchar;
          out[outIndex++] = c;
          break;
        }
        out[outIndex++] = 16 * n + m;
        break;
    }
  }

  // TODO support returning arbitrary buffers.

  return out.slice(0, outIndex - 1);
};


QueryString.unescape = function(s, decodeSpaces) {
  return QueryString.unescapeBuffer(s, decodeSpaces).toString();
};


QueryString.escape = function(str) {
  return encodeURIComponent(str);
};

var stringifyPrimitive = function(v) {
  if (util.isString(v))
    return v;
  if (util.isBoolean(v))
    return v ? 'true' : 'false';
  if (util.isNumber(v))
    return isFinite(v) ? v : '';
  return '';
};


QueryString.stringify = QueryString.encode = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (util.isNull(obj)) {
    obj = undefined;
  }

  if (util.isObject(obj)) {
    return shims.map(shims.keys(obj), function(k) {
      var ks = QueryString.escape(stringifyPrimitive(k)) + eq;
      if (util.isArray(obj[k])) {
        return shims.map(obj[k], function(v) {
          return ks + QueryString.escape(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + QueryString.escape(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return QueryString.escape(stringifyPrimitive(name)) + eq +
         QueryString.escape(stringifyPrimitive(obj));
};

// Parse a key=val string.
QueryString.parse = QueryString.decode = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (!util.isString(qs) || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && util.isNumber(options.maxKeys)) {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    try {
      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);
    } catch (e) {
      k = QueryString.unescape(kstr, true);
      v = QueryString.unescape(vstr, true);
    }

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (util.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};
},{"_shims":11,"buffer":26,"util":24}],20:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var util = require('util');

util.inherits(Stream, EE);
Stream.Readable = require('_stream_readable');
Stream.Writable = require('_stream_writable');
Stream.Duplex = require('_stream_duplex');
Stream.Transform = require('_stream_transform');
Stream.PassThrough = require('_stream_passthrough');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"_stream_duplex":12,"_stream_passthrough":13,"_stream_readable":14,"_stream_transform":15,"_stream_writable":16,"events":18,"util":24}],21:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

function assertEncoding(encoding) {
  if (encoding && !Buffer.isEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  this.charBuffer = new Buffer(6);
  this.charReceived = 0;
  this.charLength = 0;
};


StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  var offset = 0;

  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var i = (buffer.length >= this.charLength - this.charReceived) ?
                this.charLength - this.charReceived :
                buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, offset, i);
    this.charReceived += (i - offset);
    offset = i;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (i == buffer.length) return charStr;

    // otherwise cut off the characters end from the beginning of this buffer
    buffer = buffer.slice(i, buffer.length);
    break;
  }

  var lenIncomplete = this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
    this.charReceived = lenIncomplete;
    end -= lenIncomplete;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }

  return i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 2;
  this.charLength = incomplete ? 2 : 0;
  return incomplete;
}

function base64DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 3;
  this.charLength = incomplete ? 3 : 0;
  return incomplete;
}

},{"buffer":26}],22:[function(require,module,exports){
try {
    // Old IE browsers that do not curry arguments
    if (!setTimeout.call) {
        var slicer = Array.prototype.slice;
        exports.setTimeout = function(fn) {
            var args = slicer.call(arguments, 1);
            return setTimeout(function() {
                return fn.apply(this, args);
            })
        };

        exports.setInterval = function(fn) {
            var args = slicer.call(arguments, 1);
            return setInterval(function() {
                return fn.apply(this, args);
            });
        };
    } else {
        exports.setTimeout = setTimeout;
        exports.setInterval = setInterval;
    }
    exports.clearTimeout = clearTimeout;
    exports.clearInterval = clearInterval;

    if (window.setImmediate) {
      exports.setImmediate = window.setImmediate;
      exports.clearImmediate = window.clearImmediate;
    }

    // Chrome and PhantomJS seems to depend on `this` pseudo variable being a
    // `window` and throws invalid invocation exception otherwise. If this code
    // runs in such JS runtime next line will throw and `catch` clause will
    // exported timers functions bound to a window.
    exports.setTimeout(function() {});
} catch (_) {
    function bind(f, context) {
        return function () { return f.apply(context, arguments) };
    }

    if (typeof window !== 'undefined') {
      exports.setTimeout = bind(setTimeout, window);
      exports.setInterval = bind(setInterval, window);
      exports.clearTimeout = bind(clearTimeout, window);
      exports.clearInterval = bind(clearInterval, window);
      if (window.setImmediate) {
        exports.setImmediate = bind(window.setImmediate, window);
        exports.clearImmediate = bind(window.clearImmediate, window);
      }
    } else {
      if (typeof setTimeout !== 'undefined') {
        exports.setTimeout = setTimeout;
      }
      if (typeof setInterval !== 'undefined') {
        exports.setInterval = setInterval;
      }
      if (typeof clearTimeout !== 'undefined') {
        exports.clearTimeout = clearTimeout;
      }
      if (typeof clearInterval === 'function') {
        exports.clearInterval = clearInterval;
      }
    }
}

exports.unref = function unref() {};
exports.ref = function ref() {};

if (!exports.setImmediate) {
  var currentKey = 0, queue = {}, active = false;

  exports.setImmediate = (function () {
      function drain() {
        active = false;
        for (var key in queue) {
          if (queue.hasOwnProperty(currentKey, key)) {
            var fn = queue[key];
            delete queue[key];
            fn();
          }
        }
      }

      if (typeof window !== 'undefined' &&
          window.postMessage && window.addEventListener) {
        window.addEventListener('message', function (ev) {
          if (ev.source === window && ev.data === 'browserify-tick') {
            ev.stopPropagation();
            drain();
          }
        }, true);

        return function setImmediate(fn) {
          var id = ++currentKey;
          queue[id] = fn;
          if (!active) {
            active = true;
            window.postMessage('browserify-tick', '*');
          }
          return id;
        };
      } else {
        return function setImmediate(fn) {
          var id = ++currentKey;
          queue[id] = fn;
          if (!active) {
            active = true;
            setTimeout(drain, 0);
          }
          return id;
        };
      }
  })();

  exports.clearImmediate = function clearImmediate(id) {
    delete queue[id];
  };
}

},{}],23:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = { encode : function (s) { return s } };
var util = require('util');
var shims = require('_shims');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = shims.trim(rest);

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      shims.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && shims.substr(protocol, -1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  shims.forEach(shims.keys(this), function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    shims.forEach(shims.keys(relative), function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      shims.forEach(shims.keys(relative), function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (shims.substr(srcPath.join('/'), -1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};
},{"_shims":11,"querystring":19,"util":24}],24:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var shims = require('_shims');

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  shims.forEach(array, function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = shims.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = shims.getOwnPropertyNames(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }

  shims.forEach(keys, function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (shims.indexOf(ctx.seen, desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = shims.reduce(output, function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return shims.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return arg instanceof Buffer;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = shims.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = shims.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

},{"__browserify_Buffer":48,"_shims":11}],25:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],26:[function(require,module,exports){
var assert;
exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function Buffer(subject, encoding, offset) {
  if(!assert) assert= require('assert');
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding == "base64" && typeof subject == "string") {
    subject = stringtrim(subject);
    while (subject.length % 4 != 0) {
      subject = subject + "="; 
    }
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    // slicing works, with limitations (no parent tracking/update)
    // check https://github.com/toots/buffer-browserify/issues/19
    for (var i = 0; i < this.length; i++) {
        this[i] = subject.get(i+offset);
    }
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          this[i] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};

// slice(start, end)
function clamp(index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
}

Buffer.prototype.slice = function(start, end) {
  var len = this.length;
  start = clamp(start, len, 0);
  end = clamp(end, len, len);
  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

},{"./buffer_ieee754":25,"assert":17,"base64-js":27}],27:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],28:[function(require,module,exports){
var http = module.exports;
var EventEmitter = require('events').EventEmitter;
var Request = require('./lib/request');

http.request = function (params, cb) {
    if (!params) params = {};
    if (!params.host) params.host = window.location.host.split(':')[0];
    if (!params.port) params.port = window.location.port;
    if (!params.scheme) params.scheme = window.location.protocol.split(':')[0];
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

},{"./lib/request":29,"events":18}],29:[function(require,module,exports){
var Stream = require('stream');
var Response = require('./response');
var concatStream = require('concat-stream');
var Base64 = require('Base64');

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = concatStream()
    
    var uri = params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    xhr.open(
        params.method || 'GET',
        (params.scheme || 'http') + '://' + uri,
        true
    );
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            if (isArray(value)) {
                for (var j = 0; j < value.length; j++) {
                    xhr.setRequestHeader(key, value[j]);
                }
            }
            else xhr.setRequestHeader(key, value)
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });
    
    xhr.onreadystatechange = function () {
        res.handle(xhr);
    };
};

Request.prototype = new Stream;

Request.prototype.setHeader = function (key, value) {
    if (isArray(value)) {
        for (var i = 0; i < value.length; i++) {
            this.xhr.setRequestHeader(key, value[i]);
        }
    }
    else {
        this.xhr.setRequestHeader(key, value);
    }
};

Request.prototype.write = function (s) {
    this.body.write(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.write(s);
    this.body.end()
    this.xhr.send(this.body.getBody());
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

},{"./response":30,"Base64":31,"concat-stream":34,"stream":20}],30:[function(require,module,exports){
var Stream = require('stream');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

Response.prototype = new Stream;

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":20}],31:[function(require,module,exports){
;(function () {

  var
    object = typeof exports != 'undefined' ? exports : window,
    chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    INVALID_CHARACTER_ERR = (function () {
      // fabricate a suitable error object
      try { document.createElement('$'); }
      catch (error) { return error; }}());

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next input index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      input.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = input.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) throw INVALID_CHARACTER_ERR;
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    input = input.replace(/=+$/, '')
    if (input.length % 4 == 1) throw INVALID_CHARACTER_ERR;
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = input.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],32:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;const Zlib = module.exports = require('./zlib');

// the least I can do is make error messages for the rest of the node.js/zlib api.
// (thanks, dominictarr)
function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/brianloveswords/zlib-browserify'
    ].join('\n'))
}

;['createGzip'
, 'createGunzip'
, 'createDeflate'
, 'createDeflateRaw'
, 'createInflate'
, 'createInflateRaw'
, 'createUnzip'
, 'Gzip'
, 'Gunzip'
, 'Inflate'
, 'InflateRaw'
, 'Deflate'
, 'DeflateRaw'
, 'Unzip'
, 'inflateRaw'
, 'deflateRaw'].forEach(function (name) {
  Zlib[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
});

const _deflate = Zlib.deflate;
const _gzip = Zlib.gzip;

Zlib.deflate = function deflate(stringOrBuffer, callback) {
  return _deflate(Buffer(stringOrBuffer), callback);
};
Zlib.gzip = function gzip(stringOrBuffer, callback) {
  return _gzip(Buffer(stringOrBuffer), callback);
};
},{"./zlib":33,"__browserify_Buffer":48}],33:[function(require,module,exports){
var process=require("__browserify_process"),Buffer=require("__browserify_Buffer").Buffer;/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function() {'use strict';function m(c){throw c;}var r=void 0,u=!0;var B="undefined"!==typeof Uint8Array&&"undefined"!==typeof Uint16Array&&"undefined"!==typeof Uint32Array;function aa(c){if("string"===typeof c){var a=c.split(""),b,e;b=0;for(e=a.length;b<e;b++)a[b]=(a[b].charCodeAt(0)&255)>>>0;c=a}for(var f=1,d=0,g=c.length,h,j=0;0<g;){h=1024<g?1024:g;g-=h;do f+=c[j++],d+=f;while(--h);f%=65521;d%=65521}return(d<<16|f)>>>0};function I(c,a){this.index="number"===typeof a?a:0;this.n=0;this.buffer=c instanceof(B?Uint8Array:Array)?c:new (B?Uint8Array:Array)(32768);2*this.buffer.length<=this.index&&m(Error("invalid index"));this.buffer.length<=this.index&&this.f()}I.prototype.f=function(){var c=this.buffer,a,b=c.length,e=new (B?Uint8Array:Array)(b<<1);if(B)e.set(c);else for(a=0;a<b;++a)e[a]=c[a];return this.buffer=e};
I.prototype.d=function(c,a,b){var e=this.buffer,f=this.index,d=this.n,g=e[f],h;b&&1<a&&(c=8<a?(K[c&255]<<24|K[c>>>8&255]<<16|K[c>>>16&255]<<8|K[c>>>24&255])>>32-a:K[c]>>8-a);if(8>a+d)g=g<<a|c,d+=a;else for(h=0;h<a;++h)g=g<<1|c>>a-h-1&1,8===++d&&(d=0,e[f++]=K[g],g=0,f===e.length&&(e=this.f()));e[f]=g;this.buffer=e;this.n=d;this.index=f};I.prototype.finish=function(){var c=this.buffer,a=this.index,b;0<this.n&&(c[a]<<=8-this.n,c[a]=K[c[a]],a++);B?b=c.subarray(0,a):(c.length=a,b=c);return b};
var ba=new (B?Uint8Array:Array)(256),Q;for(Q=0;256>Q;++Q){for(var R=Q,ga=R,ha=7,R=R>>>1;R;R>>>=1)ga<<=1,ga|=R&1,--ha;ba[Q]=(ga<<ha&255)>>>0}var K=ba;var S={k:function(c,a,b){return S.update(c,0,a,b)},update:function(c,a,b,e){for(var f=S.L,d="number"===typeof b?b:b=0,g="number"===typeof e?e:c.length,a=a^4294967295,d=g&7;d--;++b)a=a>>>8^f[(a^c[b])&255];for(d=g>>3;d--;b+=8)a=a>>>8^f[(a^c[b])&255],a=a>>>8^f[(a^c[b+1])&255],a=a>>>8^f[(a^c[b+2])&255],a=a>>>8^f[(a^c[b+3])&255],a=a>>>8^f[(a^c[b+4])&255],a=a>>>8^f[(a^c[b+5])&255],a=a>>>8^f[(a^c[b+6])&255],a=a>>>8^f[(a^c[b+7])&255];return(a^4294967295)>>>0}},ia=S,ja,ka=[0,1996959894,3993919788,2567524794,
124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,
3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,
2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,
2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,
2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918E3,2847714899,3736837829,1202900863,
817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];ja=B?new Uint32Array(ka):ka;ia.L=ja;function na(){};function oa(c){this.buffer=new (B?Uint16Array:Array)(2*c);this.length=0}oa.prototype.getParent=function(c){return 2*((c-2)/4|0)};oa.prototype.push=function(c,a){var b,e,f=this.buffer,d;b=this.length;f[this.length++]=a;for(f[this.length++]=c;0<b;)if(e=this.getParent(b),f[b]>f[e])d=f[b],f[b]=f[e],f[e]=d,d=f[b+1],f[b+1]=f[e+1],f[e+1]=d,b=e;else break;return this.length};
oa.prototype.pop=function(){var c,a,b=this.buffer,e,f,d;a=b[0];c=b[1];this.length-=2;b[0]=b[this.length];b[1]=b[this.length+1];for(d=0;;){f=2*d+2;if(f>=this.length)break;f+2<this.length&&b[f+2]>b[f]&&(f+=2);if(b[f]>b[d])e=b[d],b[d]=b[f],b[f]=e,e=b[d+1],b[d+1]=b[f+1],b[f+1]=e;else break;d=f}return{index:c,value:a,length:this.length}};function T(c){var a=c.length,b=0,e=Number.POSITIVE_INFINITY,f,d,g,h,j,i,q,l,k;for(l=0;l<a;++l)c[l]>b&&(b=c[l]),c[l]<e&&(e=c[l]);f=1<<b;d=new (B?Uint32Array:Array)(f);g=1;h=0;for(j=2;g<=b;){for(l=0;l<a;++l)if(c[l]===g){i=0;q=h;for(k=0;k<g;++k)i=i<<1|q&1,q>>=1;for(k=i;k<f;k+=j)d[k]=g<<16|l;++h}++g;h<<=1;j<<=1}return[d,b,e]};function pa(c,a){this.l=qa;this.F=0;this.input=c;this.b=0;a&&(a.lazy&&(this.F=a.lazy),"number"===typeof a.compressionType&&(this.l=a.compressionType),a.outputBuffer&&(this.a=B&&a.outputBuffer instanceof Array?new Uint8Array(a.outputBuffer):a.outputBuffer),"number"===typeof a.outputIndex&&(this.b=a.outputIndex));this.a||(this.a=new (B?Uint8Array:Array)(32768))}var qa=2,ra={NONE:0,K:1,u:qa,W:3},sa=[],U;
for(U=0;288>U;U++)switch(u){case 143>=U:sa.push([U+48,8]);break;case 255>=U:sa.push([U-144+400,9]);break;case 279>=U:sa.push([U-256+0,7]);break;case 287>=U:sa.push([U-280+192,8]);break;default:m("invalid literal: "+U)}
pa.prototype.h=function(){var c,a,b,e,f=this.input;switch(this.l){case 0:b=0;for(e=f.length;b<e;){a=B?f.subarray(b,b+65535):f.slice(b,b+65535);b+=a.length;var d=a,g=b===e,h=r,j=r,i=r,q=r,l=r,k=this.a,p=this.b;if(B){for(k=new Uint8Array(this.a.buffer);k.length<=p+d.length+5;)k=new Uint8Array(k.length<<1);k.set(this.a)}h=g?1:0;k[p++]=h|0;j=d.length;i=~j+65536&65535;k[p++]=j&255;k[p++]=j>>>8&255;k[p++]=i&255;k[p++]=i>>>8&255;if(B)k.set(d,p),p+=d.length,k=k.subarray(0,p);else{q=0;for(l=d.length;q<l;++q)k[p++]=
d[q];k.length=p}this.b=p;this.a=k}break;case 1:var t=new I(new Uint8Array(this.a.buffer),this.b);t.d(1,1,u);t.d(1,2,u);var v=ta(this,f),x,F,w;x=0;for(F=v.length;x<F;x++)if(w=v[x],I.prototype.d.apply(t,sa[w]),256<w)t.d(v[++x],v[++x],u),t.d(v[++x],5),t.d(v[++x],v[++x],u);else if(256===w)break;this.a=t.finish();this.b=this.a.length;break;case qa:var A=new I(new Uint8Array(this.a),this.b),C,n,s,E,D,ca=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],V,La,da,Ma,la,va=Array(19),Na,Z,ma,G,Oa;C=qa;A.d(1,
1,u);A.d(C,2,u);n=ta(this,f);V=ua(this.T,15);La=wa(V);da=ua(this.S,7);Ma=wa(da);for(s=286;257<s&&0===V[s-1];s--);for(E=30;1<E&&0===da[E-1];E--);var Pa=s,Qa=E,M=new (B?Uint32Array:Array)(Pa+Qa),y,N,z,ea,L=new (B?Uint32Array:Array)(316),J,H,O=new (B?Uint8Array:Array)(19);for(y=N=0;y<Pa;y++)M[N++]=V[y];for(y=0;y<Qa;y++)M[N++]=da[y];if(!B){y=0;for(ea=O.length;y<ea;++y)O[y]=0}y=J=0;for(ea=M.length;y<ea;y+=N){for(N=1;y+N<ea&&M[y+N]===M[y];++N);z=N;if(0===M[y])if(3>z)for(;0<z--;)L[J++]=0,O[0]++;else for(;0<
z;)H=138>z?z:138,H>z-3&&H<z&&(H=z-3),10>=H?(L[J++]=17,L[J++]=H-3,O[17]++):(L[J++]=18,L[J++]=H-11,O[18]++),z-=H;else if(L[J++]=M[y],O[M[y]]++,z--,3>z)for(;0<z--;)L[J++]=M[y],O[M[y]]++;else for(;0<z;)H=6>z?z:6,H>z-3&&H<z&&(H=z-3),L[J++]=16,L[J++]=H-3,O[16]++,z-=H}c=B?L.subarray(0,J):L.slice(0,J);la=ua(O,7);for(G=0;19>G;G++)va[G]=la[ca[G]];for(D=19;4<D&&0===va[D-1];D--);Na=wa(la);A.d(s-257,5,u);A.d(E-1,5,u);A.d(D-4,4,u);for(G=0;G<D;G++)A.d(va[G],3,u);G=0;for(Oa=c.length;G<Oa;G++)if(Z=c[G],A.d(Na[Z],
la[Z],u),16<=Z){G++;switch(Z){case 16:ma=2;break;case 17:ma=3;break;case 18:ma=7;break;default:m("invalid code: "+Z)}A.d(c[G],ma,u)}var Ra=[La,V],Sa=[Ma,da],P,Ta,fa,ya,Ua,Va,Wa,Xa;Ua=Ra[0];Va=Ra[1];Wa=Sa[0];Xa=Sa[1];P=0;for(Ta=n.length;P<Ta;++P)if(fa=n[P],A.d(Ua[fa],Va[fa],u),256<fa)A.d(n[++P],n[++P],u),ya=n[++P],A.d(Wa[ya],Xa[ya],u),A.d(n[++P],n[++P],u);else if(256===fa)break;this.a=A.finish();this.b=this.a.length;break;default:m("invalid compression type")}return this.a};
function xa(c,a){this.length=c;this.N=a}
function za(){var c=Aa;switch(u){case 3===c:return[257,c-3,0];case 4===c:return[258,c-4,0];case 5===c:return[259,c-5,0];case 6===c:return[260,c-6,0];case 7===c:return[261,c-7,0];case 8===c:return[262,c-8,0];case 9===c:return[263,c-9,0];case 10===c:return[264,c-10,0];case 12>=c:return[265,c-11,1];case 14>=c:return[266,c-13,1];case 16>=c:return[267,c-15,1];case 18>=c:return[268,c-17,1];case 22>=c:return[269,c-19,2];case 26>=c:return[270,c-23,2];case 30>=c:return[271,c-27,2];case 34>=c:return[272,c-
31,2];case 42>=c:return[273,c-35,3];case 50>=c:return[274,c-43,3];case 58>=c:return[275,c-51,3];case 66>=c:return[276,c-59,3];case 82>=c:return[277,c-67,4];case 98>=c:return[278,c-83,4];case 114>=c:return[279,c-99,4];case 130>=c:return[280,c-115,4];case 162>=c:return[281,c-131,5];case 194>=c:return[282,c-163,5];case 226>=c:return[283,c-195,5];case 257>=c:return[284,c-227,5];case 258===c:return[285,c-258,0];default:m("invalid length: "+c)}}var Ba=[],Aa,Ca;
for(Aa=3;258>=Aa;Aa++)Ca=za(),Ba[Aa]=Ca[2]<<24|Ca[1]<<16|Ca[0];var Da=B?new Uint32Array(Ba):Ba;
function ta(c,a){function b(a,c){var b=a.N,d=[],e=0,f;f=Da[a.length];d[e++]=f&65535;d[e++]=f>>16&255;d[e++]=f>>24;var g;switch(u){case 1===b:g=[0,b-1,0];break;case 2===b:g=[1,b-2,0];break;case 3===b:g=[2,b-3,0];break;case 4===b:g=[3,b-4,0];break;case 6>=b:g=[4,b-5,1];break;case 8>=b:g=[5,b-7,1];break;case 12>=b:g=[6,b-9,2];break;case 16>=b:g=[7,b-13,2];break;case 24>=b:g=[8,b-17,3];break;case 32>=b:g=[9,b-25,3];break;case 48>=b:g=[10,b-33,4];break;case 64>=b:g=[11,b-49,4];break;case 96>=b:g=[12,b-
65,5];break;case 128>=b:g=[13,b-97,5];break;case 192>=b:g=[14,b-129,6];break;case 256>=b:g=[15,b-193,6];break;case 384>=b:g=[16,b-257,7];break;case 512>=b:g=[17,b-385,7];break;case 768>=b:g=[18,b-513,8];break;case 1024>=b:g=[19,b-769,8];break;case 1536>=b:g=[20,b-1025,9];break;case 2048>=b:g=[21,b-1537,9];break;case 3072>=b:g=[22,b-2049,10];break;case 4096>=b:g=[23,b-3073,10];break;case 6144>=b:g=[24,b-4097,11];break;case 8192>=b:g=[25,b-6145,11];break;case 12288>=b:g=[26,b-8193,12];break;case 16384>=
b:g=[27,b-12289,12];break;case 24576>=b:g=[28,b-16385,13];break;case 32768>=b:g=[29,b-24577,13];break;default:m("invalid distance")}f=g;d[e++]=f[0];d[e++]=f[1];d[e++]=f[2];var h,i;h=0;for(i=d.length;h<i;++h)k[p++]=d[h];v[d[0]]++;x[d[3]]++;t=a.length+c-1;l=null}var e,f,d,g,h,j={},i,q,l,k=B?new Uint16Array(2*a.length):[],p=0,t=0,v=new (B?Uint32Array:Array)(286),x=new (B?Uint32Array:Array)(30),F=c.F,w;if(!B){for(d=0;285>=d;)v[d++]=0;for(d=0;29>=d;)x[d++]=0}v[256]=1;e=0;for(f=a.length;e<f;++e){d=h=0;
for(g=3;d<g&&e+d!==f;++d)h=h<<8|a[e+d];j[h]===r&&(j[h]=[]);i=j[h];if(!(0<t--)){for(;0<i.length&&32768<e-i[0];)i.shift();if(e+3>=f){l&&b(l,-1);d=0;for(g=f-e;d<g;++d)w=a[e+d],k[p++]=w,++v[w];break}if(0<i.length){var A=r,C=r,n=0,s=r,E=r,D=r,ca=r,V=a.length,E=0,ca=i.length;a:for(;E<ca;E++){A=i[ca-E-1];s=3;if(3<n){for(D=n;3<D;D--)if(a[A+D-1]!==a[e+D-1])continue a;s=n}for(;258>s&&e+s<V&&a[A+s]===a[e+s];)++s;s>n&&(C=A,n=s);if(258===s)break}q=new xa(n,e-C);l?l.length<q.length?(w=a[e-1],k[p++]=w,++v[w],b(q,
0)):b(l,-1):q.length<F?l=q:b(q,0)}else l?b(l,-1):(w=a[e],k[p++]=w,++v[w])}i.push(e)}k[p++]=256;v[256]++;c.T=v;c.S=x;return B?k.subarray(0,p):k}
function ua(c,a){function b(a){var c=x[a][F[a]];c===l?(b(a+1),b(a+1)):--t[c];++F[a]}var e=c.length,f=new oa(572),d=new (B?Uint8Array:Array)(e),g,h,j,i,q;if(!B)for(i=0;i<e;i++)d[i]=0;for(i=0;i<e;++i)0<c[i]&&f.push(i,c[i]);g=Array(f.length/2);h=new (B?Uint32Array:Array)(f.length/2);if(1===g.length)return d[f.pop().index]=1,d;i=0;for(q=f.length/2;i<q;++i)g[i]=f.pop(),h[i]=g[i].value;var l=h.length,k=new (B?Uint16Array:Array)(a),p=new (B?Uint8Array:Array)(a),t=new (B?Uint8Array:Array)(l),v=Array(a),x=
Array(a),F=Array(a),w=(1<<a)-l,A=1<<a-1,C,n,s,E,D;k[a-1]=l;for(n=0;n<a;++n)w<A?p[n]=0:(p[n]=1,w-=A),w<<=1,k[a-2-n]=(k[a-1-n]/2|0)+l;k[0]=p[0];v[0]=Array(k[0]);x[0]=Array(k[0]);for(n=1;n<a;++n)k[n]>2*k[n-1]+p[n]&&(k[n]=2*k[n-1]+p[n]),v[n]=Array(k[n]),x[n]=Array(k[n]);for(C=0;C<l;++C)t[C]=a;for(s=0;s<k[a-1];++s)v[a-1][s]=h[s],x[a-1][s]=s;for(C=0;C<a;++C)F[C]=0;1===p[a-1]&&(--t[0],++F[a-1]);for(n=a-2;0<=n;--n){E=C=0;D=F[n+1];for(s=0;s<k[n];s++)E=v[n+1][D]+v[n+1][D+1],E>h[C]?(v[n][s]=E,x[n][s]=l,D+=2):
(v[n][s]=h[C],x[n][s]=C,++C);F[n]=0;1===p[n]&&b(n)}j=t;i=0;for(q=g.length;i<q;++i)d[g[i].index]=j[i];return d}function wa(c){var a=new (B?Uint16Array:Array)(c.length),b=[],e=[],f=0,d,g,h,j;d=0;for(g=c.length;d<g;d++)b[c[d]]=(b[c[d]]|0)+1;d=1;for(g=16;d<=g;d++)e[d]=f,f+=b[d]|0,f<<=1;d=0;for(g=c.length;d<g;d++){f=e[c[d]];e[c[d]]+=1;h=a[d]=0;for(j=c[d];h<j;h++)a[d]=a[d]<<1|f&1,f>>>=1}return a};function Ea(c,a){this.input=c;this.a=new (B?Uint8Array:Array)(32768);this.l=Fa.u;var b={},e;if((a||!(a={}))&&"number"===typeof a.compressionType)this.l=a.compressionType;for(e in a)b[e]=a[e];b.outputBuffer=this.a;this.H=new pa(this.input,b)}var Fa=ra;
Ea.prototype.h=function(){var c,a,b,e,f,d,g,h=0;g=this.a;c=Ga;switch(c){case Ga:a=Math.LOG2E*Math.log(32768)-8;break;default:m(Error("invalid compression method"))}b=a<<4|c;g[h++]=b;switch(c){case Ga:switch(this.l){case Fa.NONE:f=0;break;case Fa.K:f=1;break;case Fa.u:f=2;break;default:m(Error("unsupported compression type"))}break;default:m(Error("invalid compression method"))}e=f<<6|0;g[h++]=e|31-(256*b+e)%31;d=aa(this.input);this.H.b=h;g=this.H.h();h=g.length;B&&(g=new Uint8Array(g.buffer),g.length<=
h+4&&(this.a=new Uint8Array(g.length+4),this.a.set(g),g=this.a),g=g.subarray(0,h+4));g[h++]=d>>24&255;g[h++]=d>>16&255;g[h++]=d>>8&255;g[h++]=d&255;return g};function Ha(c,a){this.input=c;this.b=this.c=0;this.g={};a&&(a.flags&&(this.g=a.flags),"string"===typeof a.filename&&(this.filename=a.filename),"string"===typeof a.comment&&(this.comment=a.comment),a.deflateOptions&&(this.m=a.deflateOptions));this.m||(this.m={})}
Ha.prototype.h=function(){var c,a,b,e,f,d,g,h,j=new (B?Uint8Array:Array)(32768),i=0,q=this.input,l=this.c,k=this.filename,p=this.comment;j[i++]=31;j[i++]=139;j[i++]=8;c=0;this.g.fname&&(c|=Ia);this.g.fcomment&&(c|=Ja);this.g.fhcrc&&(c|=Ka);j[i++]=c;a=(Date.now?Date.now():+new Date)/1E3|0;j[i++]=a&255;j[i++]=a>>>8&255;j[i++]=a>>>16&255;j[i++]=a>>>24&255;j[i++]=0;j[i++]=Ya;if(this.g.fname!==r){g=0;for(h=k.length;g<h;++g)d=k.charCodeAt(g),255<d&&(j[i++]=d>>>8&255),j[i++]=d&255;j[i++]=0}if(this.g.comment){g=
0;for(h=p.length;g<h;++g)d=p.charCodeAt(g),255<d&&(j[i++]=d>>>8&255),j[i++]=d&255;j[i++]=0}this.g.fhcrc&&(b=S.k(j,0,i)&65535,j[i++]=b&255,j[i++]=b>>>8&255);this.m.outputBuffer=j;this.m.outputIndex=i;f=new pa(q,this.m);j=f.h();i=f.b;B&&(i+8>j.buffer.byteLength?(this.a=new Uint8Array(i+8),this.a.set(new Uint8Array(j.buffer)),j=this.a):j=new Uint8Array(j.buffer));e=S.k(q);j[i++]=e&255;j[i++]=e>>>8&255;j[i++]=e>>>16&255;j[i++]=e>>>24&255;h=q.length;j[i++]=h&255;j[i++]=h>>>8&255;j[i++]=h>>>16&255;j[i++]=
h>>>24&255;this.c=l;B&&i<j.length&&(this.a=j=j.subarray(0,i));return j};var Ya=255,Ka=2,Ia=8,Ja=16;function W(c,a){this.p=[];this.q=32768;this.e=this.j=this.c=this.t=0;this.input=B?new Uint8Array(c):c;this.v=!1;this.r=Za;this.J=!1;if(a||!(a={}))a.index&&(this.c=a.index),a.bufferSize&&(this.q=a.bufferSize),a.bufferType&&(this.r=a.bufferType),a.resize&&(this.J=a.resize);switch(this.r){case $a:this.b=32768;this.a=new (B?Uint8Array:Array)(32768+this.q+258);break;case Za:this.b=0;this.a=new (B?Uint8Array:Array)(this.q);this.f=this.R;this.z=this.O;this.s=this.Q;break;default:m(Error("invalid inflate mode"))}}
var $a=0,Za=1;
W.prototype.i=function(){for(;!this.v;){var c=X(this,3);c&1&&(this.v=u);c>>>=1;switch(c){case 0:var a=this.input,b=this.c,e=this.a,f=this.b,d=r,g=r,h=r,j=e.length,i=r;this.e=this.j=0;d=a[b++];d===r&&m(Error("invalid uncompressed block header: LEN (first byte)"));g=d;d=a[b++];d===r&&m(Error("invalid uncompressed block header: LEN (second byte)"));g|=d<<8;d=a[b++];d===r&&m(Error("invalid uncompressed block header: NLEN (first byte)"));h=d;d=a[b++];d===r&&m(Error("invalid uncompressed block header: NLEN (second byte)"));h|=
d<<8;g===~h&&m(Error("invalid uncompressed block header: length verify"));b+g>a.length&&m(Error("input buffer is broken"));switch(this.r){case $a:for(;f+g>e.length;){i=j-f;g-=i;if(B)e.set(a.subarray(b,b+i),f),f+=i,b+=i;else for(;i--;)e[f++]=a[b++];this.b=f;e=this.f();f=this.b}break;case Za:for(;f+g>e.length;)e=this.f({B:2});break;default:m(Error("invalid inflate mode"))}if(B)e.set(a.subarray(b,b+g),f),f+=g,b+=g;else for(;g--;)e[f++]=a[b++];this.c=b;this.b=f;this.a=e;break;case 1:this.s(ab,bb);break;
case 2:cb(this);break;default:m(Error("unknown BTYPE: "+c))}}return this.z()};
var db=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],eb=B?new Uint16Array(db):db,fb=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],gb=B?new Uint16Array(fb):fb,hb=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],ib=B?new Uint8Array(hb):hb,jb=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],kb=B?new Uint16Array(jb):jb,lb=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,
10,11,11,12,12,13,13],mb=B?new Uint8Array(lb):lb,nb=new (B?Uint8Array:Array)(288),Y,ob;Y=0;for(ob=nb.length;Y<ob;++Y)nb[Y]=143>=Y?8:255>=Y?9:279>=Y?7:8;var ab=T(nb),pb=new (B?Uint8Array:Array)(30),qb,rb;qb=0;for(rb=pb.length;qb<rb;++qb)pb[qb]=5;var bb=T(pb);function X(c,a){for(var b=c.j,e=c.e,f=c.input,d=c.c,g;e<a;)g=f[d++],g===r&&m(Error("input buffer is broken")),b|=g<<e,e+=8;g=b&(1<<a)-1;c.j=b>>>a;c.e=e-a;c.c=d;return g}
function sb(c,a){for(var b=c.j,e=c.e,f=c.input,d=c.c,g=a[0],h=a[1],j,i,q;e<h;)j=f[d++],j===r&&m(Error("input buffer is broken")),b|=j<<e,e+=8;i=g[b&(1<<h)-1];q=i>>>16;c.j=b>>q;c.e=e-q;c.c=d;return i&65535}
function cb(c){function a(a,b,c){var d,f,e,g;for(g=0;g<a;)switch(d=sb(this,b),d){case 16:for(e=3+X(this,2);e--;)c[g++]=f;break;case 17:for(e=3+X(this,3);e--;)c[g++]=0;f=0;break;case 18:for(e=11+X(this,7);e--;)c[g++]=0;f=0;break;default:f=c[g++]=d}return c}var b=X(c,5)+257,e=X(c,5)+1,f=X(c,4)+4,d=new (B?Uint8Array:Array)(eb.length),g,h,j,i;for(i=0;i<f;++i)d[eb[i]]=X(c,3);g=T(d);h=new (B?Uint8Array:Array)(b);j=new (B?Uint8Array:Array)(e);c.s(T(a.call(c,b,g,h)),T(a.call(c,e,g,j)))}
W.prototype.s=function(c,a){var b=this.a,e=this.b;this.A=c;for(var f=b.length-258,d,g,h,j;256!==(d=sb(this,c));)if(256>d)e>=f&&(this.b=e,b=this.f(),e=this.b),b[e++]=d;else{g=d-257;j=gb[g];0<ib[g]&&(j+=X(this,ib[g]));d=sb(this,a);h=kb[d];0<mb[d]&&(h+=X(this,mb[d]));e>=f&&(this.b=e,b=this.f(),e=this.b);for(;j--;)b[e]=b[e++-h]}for(;8<=this.e;)this.e-=8,this.c--;this.b=e};
W.prototype.Q=function(c,a){var b=this.a,e=this.b;this.A=c;for(var f=b.length,d,g,h,j;256!==(d=sb(this,c));)if(256>d)e>=f&&(b=this.f(),f=b.length),b[e++]=d;else{g=d-257;j=gb[g];0<ib[g]&&(j+=X(this,ib[g]));d=sb(this,a);h=kb[d];0<mb[d]&&(h+=X(this,mb[d]));e+j>f&&(b=this.f(),f=b.length);for(;j--;)b[e]=b[e++-h]}for(;8<=this.e;)this.e-=8,this.c--;this.b=e};
W.prototype.f=function(){var c=new (B?Uint8Array:Array)(this.b-32768),a=this.b-32768,b,e,f=this.a;if(B)c.set(f.subarray(32768,c.length));else{b=0;for(e=c.length;b<e;++b)c[b]=f[b+32768]}this.p.push(c);this.t+=c.length;if(B)f.set(f.subarray(a,a+32768));else for(b=0;32768>b;++b)f[b]=f[a+b];this.b=32768;return f};
W.prototype.R=function(c){var a,b=this.input.length/this.c+1|0,e,f,d,g=this.input,h=this.a;c&&("number"===typeof c.B&&(b=c.B),"number"===typeof c.M&&(b+=c.M));2>b?(e=(g.length-this.c)/this.A[2],d=258*(e/2)|0,f=d<h.length?h.length+d:h.length<<1):f=h.length*b;B?(a=new Uint8Array(f),a.set(h)):a=h;return this.a=a};
W.prototype.z=function(){var c=0,a=this.a,b=this.p,e,f=new (B?Uint8Array:Array)(this.t+(this.b-32768)),d,g,h,j;if(0===b.length)return B?this.a.subarray(32768,this.b):this.a.slice(32768,this.b);d=0;for(g=b.length;d<g;++d){e=b[d];h=0;for(j=e.length;h<j;++h)f[c++]=e[h]}d=32768;for(g=this.b;d<g;++d)f[c++]=a[d];this.p=[];return this.buffer=f};
W.prototype.O=function(){var c,a=this.b;B?this.J?(c=new Uint8Array(a),c.set(this.a.subarray(0,a))):c=this.a.subarray(0,a):(this.a.length>a&&(this.a.length=a),c=this.a);return this.buffer=c};function tb(c){this.input=c;this.c=0;this.member=[]}
tb.prototype.i=function(){for(var c=this.input.length;this.c<c;){var a=new na,b=r,e=r,f=r,d=r,g=r,h=r,j=r,i=r,q=r,l=this.input,k=this.c;a.C=l[k++];a.D=l[k++];(31!==a.C||139!==a.D)&&m(Error("invalid file signature:",a.C,a.D));a.w=l[k++];switch(a.w){case 8:break;default:m(Error("unknown compression method: "+a.w))}a.o=l[k++];i=l[k++]|l[k++]<<8|l[k++]<<16|l[k++]<<24;a.Z=new Date(1E3*i);a.aa=l[k++];a.$=l[k++];0<(a.o&4)&&(a.V=l[k++]|l[k++]<<8,k+=a.V);if(0<(a.o&Ia)){j=[];for(h=0;0<(g=l[k++]);)j[h++]=String.fromCharCode(g);
a.name=j.join("")}if(0<(a.o&Ja)){j=[];for(h=0;0<(g=l[k++]);)j[h++]=String.fromCharCode(g);a.comment=j.join("")}0<(a.o&Ka)&&(a.P=S.k(l,0,k)&65535,a.P!==(l[k++]|l[k++]<<8)&&m(Error("invalid header crc16")));b=l[l.length-4]|l[l.length-3]<<8|l[l.length-2]<<16|l[l.length-1]<<24;l.length-k-4-4<512*b&&(d=b);e=new W(l,{index:k,bufferSize:d});a.data=f=e.i();k=e.c;a.X=q=(l[k++]|l[k++]<<8|l[k++]<<16|l[k++]<<24)>>>0;S.k(f)!==q&&m(Error("invalid CRC-32 checksum: 0x"+S.k(f).toString(16)+" / 0x"+q.toString(16)));
a.Y=b=(l[k++]|l[k++]<<8|l[k++]<<16|l[k++]<<24)>>>0;(f.length&4294967295)!==b&&m(Error("invalid input size: "+(f.length&4294967295)+" / "+b));this.member.push(a);this.c=k}var p=this.member,t,v,x=0,F=0,w;t=0;for(v=p.length;t<v;++t)F+=p[t].data.length;if(B){w=new Uint8Array(F);for(t=0;t<v;++t)w.set(p[t].data,x),x+=p[t].data.length}else{w=[];for(t=0;t<v;++t)w[t]=p[t].data;w=Array.prototype.concat.apply([],w)}return w};function ub(c,a){var b,e;this.input=c;this.c=0;if(a||!(a={}))a.index&&(this.c=a.index),a.verify&&(this.U=a.verify);b=c[this.c++];e=c[this.c++];switch(b&15){case Ga:this.method=Ga;break;default:m(Error("unsupported compression method"))}0!==((b<<8)+e)%31&&m(Error("invalid fcheck flag:"+((b<<8)+e)%31));e&32&&m(Error("fdict flag is not supported"));this.I=new W(c,{index:this.c,bufferSize:a.bufferSize,bufferType:a.bufferType,resize:a.resize})}
ub.prototype.i=function(){var c=this.input,a,b;a=this.I.i();this.c=this.I.c;this.U&&(b=(c[this.c++]<<24|c[this.c++]<<16|c[this.c++]<<8|c[this.c++])>>>0,b!==aa(a)&&m(Error("invalid adler-32 checksum")));return a};exports.deflate=vb;exports.deflateSync=wb;exports.inflate=xb;exports.inflateSync=yb;exports.gzip=zb;exports.gzipSync=Ab;exports.gunzip=Bb;exports.gunzipSync=Cb;function vb(c,a,b){process.nextTick(function(){var e,f;try{f=wb(c,b)}catch(d){e=d}a(e,f)})}function wb(c,a){var b;b=(new Ea(c)).h();a||(a={});return a.G?b:Db(b)}function xb(c,a,b){process.nextTick(function(){var e,f;try{f=yb(c,b)}catch(d){e=d}a(e,f)})}
function yb(c,a){var b;c.subarray=c.slice;b=(new ub(c)).i();a||(a={});return a.noBuffer?b:Db(b)}function zb(c,a,b){process.nextTick(function(){var e,f;try{f=Ab(c,b)}catch(d){e=d}a(e,f)})}function Ab(c,a){var b;c.subarray=c.slice;b=(new Ha(c)).h();a||(a={});return a.G?b:Db(b)}function Bb(c,a,b){process.nextTick(function(){var e,f;try{f=Cb(c,b)}catch(d){e=d}a(e,f)})}function Cb(c,a){var b;c.subarray=c.slice;b=(new tb(c)).i();a||(a={});return a.G?b:Db(b)}
function Db(c){var a=new Buffer(c.length),b,e;b=0;for(e=c.length;b<e;++b)a[b]=c[b];return a};var Eb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];B&&new Uint16Array(Eb);var Fb=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258];B&&new Uint16Array(Fb);var Gb=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0];B&&new Uint8Array(Gb);var Hb=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577];B&&new Uint16Array(Hb);
var Ib=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];B&&new Uint8Array(Ib);var Jb=new (B?Uint8Array:Array)(288),$,Kb;$=0;for(Kb=Jb.length;$<Kb;++$)Jb[$]=143>=$?8:255>=$?9:279>=$?7:8;T(Jb);var Lb=new (B?Uint8Array:Array)(30),Mb,Nb;Mb=0;for(Nb=Lb.length;Mb<Nb;++Mb)Lb[Mb]=5;T(Lb);var Ga=8;}).call(this);

},{"__browserify_Buffer":48,"__browserify_process":49}],34:[function(require,module,exports){
var stream = require('stream')
var bops = require('bops')
var util = require('util')

function ConcatStream(cb) {
  stream.Stream.call(this)
  this.writable = true
  if (cb) this.cb = cb
  this.body = []
  this.on('error', function(err) {
    // no-op
  })
}

util.inherits(ConcatStream, stream.Stream)

ConcatStream.prototype.write = function(chunk) {
  this.body.push(chunk)
}

ConcatStream.prototype.destroy = function() {}

ConcatStream.prototype.arrayConcat = function(arrs) {
  if (arrs.length === 0) return []
  if (arrs.length === 1) return arrs[0]
  return arrs.reduce(function (a, b) { return a.concat(b) })
}

ConcatStream.prototype.isArray = function(arr) {
  return Array.isArray(arr)
}

ConcatStream.prototype.getBody = function () {
  if (this.body.length === 0) return
  if (typeof(this.body[0]) === "string") return this.body.join('')
  if (this.isArray(this.body[0])) return this.arrayConcat(this.body)
  if (bops.is(this.body[0])) return bops.join(this.body)
  return this.body
}

ConcatStream.prototype.end = function() {
  if (this.cb) this.cb(this.getBody())
}

module.exports = function(cb) {
  return new ConcatStream(cb)
}

module.exports.ConcatStream = ConcatStream

},{"bops":35,"stream":20,"util":24}],35:[function(require,module,exports){
var proto = {}
module.exports = proto

proto.from = require('./from.js')
proto.to = require('./to.js')
proto.is = require('./is.js')
proto.subarray = require('./subarray.js')
proto.join = require('./join.js')
proto.copy = require('./copy.js')
proto.create = require('./create.js')

mix(require('./read.js'), proto)
mix(require('./write.js'), proto)

function mix(from, into) {
  for(var key in from) {
    into[key] = from[key]
  }
}

},{"./copy.js":38,"./create.js":39,"./from.js":40,"./is.js":41,"./join.js":42,"./read.js":44,"./subarray.js":45,"./to.js":46,"./write.js":47}],36:[function(require,module,exports){
module.exports=require(27)
},{}],37:[function(require,module,exports){
module.exports = to_utf8

var out = []
  , col = []
  , fcc = String.fromCharCode
  , mask = [0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01]
  , unmask = [
      0x00
    , 0x01
    , 0x02 | 0x01
    , 0x04 | 0x02 | 0x01
    , 0x08 | 0x04 | 0x02 | 0x01
    , 0x10 | 0x08 | 0x04 | 0x02 | 0x01
    , 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01
    , 0x40 | 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01
  ]

function to_utf8(bytes, start, end) {
  start = start === undefined ? 0 : start
  end = end === undefined ? bytes.length : end

  var idx = 0
    , hi = 0x80
    , collecting = 0
    , pos
    , by

  col.length =
  out.length = 0

  while(idx < bytes.length) {
    by = bytes[idx]
    if(!collecting && by & hi) {
      pos = find_pad_position(by)
      collecting += pos
      if(pos < 8) {
        col[col.length] = by & unmask[6 - pos]
      }
    } else if(collecting) {
      col[col.length] = by & unmask[6]
      --collecting
      if(!collecting && col.length) {
        out[out.length] = fcc(reduced(col, pos))
        col.length = 0
      }
    } else { 
      out[out.length] = fcc(by)
    }
    ++idx
  }
  if(col.length && !collecting) {
    out[out.length] = fcc(reduced(col, pos))
    col.length = 0
  }
  return out.join('')
}

function find_pad_position(byt) {
  for(var i = 0; i < 7; ++i) {
    if(!(byt & mask[i])) {
      break
    }
  }
  return i
}

function reduced(list) {
  var out = 0
  for(var i = 0, len = list.length; i < len; ++i) {
    out |= list[i] << ((len - i - 1) * 6)
  }
  return out
}

},{}],38:[function(require,module,exports){
module.exports = copy

var slice = [].slice

function copy(source, target, target_start, source_start, source_end) {
  target_start = arguments.length < 3 ? 0 : target_start
  source_start = arguments.length < 4 ? 0 : source_start
  source_end = arguments.length < 5 ? source.length : source_end

  if(source_end === source_start) {
    return
  }

  if(target.length === 0 || source.length === 0) {
    return
  }

  if(source_end > source.length) {
    source_end = source.length
  }

  if(target.length - target_start < source_end - source_start) {
    source_end = target.length - target_start + start
  }

  if(source.buffer !== target.buffer) {
    return fast_copy(source, target, target_start, source_start, source_end)
  }
  return slow_copy(source, target, target_start, source_start, source_end)
}

function fast_copy(source, target, target_start, source_start, source_end) {
  var len = (source_end - source_start) + target_start

  for(var i = target_start, j = source_start;
      i < len;
      ++i,
      ++j) {
    target[i] = source[j]
  }
}

function slow_copy(from, to, j, i, jend) {
  // the buffers could overlap.
  var iend = jend + i
    , tmp = new Uint8Array(slice.call(from, i, iend))
    , x = 0

  for(; i < iend; ++i, ++x) {
    to[j++] = tmp[x]
  }
}

},{}],39:[function(require,module,exports){
module.exports = function(size) {
  return new Uint8Array(size)
}

},{}],40:[function(require,module,exports){
module.exports = from

var base64 = require('base64-js')

var decoders = {
    hex: from_hex
  , utf8: from_utf
  , base64: from_base64
}

function from(source, encoding) {
  if(Array.isArray(source)) {
    return new Uint8Array(source)
  }

  return decoders[encoding || 'utf8'](source)
}

function from_hex(str) {
  var size = str.length / 2
    , buf = new Uint8Array(size)
    , character = ''

  for(var i = 0, len = str.length; i < len; ++i) {
    character += str.charAt(i)

    if(i > 0 && (i % 2) === 1) {
      buf[i>>>1] = parseInt(character, 16)
      character = '' 
    }
  }

  return buf 
}

function from_utf(str) {
  var bytes = []
    , tmp
    , ch

  for(var i = 0, len = str.length; i < len; ++i) {
    ch = str.charCodeAt(i)
    if(ch & 0x80) {
      tmp = encodeURIComponent(str.charAt(i)).substr(1).split('%')
      for(var j = 0, jlen = tmp.length; j < jlen; ++j) {
        bytes[bytes.length] = parseInt(tmp[j], 16)
      }
    } else {
      bytes[bytes.length] = ch 
    }
  }

  return new Uint8Array(bytes)
}

function from_base64(str) {
  return new Uint8Array(base64.toByteArray(str)) 
}

},{"base64-js":36}],41:[function(require,module,exports){

module.exports = function(buffer) {
  return buffer instanceof Uint8Array;
}

},{}],42:[function(require,module,exports){
module.exports = join

function join(targets, hint) {
  if(!targets.length) {
    return new Uint8Array(0)
  }

  var len = hint !== undefined ? hint : get_length(targets)
    , out = new Uint8Array(len)
    , cur = targets[0]
    , curlen = cur.length
    , curidx = 0
    , curoff = 0
    , i = 0

  while(i < len) {
    if(curoff === curlen) {
      curoff = 0
      ++curidx
      cur = targets[curidx]
      curlen = cur && cur.length
      continue
    }
    out[i++] = cur[curoff++] 
  }

  return out
}

function get_length(targets) {
  var size = 0
  for(var i = 0, len = targets.length; i < len; ++i) {
    size += targets[i].byteLength
  }
  return size
}

},{}],43:[function(require,module,exports){
var proto
  , map

module.exports = proto = {}

map = typeof WeakMap === 'undefined' ? null : new WeakMap

proto.get = !map ? no_weakmap_get : get

function no_weakmap_get(target) {
  return new DataView(target.buffer, 0)
}

function get(target) {
  var out = map.get(target.buffer)
  if(!out) {
    map.set(target.buffer, out = new DataView(target.buffer, 0))
  }
  return out
}

},{}],44:[function(require,module,exports){
module.exports = {
    readUInt8:      read_uint8
  , readInt8:       read_int8
  , readUInt16LE:   read_uint16_le
  , readUInt32LE:   read_uint32_le
  , readInt16LE:    read_int16_le
  , readInt32LE:    read_int32_le
  , readFloatLE:    read_float_le
  , readDoubleLE:   read_double_le
  , readUInt16BE:   read_uint16_be
  , readUInt32BE:   read_uint32_be
  , readInt16BE:    read_int16_be
  , readInt32BE:    read_int32_be
  , readFloatBE:    read_float_be
  , readDoubleBE:   read_double_be
}

var map = require('./mapped.js')

function read_uint8(target, at) {
  return target[at]
}

function read_int8(target, at) {
  var v = target[at];
  return v < 0x80 ? v : v - 0x100
}

function read_uint16_le(target, at) {
  var dv = map.get(target);
  return dv.getUint16(at + target.byteOffset, true)
}

function read_uint32_le(target, at) {
  var dv = map.get(target);
  return dv.getUint32(at + target.byteOffset, true)
}

function read_int16_le(target, at) {
  var dv = map.get(target);
  return dv.getInt16(at + target.byteOffset, true)
}

function read_int32_le(target, at) {
  var dv = map.get(target);
  return dv.getInt32(at + target.byteOffset, true)
}

function read_float_le(target, at) {
  var dv = map.get(target);
  return dv.getFloat32(at + target.byteOffset, true)
}

function read_double_le(target, at) {
  var dv = map.get(target);
  return dv.getFloat64(at + target.byteOffset, true)
}

function read_uint16_be(target, at) {
  var dv = map.get(target);
  return dv.getUint16(at + target.byteOffset, false)
}

function read_uint32_be(target, at) {
  var dv = map.get(target);
  return dv.getUint32(at + target.byteOffset, false)
}

function read_int16_be(target, at) {
  var dv = map.get(target);
  return dv.getInt16(at + target.byteOffset, false)
}

function read_int32_be(target, at) {
  var dv = map.get(target);
  return dv.getInt32(at + target.byteOffset, false)
}

function read_float_be(target, at) {
  var dv = map.get(target);
  return dv.getFloat32(at + target.byteOffset, false)
}

function read_double_be(target, at) {
  var dv = map.get(target);
  return dv.getFloat64(at + target.byteOffset, false)
}

},{"./mapped.js":43}],45:[function(require,module,exports){
module.exports = subarray

function subarray(buf, from, to) {
  return buf.subarray(from || 0, to || buf.length)
}

},{}],46:[function(require,module,exports){
module.exports = to

var base64 = require('base64-js')
  , toutf8 = require('to-utf8')

var encoders = {
    hex: to_hex
  , utf8: to_utf
  , base64: to_base64
}

function to(buf, encoding) {
  return encoders[encoding || 'utf8'](buf)
}

function to_hex(buf) {
  var str = ''
    , byt

  for(var i = 0, len = buf.length; i < len; ++i) {
    byt = buf[i]
    str += ((byt & 0xF0) >>> 4).toString(16)
    str += (byt & 0x0F).toString(16)
  }

  return str
}

function to_utf(buf) {
  return toutf8(buf)
}

function to_base64(buf) {
  return base64.fromByteArray(buf)
}


},{"base64-js":36,"to-utf8":37}],47:[function(require,module,exports){
module.exports = {
    writeUInt8:      write_uint8
  , writeInt8:       write_int8
  , writeUInt16LE:   write_uint16_le
  , writeUInt32LE:   write_uint32_le
  , writeInt16LE:    write_int16_le
  , writeInt32LE:    write_int32_le
  , writeFloatLE:    write_float_le
  , writeDoubleLE:   write_double_le
  , writeUInt16BE:   write_uint16_be
  , writeUInt32BE:   write_uint32_be
  , writeInt16BE:    write_int16_be
  , writeInt32BE:    write_int32_be
  , writeFloatBE:    write_float_be
  , writeDoubleBE:   write_double_be
}

var map = require('./mapped.js')

function write_uint8(target, value, at) {
  return target[at] = value
}

function write_int8(target, value, at) {
  return target[at] = value < 0 ? value + 0x100 : value
}

function write_uint16_le(target, value, at) {
  var dv = map.get(target);
  return dv.setUint16(at + target.byteOffset, value, true)
}

function write_uint32_le(target, value, at) {
  var dv = map.get(target);
  return dv.setUint32(at + target.byteOffset, value, true)
}

function write_int16_le(target, value, at) {
  var dv = map.get(target);
  return dv.setInt16(at + target.byteOffset, value, true)
}

function write_int32_le(target, value, at) {
  var dv = map.get(target);
  return dv.setInt32(at + target.byteOffset, value, true)
}

function write_float_le(target, value, at) {
  var dv = map.get(target);
  return dv.setFloat32(at + target.byteOffset, value, true)
}

function write_double_le(target, value, at) {
  var dv = map.get(target);
  return dv.setFloat64(at + target.byteOffset, value, true)
}

function write_uint16_be(target, value, at) {
  var dv = map.get(target);
  return dv.setUint16(at + target.byteOffset, value, false)
}

function write_uint32_be(target, value, at) {
  var dv = map.get(target);
  return dv.setUint32(at + target.byteOffset, value, false)
}

function write_int16_be(target, value, at) {
  var dv = map.get(target);
  return dv.setInt16(at + target.byteOffset, value, false)
}

function write_int32_be(target, value, at) {
  var dv = map.get(target);
  return dv.setInt32(at + target.byteOffset, value, false)
}

function write_float_be(target, value, at) {
  var dv = map.get(target);
  return dv.setFloat32(at + target.byteOffset, value, false)
}

function write_double_be(target, value, at) {
  var dv = map.get(target);
  return dv.setFloat64(at + target.byteOffset, value, false)
}

},{"./mapped.js":43}],48:[function(require,module,exports){
require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],"q9TxCC":[function(require,module,exports){
var assert;
exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function Buffer(subject, encoding, offset) {
  if(!assert) assert= require('assert');
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding == "base64" && typeof subject == "string") {
    subject = stringtrim(subject);
    while (subject.length % 4 != 0) {
      subject = subject + "="; 
    }
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    // slicing works, with limitations (no parent tracking/update)
    // check https://github.com/toots/buffer-browserify/issues/19
    for (var i = 0; i < this.length; i++) {
        this[i] = subject.get(i+offset);
    }
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          this[i] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};

// slice(start, end)
function clamp(index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
}

Buffer.prototype.slice = function(start, end) {
  var len = this.length;
  start = clamp(start, len, 0);
  end = clamp(end, len, len);
  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

},{"./buffer_ieee754":1,"assert":6,"base64-js":4}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],4:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],5:[function(require,module,exports){


//
// The shims in this file are not fully implemented shims for the ES5
// features, but do work for the particular usecases there is in
// the other modules.
//

var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

// Array.isArray is supported in IE9
function isArray(xs) {
  return toString.call(xs) === '[object Array]';
}
exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

// Array.prototype.indexOf is supported in IE9
exports.indexOf = function indexOf(xs, x) {
  if (xs.indexOf) return xs.indexOf(x);
  for (var i = 0; i < xs.length; i++) {
    if (x === xs[i]) return i;
  }
  return -1;
};

// Array.prototype.filter is supported in IE9
exports.filter = function filter(xs, fn) {
  if (xs.filter) return xs.filter(fn);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (fn(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
};

// Array.prototype.forEach is supported in IE9
exports.forEach = function forEach(xs, fn, self) {
  if (xs.forEach) return xs.forEach(fn, self);
  for (var i = 0; i < xs.length; i++) {
    fn.call(self, xs[i], i, xs);
  }
};

// Array.prototype.map is supported in IE9
exports.map = function map(xs, fn) {
  if (xs.map) return xs.map(fn);
  var out = new Array(xs.length);
  for (var i = 0; i < xs.length; i++) {
    out[i] = fn(xs[i], i, xs);
  }
  return out;
};

// Array.prototype.reduce is supported in IE9
exports.reduce = function reduce(array, callback, opt_initialValue) {
  if (array.reduce) return array.reduce(callback, opt_initialValue);
  var value, isValueSet = false;

  if (2 < arguments.length) {
    value = opt_initialValue;
    isValueSet = true;
  }
  for (var i = 0, l = array.length; l > i; ++i) {
    if (array.hasOwnProperty(i)) {
      if (isValueSet) {
        value = callback(value, array[i], i, array);
      }
      else {
        value = array[i];
        isValueSet = true;
      }
    }
  }

  return value;
};

// String.prototype.substr - negative index don't work in IE8
if ('ab'.substr(-1) !== 'b') {
  exports.substr = function (str, start, length) {
    // did we get a negative start, calculate how much it is from the beginning of the string
    if (start < 0) start = str.length + start;

    // call the original function
    return str.substr(start, length);
  };
} else {
  exports.substr = function (str, start, length) {
    return str.substr(start, length);
  };
}

// String.prototype.trim is supported in IE9
exports.trim = function (str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
};

// Function.prototype.bind is supported in IE9
exports.bind = function () {
  var args = Array.prototype.slice.call(arguments);
  var fn = args.shift();
  if (fn.bind) return fn.bind.apply(fn, args);
  var self = args.shift();
  return function () {
    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
  };
};

// Object.create is supported in IE9
function create(prototype, properties) {
  var object;
  if (prototype === null) {
    object = { '__proto__' : null };
  }
  else {
    if (typeof prototype !== 'object') {
      throw new TypeError(
        'typeof prototype[' + (typeof prototype) + '] != \'object\''
      );
    }
    var Type = function () {};
    Type.prototype = prototype;
    object = new Type();
    object.__proto__ = prototype;
  }
  if (typeof properties !== 'undefined' && Object.defineProperties) {
    Object.defineProperties(object, properties);
  }
  return object;
}
exports.create = typeof Object.create === 'function' ? Object.create : create;

// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
// they do show a description and number property on Error objects
function notObject(object) {
  return ((typeof object != "object" && typeof object != "function") || object === null);
}

function keysShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.keys called on a non-object");
  }

  var result = [];
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// getOwnPropertyNames is almost the same as Object.keys one key feature
//  is that it returns hidden properties, since that can't be implemented,
//  this feature gets reduced so it just shows the length property on arrays
function propertyShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
  }

  var result = keysShim(object);
  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
    result.push('length');
  }
  return result;
}

var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
  Object.getOwnPropertyNames : propertyShim;

if (new Error().hasOwnProperty('description')) {
  var ERROR_PROPERTY_FILTER = function (obj, array) {
    if (toString.call(obj) === '[object Error]') {
      array = exports.filter(array, function (name) {
        return name !== 'description' && name !== 'number' && name !== 'message';
      });
    }
    return array;
  };

  exports.keys = function (object) {
    return ERROR_PROPERTY_FILTER(object, keys(object));
  };
  exports.getOwnPropertyNames = function (object) {
    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
  };
} else {
  exports.keys = keys;
  exports.getOwnPropertyNames = getOwnPropertyNames;
}

// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
function valueObject(value, key) {
  return { value: value[key] };
}

if (typeof Object.getOwnPropertyDescriptor === 'function') {
  try {
    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  } catch (e) {
    // IE8 dom element issue - use a try catch and default to valueObject
    exports.getOwnPropertyDescriptor = function (value, key) {
      try {
        return Object.getOwnPropertyDescriptor(value, key);
      } catch (e) {
        return valueObject(value, key);
      }
    };
  }
} else {
  exports.getOwnPropertyDescriptor = valueObject;
}

},{}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// UTILITY
var util = require('util');
var shims = require('_shims');
var pSlice = Array.prototype.slice;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  this.message = options.message || getMessage(this);
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = shims.keys(a),
        kb = shims.keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};
},{"_shims":5,"util":7}],7:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var shims = require('_shims');

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  shims.forEach(array, function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = shims.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = shims.getOwnPropertyNames(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }

  shims.forEach(keys, function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (shims.indexOf(ctx.seen, desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = shims.reduce(output, function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return shims.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return arg instanceof Buffer;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = shims.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = shims.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

},{"_shims":5}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],49:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])
;