require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var __dirname="/";var KevoreeCore             = require('kevoree-core'),
    JSONModelLoader         = require('kevoree-library').org.kevoree.loader.JSONModelLoader,
    KevoreeBrowserLogger    = require('./lib/KevoreeBrowserLogger'),
    HTTPBootstrapper        = require('./lib/BrowserBootstrapper');

var log = new KevoreeBrowserLogger('Runtime');

// init core objects
var kevoreeCore     = new KevoreeCore(__dirname, log),
    jsonLoader      = new JSONModelLoader(),
    bootstrapper    = new HTTPBootstrapper(__dirname);

// init DOM objects
var startBtn    = $('#start-btn'),
    deployBtn   = $('#deploy-btn'),
    nodeName    = $('#node-name'),
    started     = false,
    deployed    = false,
    deploying   = false;

kevoreeCore.on('started', function () {
    log.info("KevoreeCore started");
    started = true;
    startBtn.addClass("disabled");
    deployBtn.removeClass("disabled");
});

kevoreeCore.on('deployed', function (err, model) {
    deploying = false;
    deployed = true;
    deployBtn.popover('hide');
    deployBtn.removeClass("disabled");
    log.info("KevoreeCore deployed");
});

kevoreeCore.on('stopped', function (err, model) {
    log.info("KevoreeCore stopped");
    started = deployed = deploying = false;
    startBtn.removeClass("disabled");
});

kevoreeCore.on('error', function (err) {
    log.error(err.message);
    deploying = deployed = false;
    deployBtn.popover('hide');
    deployBtn.removeClass("disabled");
    try {
        // try to stop Kevoree Core on error
        kevoreeCore.stop();
    } catch (err) {
        started = deployed = deploying = false;
    }
});

//set Kevoree bootstrapper
kevoreeCore.setBootstrapper(bootstrapper);

// start Kevoree Core button clicked
startBtn.on('click', function () {
    if (!started) {
        try {
            var nodename = nodeName.val() || "node0";
            kevoreeCore.start(cleanString(nodename));
            nodeName.prop('disabled', 'disabled');
        } catch (err) {
            log.error(err.message);
        }

    } else log.warn();
});

// deploy button clicked
deployBtn.on('click', function () {
    if (started) {
        if (!deploying) {
            if (!deployed) {
                try {
                    deploying = true;
                    deployBtn.addClass("disabled");
                    deployBtn.popover({
                        html: true,
                        content: deployPopoverContent,
                        placement: 'bottom',
                        trigger: 'manual'
                    });
                    deployBtn.popover('show');

                    $.ajax({
                        type: 'GET',
                        url: '/bootstrap',
                        data: {nodename: kevoreeCore.getNodeName()},
                        success: function (data) {
                            kevoreeCore.deploy(jsonLoader.loadModelFromString(data.model).get(0));
                        },
                        error: function (err) {
                            console.error(err);
                            log.error('Unable to retrieve bootstrap model from server. Aborting deploy.');
                            deploying = false;
                            deployBtn.removeClass('disabled');
                            deployBtn.popover('hide');
                        }
                    });
                } catch (err) {
                    log.error(err.message);
                }
            } else {
                log.warn("Model is already deployed.");
            }
        } else {
            log.warn("Already trying to deploy model, please wait...");
        }
    } else {
        log.warn("Can't deploy model: you must start Kevoree Runtime first.");
    }
});

var deployPopoverContent = function deployPopoverContent() {
    return '<small>Please wait while deploying...</small>' +
           '<div class="progress progress-striped active" style="margin-bottom: 0px">'+
             '<div class="progress-bar progress-bar-info"  role="progressbar" aria-valuenow="45" aria-valuemin="0" aria-valuemax="100" style="width: 100%"></div>' +
           '</div>';
}

var cleanString = function cleanString(str) {
    str = str.replace(/\s/g, '');
    str = str.replace(/[^\w\d]/g, '');
    return str;
}

},{"./lib/BrowserBootstrapper":2,"./lib/KevoreeBrowserLogger":4,"kevoree-core":12,"kevoree-library":"qQyNdC"}],2:[function(require,module,exports){
var Bootstrapper    = require('kevoree-commons').Bootstrapper,
    KevoreeLogger   = require('./KevoreeBrowserLogger'),
    GITResolver     = require('./GITResolver'),
    NPMResolver     = require('./NPMResolver');

var GIT     = 'git',
    FILE    = 'file',
    NPM     = 'npm';

var BrowserBootstrapper = Bootstrapper.extend({
    toString: 'BrowserBootstrapper',

    construct: function (modulesPath) {
        this.modulesPath = modulesPath;

        this.resolvers = {};
        this.resolvers[GIT] = new GITResolver(modulesPath);
        this.resolvers[NPM] = new NPMResolver(modulesPath);

        this.log = new KevoreeLogger(this.toString());
    },

    /**
     *
     * @param deployUnit
     * @param callback
     */
    bootstrap: function (deployUnit, callback) {
        // --- Resolvers callback
        var bootstrapper = this;
        this.resolver('resolve', deployUnit, function (err, EntityClass) {
            if (err) {
                bootstrapper.log.error(err.message);
                return callback(new Error("'"+deployUnit.unitName+"' bootstrap failed!"));
            }

            // install success
            return callback(null, EntityClass);
        });
    },

    uninstall: function (deployUnit, callback) {
        var bootstrapper = this;
        this.resolver('uninstall', deployUnit, function (err) {
            if (err) {
                bootstrapper.log.error(err.message);
                return callback(new Error("'"+deployUnit.unitName+"' uninstall failed!"));
            }

            // uninstall success
            return callback(null);
        });
    },

    resolver: function (action, deployUnit, callback) {
        var url = deployUnit.url || '';

        if (url.startsWith(FILE)) {
//            this.resolvers[FILE][action](deployUnit, callback);
            return callback(new Error("File resolver not implemented yet"));

        } else if (url.startsWith(GIT)) {
            this.resolvers[GIT][action](deployUnit, callback);

        } else {
            this.resolvers[NPM][action](deployUnit, callback);
        }
    }
});

module.exports = BrowserBootstrapper;
},{"./GITResolver":3,"./KevoreeBrowserLogger":4,"./NPMResolver":5,"kevoree-commons":7}],3:[function(require,module,exports){
var Resolver        = require('kevoree-commons').Resolver,
    KevoreeLogger   = require('./KevoreeBrowserLogger');

var GITResolver = Resolver.extend({
    toString: 'GITResolver',

    construct: function (modulesPath) {
        this.modulesPath = modulesPath;
        this.log = new KevoreeLogger(this.toString());
    },

    resolve: function (deployUnit, callback) {
        var resolver = this;
        callback(new Error("GitResolver: Not implemented yet"));
        // TODO
    },

    uninstall: function (deployUnit, callback) {
        var resolver = this;
        callback(new Error("GitResolver: Not implemented yet"));
        // TODO
    }
});

module.exports = GITResolver;
},{"./KevoreeBrowserLogger":4,"kevoree-commons":7}],4:[function(require,module,exports){
var KevoreeLogger = require('kevoree-commons').KevoreeLogger;

var logDOM  = document.querySelector('#log-console'),
    ERROR   = 0,
    WARN    = 1,
    DEBUG   = 2,
    INFO    = 3;

/**
 * DOM logger
 * @param level
 * @param tag
 * @param msg
 */
var addLogToDOM = function addLogToDOM(level, tag, msg) {
    var tr      = document.createElement('tr'),
        timeTd  = document.createElement('td'),
        tagTd   = document.createElement('td'),
        msgTd   = document.createElement('td');

    switch (level) {
        case DEBUG:
            tr.className += ' success';
            break;

        case INFO:
            tr.className += ' primary';
            break;

        case ERROR:
            tr.className += ' danger';
            break;

        case WARN:
            tr.className += ' warning';
            break;
    }

    timeTd.innerHTML = getTimeFormatted();
    tagTd.innerHTML = '<strong>'+tag+'</strong>';
    msgTd.innerHTML = msg;

    timeTd.className = 'time-td';
    tagTd.className = 'tag-td';

    tr.appendChild(timeTd);
    tr.appendChild(tagTd);
    tr.appendChild(msgTd);
    logDOM.appendChild(tr);
}

/**
 * Console logger
 * @param level
 * @param tag
 * @param msg
 */
var addLogToConsole = function addLogToConsole(level, tag, msg) {
    switch (level) {
        case DEBUG:
            console.info(tag+': '+msg);
            break;

        case INFO:
            console.log(tag+': '+msg);
            break;

        case ERROR:
            console.error(tag+': '+msg);
            break;

        case WARN:
            console.warn(tag+': '+msg);
            break;
    }
}

// determine which logger to use
var logger = (function () {
    if (logDOM != null) {
        return addLogToDOM;
    } else {
        return addLogToConsole;
    }
})();

/**
 * KevoreeBrowserLogger redefines KevoreeLogger in order to show logs wether in browser's console
 * or by finding a #log-console ID in the DOM.
 * @type {KevoreeBrowserLogger} extend KevoreeLogger
 */
var KevoreeBrowserLogger = KevoreeLogger.extend({
    toString: 'KevoreeBrowserLogger',

    info: function (msg) {
        logger(INFO, this.tag, msg);
    },

    warn: function (msg) {
        logger(WARN, this.tag, msg);
    },

    debug: function (msg) {
        logger(DEBUG, this.tag, msg);
    },

    error: function (msg) {
        logger(ERROR, this.tag, msg);
    }
});

var getTimeFormatted = function getTimeFormatted() {
    var time = new Date;
    return time.getHours()+':'+time.getMinutes()+':'+time.getSeconds()+':'+time.getMilliseconds();
}

module.exports = KevoreeBrowserLogger;
},{"kevoree-commons":7}],5:[function(require,module,exports){
var Resolver        = require('kevoree-commons').Resolver,
    KevoreeLogger   = require('./KevoreeBrowserLogger'),
    FileSystem      = require('kevoree-commons').FileSystem,
    async           = require('async');

/**
 * Retrieves module content from zip from server
 * @type {NPMResolver}
 */
var NPMResolver = Resolver.extend({
    toString: 'NPMResolver',

    construct: function (modulesPath) {
        this.modulesPath = modulesPath;
        this.log = new KevoreeLogger(this.toString());
    },

    resolve: function (deployUnit, callback) {
        var resolver = this;
        // TODO do not ask for server resolving if we already have the version locally

        // forward resolving request to server
        $.ajax({
            type: 'GET',
            url: '/resolve',
            data: {
                type: deployUnit.type,
                name: deployUnit.unitName,
                version: deployUnit.version
            },
            success: function (resp) {
                // server response contains a zipPath & name of the requested module package
                // (retrieved server-side from npm registry)

                installZip(resp.zipPath, resp.zipName, function (err) {
                    if (err) {
                        errorHandler(err);
                        callback(err);
                        return;
                    }

                    // zip installed successfully
                    $.getScript('filesystem:'+window.location.origin+'/persistent/kev_libraries/'+deployUnit.unitName+'@'+deployUnit.version+'/'+deployUnit.unitName+'-bundle.js', function () {
                        resolver.log.info("Zip '"+deployUnit.unitName+"' installed and module loaded successfully");
                        var ModuleEntry = require(deployUnit.unitName);
                        callback(null, ModuleEntry);
                    });
                });
            },
            error: function (err) {
                if (err.responseText.length == 0) {
                    err.responseText = "Kevoree Runtime server was not able to process '/resolve' request ("+deployUnit.unitName+":"+deployUnit.version+")";
                }
                callback(new Error(err.responseText));
            }
        });
    },

    uninstall: function (deployUnit, callback) {
        console.warn("NPMResolver.uninstall(...): Not implemented yet (I did NOT uninstall the module, but I told the bootstrapper that I did)");
        callback();
        // TODO
    }
});

/**
 * Download and install zip locally in browser file system
 * @param zipPath zip file path on server
 * @param zipName zip name
 * @param callback
 */
var installZip = function installZip(zipPath, zipName, callback) {
    var fsapi = new FileSystem();
    // create a local file system of 50Mb
    fsapi.getFileSystem(5*1024*1024*1024, function (err, fs) {
        // create a root directory called "kev_libraries" in this fs
        fs.root.getDirectory('kev_libraries', { create: true, exclusive: false }, function (rootDir) {
            rootDir.getDirectory(zipName, { create: true, exclusive: false}, function (zipDir) {
                // remove dir content before re-writing
                zipDir.removeRecursively(function () {
                    // dir content removed
                    fillDir();
                }, function () {
                    // error (meaning that the directory does not exist, so create it)
                    fillDir();
                });

                /**
                 * Fill directory "zipDir" with zip content
                 */
                function fillDir() {
                    // create a new directory for the current zip
                    rootDir.getDirectory(zipName, { create: true, exclusive: false }, function (zipDir) {
                        // read zip content
                        zip.createReader(new zip.HttpReader(zipPath), function(reader) {
                            reader.getEntries(function(entries) {
                                // process all entries from the zip
                                processEntries(entries, zipDir, callback);
                            });
                        }, callback);
                    }, callback);
                }
            });
        }, callback);
    });
}

/**
 * Only processes 'file' entries in zip
 * @param entries
 * @param zipDir
 * @param callback
 */
var processEntries = function processEntries(entries, zipDir, callback) {
    var asyncTasks = [];

    // check entries type (dir, file)
    for (var i in entries) {
        if (entries[i].directory == false) {
            asyncTasks.push(function (taskCallback) {
                processFileEntry(entries[i], zipDir, function (err) {
                    if (err) {
                        taskCallback(err);
                        return;
                    }

                    taskCallback(null);
                });
            });
        }
    }

    // execute each task asynchronously
    async.parallel(asyncTasks, function (err) {
        if (err) {
            callback(err);
            return;
        }

        // all tasks run without error : cool =)
        callback(null);
    });
}

/**
 * Will recursively create needed directories for the file entry given
 * if its path is nested.
 * Lets say the entry has 'foo/bar/baz.ext' file path, this will try
 * to create a new directory foo, then bar, then call a file create into that 'bar' directory
 * @param entry
 * @param zipDir
 * @param callback
 */
var processFileEntry = function processFileEntry(entry, zipDir, callback) {
    getDir(entry.filename, zipDir, function (dir) {
        var splittedName = entry.filename.split('/'),
            cleanName    = splittedName[splittedName.length-1];
       dir.getFile(cleanName, {create: true, exclusive: false}, function(fileEntry) {
           // Create a FileWriter object for our FileEntry (log.txt).
           fileEntry.createWriter(function(fileWriter) {

               fileWriter.onwriteend = function(e) {
                   console.log('Write completed: ', zipDir);
                   callback(null, fileEntry);
               };

               fileWriter.onerror = function(e) {
                   console.log('Write failed: ' + e.toString());
                   callback(e);
               };

               entry.getData(new zip.TextWriter(), function(text) {
                   // Create a new Blob and write it to log.txt.
                   var blob = new Blob([text], {type: 'text/plain'});
                   fileWriter.write(blob);
               });

           });

       }, callback);
    }, callback);
}

/**
 * Recursively creates directory tree according to given path
 * @param path foo/bar/baz.ext
 * @param dir root directory to start directories creation (always need a starting point !)
 * @param callback
 */
var getDir = function getDir(path, dir, callback, errorCallback) {
    if (!dir || dir == null) {
        errorCallback(new Error('getDir(path, dir, callback, errorCallback) error: "dir" is null'));
        return;
    }

    var splittedPath = path.split('/');
    if (splittedPath.length == 1) {
        callback(dir);

    } else {
        dir.getDirectory(splittedPath[0], {create: true, exclusive: false}, function (newDir) {
            getDir(splittedPath.slice(1, splittedPath.length).join('/'), newDir, callback);
        }, errorHandler);
    }
}

var errorHandler = function errorHandler(e) {
       var msg = '';
       switch (e.code) {
         case FileError.QUOTA_EXCEEDED_ERR:
           msg = 'QUOTA_EXCEEDED_ERR';
           break;
         case FileError.NOT_FOUND_ERR:
           msg = 'NOT_FOUND_ERR';
           break;
         case FileError.SECURITY_ERR:
           msg = 'SECURITY_ERR';
           break;
         case FileError.INVALID_MODIFICATION_ERR:
           msg = 'INVALID_MODIFICATION_ERR';
           break;
         case FileError.INVALID_STATE_ERR:
           msg = 'INVALID_STATE_ERR';
           break;
         default:
           console.error(e);
           return;
       };

       console.log('Error: ' + msg);
}

module.exports = NPMResolver;
},{"./KevoreeBrowserLogger":4,"async":6,"kevoree-commons":7}],6:[function(require,module,exports){
var process=require("__browserify_process");/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = setImmediate;
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

},{"__browserify_process":23}],7:[function(require,module,exports){
module.exports.Resolver         = require('./lib/Resolver');
module.exports.Bootstrapper     = require('./lib/Bootstrapper');
module.exports.KevoreeLogger    = require('./lib/KevoreeLogger');
module.exports.FileSystem       = require('./lib/FileSystem');
},{"./lib/Bootstrapper":8,"./lib/FileSystem":9,"./lib/KevoreeLogger":10,"./lib/Resolver":11}],8:[function(require,module,exports){
var Class = require('pseudoclass');

/**
 * Bootstrapper API
 * @type {Bootstrapper}
 */
var Bootstrapper = Class({
    toString: 'Bootstrapper',

    /**
     *
     * @param nodeName
     * @param model
     * @param callback
     */
    bootstrapNodeType: function (nodeName, model, callback) {
        callback = callback || function () {};

        var nodeInstance = model.findNodesByID(nodeName);
        if (nodeInstance != undefined && nodeInstance != null) {
            var deployUnits = nodeInstance.typeDefinition.deployUnits;
            if (deployUnits.size() > 0) {
                // bootstrap node deploy unit
                this.bootstrap(deployUnits.get(0), callback);

            } else {
                callback.call(this, new Error("'"+nodeName+"' NodeType deploy units not found. Have you forgotten to merge nodetype library ?"));
                return;
            }
        } else {
            callback.call(this, new Error("Unable to find '"+nodeName+"' in the given model."));
            return;
        }
    },

    /**
     *
     * @param deployUnit
     * @param callback
     */
    bootstrap: function (deployUnit, callback) {},

    /**
     *
     * @param deployUnit
     * @param callback
     */
    uninstall: function (deployUnit, callback) {}
});

module.exports = Bootstrapper;
},{"pseudoclass":18}],9:[function(require,module,exports){
var Class         = require('pseudoclass');

var FileSystem = Class({
    toString: 'FileSystem',

    getFileSystem: function (size, callback) {
        if (document) {
            getBrowserFileSystem(this, size, callback);
        } else {
            console.error('Kevoree FileSystem API only handles Browser FS for now.');
        }
    }
});

var getBrowserFileSystem = function getBrowserFileSystem(fsapi, size, callback) {
    window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
    navigator.persistentStorage = navigator.persistentStorage || navigator.webkitPersistentStorage;

    if (window.requestFileSystem && navigator.persistentStorage) {

        var successHandler = function successHandler(grantedSize) {
            window.requestFileSystem(window.PERSISTENT, grantedSize, function (fs) {
                callback.call(fsapi, null, fs);
            });
        }

        var errorHandler = function errorHandler(e) {
            callback.call(fsapi, null);
        }

        navigator.persistentStorage.requestQuota(size, successHandler, errorHandler);
    }
}

module.exports = FileSystem;
},{"pseudoclass":18}],10:[function(require,module,exports){
var Class = require('pseudoclass');

var KevoreeLogger = Class({
    toString: 'KevoreeLogger',

    construct: function (tag) {
        this.tag = tag;
    },

    info: function (msg) {
        console.log('[INFO] '+this.tag+': '+msg);
    },

    warn: function (msg) {
        console.warn('[WARN] '+this.tag+': '+msg);
    },

    error: function (msg) {
        console.error('[ERROR] '+this.tag+': '+msg);
    },

    debug: function (msg) {
        console.log('[DEBUG] '+this.tag+': '+msg);
    }
});

module.exports = KevoreeLogger;
},{"pseudoclass":18}],11:[function(require,module,exports){
var Class = require('pseudoclass');

/**
 * Resolver API
 * @type {Resolver}
 */
var Resolver = Class({
    toString: 'Resolver',

    /**
     *
     * @param deployUnit Kevoree DeployUnit
     * @param callback(err, Class)
     */
    resolve: function (deployUnit, callback) {},

    uninstall: function (deployUnit, callback) {}
});

module.exports = Resolver;
},{"pseudoclass":18}],12:[function(require,module,exports){
var Class           = require('pseudoclass'),
    kLib            = require('kevoree-library'),
    KevoreeLogger   = require('kevoree-commons').KevoreeLogger,
    async           = require('async'),
    EventEmitter    = require('events').EventEmitter;

/**
 * Kevoree Core
 *
 * @type {*}
 */
module.exports = Class({
    toString: 'KevoreeCore',

    /**
     * Core constructor
     */
    construct: function(modulesPath, logger) {
        this.log = (logger != undefined) ? logger : new KevoreeLogger(this.toString());

        this.factory = new kLib.org.kevoree.impl.DefaultKevoreeFactory();
        this.loader  = new kLib.org.kevoree.loader.JSONModelLoader();
        this.compare = new kLib.org.kevoree.compare.DefaultModelCompare();
        this.cloner  = new kLib.org.kevoree.cloner.DefaultModelCloner();

        this.currentModel   = null;
        this.deployModel    = null;
        this.models         = [];
        this.nodeName       = null;
        this.nodeInstance   = null;
        this.modulesPath    = modulesPath;
        this.bootstrapper   = null;
        this.intervalId     = null;

        this.emitter = new EventEmitter();
    },

    /**
     * Destruct core instance
     */
    destruct: function() {
        this.log.debug('Destructing...');
    },

    /**
     * Starts Kevoree Core
     * @param nodeName
     */
    start: function (nodeName) {
        if (nodeName == undefined || nodeName.length == 0) nodeName = "node0";

        this.nodeName = nodeName;
        this.currentModel = this.factory.createContainerRoot();

        // starting loop function
        this.intervalId = setInterval(function () {}, 1e8);

        this.log.info("Platform started: "+nodeName);

        this.emitter.emit('started');
    },

    setBootstrapper: function (bootstrapper) {
        this.bootstrapper = bootstrapper;
    },

    getBootstrapper: function () {
        return this.bootstrapper;
    },

    /**
     * Stops Kevoree Core
     */
    stop: function () {
        if (this.intervalId != undefined && this.intervalId != null) {
            if (this.nodeInstance != null) {
                this.nodeInstance.stop();
            }
            clearInterval(this.intervalId);
            this.intervalId = null;
            this.currentModel = null;

            this.log.info("Platform stopped: "+this.nodeName);
            this.emitter.emit('stopped');
        }
    },

    /**
     * Save model to hdd
     */
    saveModel: function () {
        // TODO
    },

    /**
     * Compare current with model
     * Get traces and call command (that can be redefined)
     *
     * @param model
     */
    deploy: function (model) {
        if (model.findNodesByID(this.nodeName) == null) {
            this.emitter.emit('error', new Error('Deploy model failure: unable to find '+this.nodeName+' in given model'));
            return;

        } else {
            this.log.info('Deploy process started...');
            if (model != undefined && model != null) {
                // check if there is an instance currently running
                // if not, it will try to run it
                var core = this;
                this.checkBootstrapNode(model, function (err) {
                    if (err) {
                        core.emitter.emit('error', err);
                        return;
                    }

                    if (core.nodeInstance != undefined && core.nodeInstance != null) {
                        // given model is defined and not null
                        core.deployModel = core.cloner.clone(model, true);
                        core.deployModel.setRecursiveReadOnly();
                        var diffSeq = core.compare.diff(core.currentModel, core.deployModel);
                        var adaptations = core.nodeInstance.processTraces(diffSeq.traces, core.deployModel);
                        // list of adaptation commands retrieved
                        var cmdStack = [];

                        // executeCommand: function that save cmd to stack and executes it
                        var executeCommand = function executeCommand(cmd, iteratorCallback) {
                            // save the cmd to be processed in a stack using unshift
                            // in order to add the last processed cmd at the beginning of the array
                            // => cmdStack[0] = more recently executed cmd
                            cmdStack.unshift(cmd);

                            // execute cmd
                            cmd.execute(function (err) {
                                if (err) {
                                    iteratorCallback(err);
                                    return;
                                }

                                // adaptation succeed
                                iteratorCallback();
                            });
                        };

                        // rollbackCommand: function that calls undo() on cmds in the stack
                        var rollbackCommand = function rollbackCommand(cmd, iteratorCallback) {
                            cmd.undo(function (err) {
                                if (err) {
                                    iteratorCallback(err);
                                    return;
                                }

                                // undo succeed
                                iteratorCallback();
                            });
                        };

                        // execute each command synchronously
                        async.eachSeries(adaptations, executeCommand, function (err) {
                            if (err) {
                                // something went wrong while processing adaptations
                                core.log.error(err.message);

                                // rollback process
                                async.eachSeries(cmdStack, rollbackCommand, function (er) {
                                    if (er) {
                                        // something went wrong while rollbacking
                                        core.log.error(er.message);
                                        core.emitter.emit('error', new Error("Something went wrong while rollbacking..."));
                                        return;
                                    }

                                    // rollback succeed
                                    core.emitter.emit('rollback');
                                    return;
                                });

                                core.emitter.emit('error', new Error("Something went wrong while processing adaptations. Rollback"));
                                return;
                            }

                            // adaptations succeed : woot
                            core.log.debug("Model deployed successfully.");
                            // save old model
                            pushInArray(core.models, core.currentModel);
                            // set new model to be the current deployed one
                            core.currentModel = model; // do not give core.deployModel here because it is a readOnly model
                            // reset deployModel
                            core.deployModel = null;
                            // all good :)
                            core.emitter.emit('deployed', core.currentModel);
                            return;
                        });

                    } else {
                        core.emitter.emit('error', new Error("There is no instance to bootstrap on"));
                        return;
                    }
                });
            } else {
                this.emitter.emit('error', new Error("model is not defined or null. Deploy aborted."));
                return;
            }
        }
    },

    checkBootstrapNode: function (model, callback) {
        callback = callback || function () { console.warn('No callback defined for checkBootstrapNode(model, cb) in KevoreeCore'); };

        if (this.nodeInstance == undefined || this.nodeInstance == null) {
            this.log.info("Start '"+this.nodeName+"' bootstrapping...");
            var core = this;
            this.bootstrapper.bootstrapNodeType(this.nodeName, model, function (err, AbstractNode) {
                if (err) {
                    core.log.error(err.message);
                    callback(new Error("Unable to bootstrap '"+core.nodeName+"'! Start process aborted."));
                    return;
                }

                core.nodeInstance = new AbstractNode();
                core.nodeInstance.setKevoreeCore(core);
                core.nodeInstance.setName(core.nodeName);
                core.nodeInstance.start();

                core.log.info("'"+core.nodeName+"' instance started successfully");

                callback();
                return
            });

        } else {
            callback();
            return;
        }
    },

    /**
     * Put core in readonly mode
     */
    lock: function() {
        // TODO
    },

    /**
     * Put core in read/write mode
     */
    unlock: function() {
        // TODO
    },

    getCurrentModel: function () {
        return this.currentModel;
    },

    getPreviousModel: function () {
        var model = null;
        if (this.models.length > 0) model = this.models[this.models.length-1];
        return model;
    },

    getPreviousModels: function () {
        return this.models;
    },

    getModulesPath: function () {
        return this.modulesPath;
    },

    getDeployModel: function () {
        return this.deployModel;
    },

    getNodeName: function () {
        return this.nodeName;
    },

    on: function (event, callback) {
        this.emitter.addListener(event, callback);
    }
});

// utility function to ensure cached model list won't go over 10 items
var pushInArray = function pushInArray(array, model) {
    if (array.length == 10) this.shift();
    array.push(model);
}

// utility function to know if a model is currently already in the array
var containsModel = function containsModel(array, model) {
    return (array.indexOf(model) > -1);
}
},{"async":6,"events":20,"kevoree-commons":7,"kevoree-library":"qQyNdC","pseudoclass":18}],"GtU2J/":[function(require,module,exports){
module.exports = require('./lib/kotlin');
},{"./lib/kotlin":15}],"kevoree-kotlin":[function(require,module,exports){
module.exports=require('GtU2J/');
},{}],15:[function(require,module,exports){

// TODO drop this:
(function () {
    'use strict';

    if (!Array.isArray) {
        Array.isArray = function (vArg) {
            return Object.prototype.toString.call(vArg) === "[object Array]";
        };
    }

    if (!Function.prototype.bind) {
        Function.prototype.bind = function (oThis) {
            if (typeof this !== "function") {
                // closest thing possible to the ECMAScript 5 internal IsCallable function
                throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
            }

            var aArgs = Array.prototype.slice.call(arguments, 1),
                fToBind = this,
                fNOP = function () {
                },
                fBound = function () {
                    return fToBind.apply(this instanceof fNOP && oThis
                                             ? this
                                             : oThis,
                                         aArgs.concat(Array.prototype.slice.call(arguments)));
                };

            fNOP.prototype = this.prototype;
            fBound.prototype = new fNOP();

            return fBound;
        };
    }

    if (!Object.keys) {
        Object.keys = function (o) {
            var result = [];
            var i = 0;
            for (var p in o) {
                if (o.hasOwnProperty(p)) {
                    result[i++] = p;
                }
            }
            return result;
        };
    }

    if (!Object.create) {
        Object.create = function(proto) {
            function F() {}
            F.prototype = proto;
            return new F();
        }
    }

    // http://ejohn.org/blog/objectgetprototypeof/
    if ( typeof Object.getPrototypeOf !== "function" ) {
        if ( typeof "test".__proto__ === "object" ) {
            Object.getPrototypeOf = function(object){
                return object.__proto__;
            };
        } else {
            Object.getPrototypeOf = function(object){
                // May break if the constructor has been tampered with
                return object.constructor.prototype;
            };
        }
    }
})();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

var Kotlin = {};

(function () {

    function toArray(obj) {
        var array;
        if (obj == null) {
            array = [];
        }
        else if(!Array.isArray(obj)) {
            array = [obj];
        }
        else {
            array = obj;
        }
        return array;
    }

    function copyProperties(to, from) {
        if (to == null || from == null) {
            return;
        }
        for (var p in from) {
            if (from.hasOwnProperty(p)) {
                to[p] = from[p];
            }
        }
    }

    function getClass(basesArray) {
        for (var i = 0; i < basesArray.length; i++) {
            if (isNativeClass(basesArray[i]) || basesArray[i].$metadata$.type === Kotlin.TYPE.CLASS) {
                return basesArray[i];
            }
        }
        return null;
    }

    var emptyFunction = function() {
        return function() {};
    };

    Kotlin.TYPE = {
        CLASS: "class",
        TRAIT: "trait",
        OBJECT: "object"
    };

    Kotlin.classCount = 0;
    Kotlin.newClassIndex = function() {
        var tmp = Kotlin.classCount;
        Kotlin.classCount++;
        return tmp;
    };

    function isNativeClass(obj) {
        return !(obj == null) && obj.$metadata$ == null;
    }

    function applyExtension(current, bases, baseGetter) {
        for (var i = 0; i < bases.length; i++) {
            if (isNativeClass(bases[i])) {
                continue;
            }
            var base = baseGetter(bases[i]);
            for (var p in  base) {
                if (base.hasOwnProperty(p)) {
                    if(!current.hasOwnProperty(p) || current[p].$classIndex$ < base[p].$classIndex$) {
                        current[p] = base[p];
                    }
                }
            }
        }
    }

    function computeMetadata(bases, properties) {
        var metadata = {};

        metadata.baseClasses = toArray(bases);
        metadata.baseClass = getClass(metadata.baseClasses);
        metadata.classIndex = Kotlin.newClassIndex();
        metadata.functions = {};
        metadata.properties = {};

        if (!(properties == null)) {
            for (var p in properties) {
                if (properties.hasOwnProperty(p)) {
                    var property = properties[p];
                    property.$classIndex$ = metadata.classIndex;
                    if (typeof property === "function") {
                        metadata.functions[p] = property;
                    } else {
                        metadata.properties[p] = property;
                    }
                }
            }
        }
        applyExtension(metadata.functions, metadata.baseClasses, function (it) {
            return it.$metadata$.functions
        });
        applyExtension(metadata.properties, metadata.baseClasses, function (it) {
            return it.$metadata$.properties
        });

        return metadata;
    }

    function class_object() {
        var object = this.object_initializer$();
        Object.defineProperty(this, "object", {value: object});
        return object;
    }

    Kotlin.createClass = function (bases, constructor, properties, staticProperties) {
        if (constructor == null) {
            constructor = emptyFunction();
        }
        copyProperties(constructor, staticProperties);

        var metadata = computeMetadata(bases, properties);
        metadata.type = Kotlin.TYPE.CLASS;

        var prototypeObj;
        if (metadata.baseClass !== null) {
            prototypeObj = Object.create(metadata.baseClass.prototype);
        } else {
            prototypeObj = {};
        }
        Object.defineProperties(prototypeObj, metadata.properties);
        copyProperties(prototypeObj, metadata.functions);
        prototypeObj.constructor = constructor;

        if (metadata.baseClass != null) {
            constructor.baseInitializer = metadata.baseClass;
        }

        constructor.$metadata$ = metadata;
        constructor.prototype = prototypeObj;
        Object.defineProperty(constructor, "object", {get: class_object, configurable: true});
        return constructor;
    };

    Kotlin.createObject = function (bases, constructor, functions) {
        var noNameClass = Kotlin.createClass(bases, constructor, functions);
        var obj = new noNameClass();
        obj.$metadata$ = {
            type: Kotlin.TYPE.OBJECT
        };
        return  obj;
    };

    Kotlin.createTrait = function (bases, properties, staticProperties) {
        var obj = function () {};
        copyProperties(obj, staticProperties);

        obj.$metadata$ = computeMetadata(bases, properties);
        obj.$metadata$.type = Kotlin.TYPE.TRAIT;
        return obj;
    };

    function isInheritanceFromTrait (objConstructor, trait) {
        if (isNativeClass(objConstructor) || objConstructor.$metadata$.classIndex < trait.$metadata$.classIndex) {
            return false;
        }
        var baseClasses = objConstructor.$metadata$.baseClasses;
        var i;
        for (i = 0; i < baseClasses.length; i++) {
            if (baseClasses[i] === trait) {
                return true;
            }
        }
        for (i = 0; i < baseClasses.length; i++) {
            if (isInheritanceFromTrait(baseClasses[i], trait)) {
                return true;
            }
        }
        return false;
    }

    Kotlin.isType = function (object, klass) {
        if (object == null || klass == null) {
            return false;
        } else {
            if (object instanceof klass) {
                return true;
            }
            else if (isNativeClass(klass) || klass.$metadata$.type == Kotlin.TYPE.CLASS) {
                return false;
            }
            else {
                return isInheritanceFromTrait(object.constructor, klass);
            }
        }
    };


////////////////////////////////// packages & modules //////////////////////////////

    function createPackageGetter(instance, initializer) {
        return function () {
            if (initializer !== null) {
                var tmp = initializer;
                initializer = null;
                tmp.call(instance);
            }

            return instance;
        };
    }

    function createDefinition(members) {
        var definition = {};
        if (members == null) {
            return definition;
        }
        for (var p in members) {
            if (members.hasOwnProperty(p)) {
                if ((typeof members[p]) === "function") {
                    definition[p] = members[p];
                } else {
                    Object.defineProperty(definition, p, members[p]);
                }
            }
        }
        return definition;
    }

    Kotlin.definePackage = function (initializer, members) {
        var definition = createDefinition(members);
        if (initializer === null) {
            return {value: definition};
        }
        else {
            var getter = createPackageGetter(definition, initializer);
            return {get: getter};
        }
    };

    Kotlin.defineRootPackage = function (initializer, members) {
        var definition = createDefinition(members);

        if (initializer === null) {
            definition.$initializer$ = emptyFunction();
        } else {
            definition.$initializer$ = initializer;
        }
        return definition;
      };

    Kotlin.defineModule = function (id, declaration) {
        if (id in Kotlin.modules) {
            throw new Error("Module " + id + " is already defined");
        }
        declaration.$initializer$.call(declaration); // TODO: temporary hack
        Object.defineProperty(Kotlin.modules, id, {value: declaration});
    };

})();

/**
 * Copyright 2010 Tim Down.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

"use strict";

// todo inlined
String.prototype.startsWith = function (s) {
  return this.indexOf(s) === 0;
};

String.prototype.endsWith = function (s) {
  return this.indexOf(s, this.length - s.length) !== -1;
};

String.prototype.contains = function (s) {
  return this.indexOf(s) !== -1;
};

(function () {
    Kotlin.equals = function (obj1, obj2) {
        if (obj1 == null) {
            return obj2 == null;
        }

        if (Array.isArray(obj1)) {
            return Kotlin.arrayEquals(obj1, obj2);
        }

        if (typeof obj1 == "object" && obj1.equals !== undefined) {
            return obj1.equals(obj2);
        }

        return obj1 === obj2;
    };

    Kotlin.toString = function (o) {
        if (o == null) {
            return "null";
        }
        else if (Array.isArray(o)) {
            return Kotlin.arrayToString(o);
        }
        else {
            return o.toString();
        }
    };
    
    Kotlin.arrayToString = function(a) {
        return "[" + a.join(", ") + "]";
    };

    Kotlin.intUpto = function (from, to) {
        return new Kotlin.NumberRange(from, to);
    };

    Kotlin.intDownto = function (from, to) {
        return new Kotlin.Progression(from, to, -1);
    };

    Kotlin.modules = {};

    Kotlin.RuntimeException = Kotlin.createClass();
    Kotlin.NullPointerException = Kotlin.createClass();
    Kotlin.NoSuchElementException = Kotlin.createClass();
    Kotlin.IllegalArgumentException = Kotlin.createClass();
    Kotlin.IllegalStateException = Kotlin.createClass();
    Kotlin.UnsupportedOperationException = Kotlin.createClass();
    Kotlin.IOException = Kotlin.createClass();

    Kotlin.throwNPE = function () {
        throw new Kotlin.NullPointerException();
    };

    function throwAbstractFunctionInvocationError(funName) {
        return function() {
            var message;
            if (funName !== undefined) {
                message = "Function " + funName + " is abstract";
            } else {
                message = "Function is abstract";
            }
            throw new TypeError(message);
        };
    }

    Kotlin.Iterator = Kotlin.createClass(null, null, {
        next: throwAbstractFunctionInvocationError("Iterator#next"),
        hasNext: throwAbstractFunctionInvocationError("Iterator#hasNext")
    });

    var ArrayIterator = Kotlin.createClass(Kotlin.Iterator,
        function (array) {
            this.array = array;
            this.size = array.length;
            this.index = 0;
        }, {
            next: function () {
                return this.array[this.index++];
            },
            hasNext: function () {
                return this.index < this.size;
            }
    });

    var ListIterator = Kotlin.createClass(ArrayIterator,
        function (list) {
            this.list = list;
            this.size = list.size();
            this.index = 0;
        }, {
            next: function () {
                return this.list.get(this.index++);
            }
    });

    Kotlin.Collection = Kotlin.createClass();

    Kotlin.Enum = Kotlin.createClass(null,
        function () {
            this.name$ = undefined;
            this.ordinal$ = undefined;
        }, {
            name: function () {
                return this.name$;
            },
            ordinal: function () {
                return this.ordinal$;
            },
            toString: function () {
                return this.name();
            }
    });
    (function (){
        function valueOf(name) {
            return this[name];
        }
        function getValues() {
            return this.values$;
        }

        Kotlin.createEnumEntries = function(enumEntryList) {
            var i = 0;
            var values = [];
            for (var entryName in enumEntryList) {
                if (enumEntryList.hasOwnProperty(entryName)) {
                    var entryObject = enumEntryList[entryName];
                    values[i] = entryObject;
                    entryObject.ordinal$ = i;
                    entryObject.name$ = entryName;
                    i++;
                }
            }
            enumEntryList.values$ = values;
            enumEntryList.valueOf = valueOf;
            enumEntryList.values = getValues;
            return enumEntryList;
        };
    })();

    Kotlin.PropertyMetadata = Kotlin.createClass(null,
        function(name) {
            this.name = name;
        }
    );

    Kotlin.AbstractCollection = Kotlin.createClass(Kotlin.Collection, null, {
        size: function () {
            return this.$size;
        },
        addAll: function (collection) {
            var it = collection.iterator();
            var i = this.size();
            while (i-- > 0) {
                this.add(it.next());
            }
        },
        isEmpty: function () {
            return this.size() === 0;
        },
        iterator: function () {
            return new ArrayIterator(this.toArray());
        },
        equals: function (o) {
            if (this.size() !== o.size()) return false;

            var iterator1 = this.iterator();
            var iterator2 = o.iterator();
            var i = this.size();
            while (i-- > 0) {
                if (!Kotlin.equals(iterator1.next(), iterator2.next())) {
                    return false;
                }
            }

            return true;
        },
        toString: function () {
            var builder = "[";
            var iterator = this.iterator();
            var first = true;
            var i = this.$size;
            while (i-- > 0) {
                if (first) {
                    first = false;
                }
                else {
                    builder += ", ";
                }
                builder += iterator.next();
            }
            builder += "]";
            return builder;
        },
        toJSON: function () {
            return this.toArray();
        }
    });

    Kotlin.AbstractList = Kotlin.createClass(Kotlin.AbstractCollection, null, {
        iterator: function () {
            return new ListIterator(this);
        },
        remove: function (o) {
            var index = this.indexOf(o);
            if (index !== -1) {
                this.removeAt(index);
            }
        },
        contains: function (o) {
            return this.indexOf(o) !== -1;
        }
    });

    //TODO: should be JS Array-like (https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Predefined_Core_Objects#Working_with_Array-like_objects)
    Kotlin.ArrayList = Kotlin.createClass(Kotlin.AbstractList,
        function () {
            this.array = [];
            this.$size = 0;
        }, {
            get: function (index) {
                this.checkRange(index);
                return this.array[index];
            },
            set: function (index, value) {
                this.checkRange(index);
                this.array[index] = value;
            },
            size: function () {
                return this.$size;
            },
            iterator: function () {
                return Kotlin.arrayIterator(this.array);
            },
            add: function (element) {
                this.array[this.$size++] = element;
            },
            addAt: function (index, element) {
                this.array.splice(index, 0, element);
                this.$size++;
            },
            addAll: function (collection) {
                var it = collection.iterator();
                for (var i = this.$size, n = collection.size(); n-- > 0;) {
                    this.array[i++] = it.next();
                }

                this.$size += collection.size();
            },
            removeAt: function (index) {
                this.checkRange(index);
                this.$size--;
                return this.array.splice(index, 1)[0];
            },
            clear: function () {
                this.array.length = 0;
                this.$size = 0;
            },
            indexOf: function (o) {
                for (var i = 0, n = this.$size; i < n; ++i) {
                    if (Kotlin.equals(this.array[i], o)) {
                        return i;
                    }
                }
                return -1;
            },
            toArray: function () {
                return this.array.slice(0, this.$size);
            },
            toString: function () {
                return "[" + this.array.join(", ") + "]";
            },
            toJSON: function () {
                return this.array;
            },
            checkRange: function(index) {
                if (index < 0 || index >= this.$size) {
                    throw new RangeError();
                }
            }
    });

    Kotlin.Runnable = Kotlin.createClass(null, null, {
        run: throwAbstractFunctionInvocationError("Runnable#run")
    });

    Kotlin.Comparable = Kotlin.createClass(null, null, {
        compareTo: throwAbstractFunctionInvocationError("Comparable#compareTo")
    });

    Kotlin.Appendable = Kotlin.createClass(null, null, {
        append: throwAbstractFunctionInvocationError("Appendable#append")
    });

    Kotlin.Closeable = Kotlin.createClass(null, null, {
        close: throwAbstractFunctionInvocationError("Closeable#close")
    });

    Kotlin.safeParseInt = function(str) {
        var r = parseInt(str, 10);
        return isNaN(r) ? null : r;
    };

    Kotlin.safeParseDouble = function(str) {
        var r = parseFloat(str);
        return isNaN(r) ? null : r;
    };

    Kotlin.arrayEquals = function (a, b) {
        if (a === b) {
            return true;
        }
        if (!Array.isArray(b) || a.length !== b.length) {
            return false;
        }

        for (var i = 0, n = a.length; i < n; i++) {
            if (!Kotlin.equals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    };

    Kotlin.System = function () {
        var output = "";

        var print = function (obj) {
            if (obj !== undefined) {
                if (obj === null || typeof obj !== "object") {
                    output += obj;
                }
                else {
                    output += obj.toString();
                }
            }
        };
        var println = function (obj) {
            this.print(obj);
            output += "\n";
        };

        return {
            out: function () {
                return {
                    print: print,
                    println: println
                };
            },
            output: function () {
                return output;
            },
            flush: function () {
                output = "";
            }
        };
    }();

    Kotlin.println = function (s) {
        Kotlin.System.out().println(s);
    };

    Kotlin.print = function (s) {
        Kotlin.System.out().print(s);
    };

    Kotlin.RangeIterator = Kotlin.createClass(Kotlin.Iterator,
        function (start, end, increment) {
            this.start = start;
            this.end = end;
            this.increment = increment;
            this.i = start;
        }, {
            next: function () {
                var value = this.i;
                this.i = this.i + this.increment;
                return value;
            },
            hasNext: function () {
                return this.i <= this.end;
            }
    });

    Kotlin.NumberRange = Kotlin.createClass(null,
        function (start, end) {
            this.start = start;
            this.end = end;
            this.increment = 1;
        }, {
            contains: function (number) {
                return this.start <= number && number <= this.end;
            },
            iterator: function () {
                return new Kotlin.RangeIterator(this.start, this.end);
            }
    });

    Kotlin.Progression = Kotlin.createClass(null,
        function (start, end, increment) {
            this.start = start;
            this.end = end;
            this.increment = increment;
        }, {
        iterator: function () {
            return new Kotlin.RangeIterator(this.start, this.end, this.increment);
        }
    });

    Kotlin.Comparator = Kotlin.createClass(null, null, {
        compare: throwAbstractFunctionInvocationError("Comparator#compare")
    });

    var ComparatorImpl = Kotlin.createClass(Kotlin.Comparator,
        function (comparator) {
            this.compare = comparator;
        }
    );

    Kotlin.comparator = function (f) {
        return new ComparatorImpl(f);
    };

    Kotlin.collectionsMax = function (c, comp) {
        if (c.isEmpty()) {
            //TODO: which exception?
            throw new Error();
        }
        var it = c.iterator();
        var max = it.next();
        while (it.hasNext()) {
            var el = it.next();
            if (comp.compare(max, el) < 0) {
                max = el;
            }
        }
        return max;
    };

    Kotlin.collectionsSort = function (mutableList, comparator) {
        var boundComparator = undefined;
        if (comparator !== undefined) {
            boundComparator = comparator.compare.bind(comparator);
        }

        if (mutableList instanceof Array) {
            mutableList.sort(boundComparator);
        }

        //TODO: should be deleted when List will be JS Array-like (https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Predefined_Core_Objects#Working_with_Array-like_objects)
        var array = [];
        var it = mutableList.iterator();
        while (it.hasNext()) {
            array.push(it.next());
        }

        array.sort(boundComparator);

        for (var i = 0, n = array.length; i < n; i++) {
            mutableList.set(i, array[i]);
        }
    };

    Kotlin.copyToArray = function (collection) {
        var array = [];
        var it = collection.iterator();
        while (it.hasNext()) {
            array.push(it.next());
        }

        return array;
    };


    Kotlin.StringBuilder = Kotlin.createClass(null,
        function () {
            this.string = "";
        }, {
        append:function (obj) {
            this.string = this.string + obj.toString();
        },
        toString:function () {
            return this.string;
        }
    });

    Kotlin.splitString = function (str, regex, limit) {
        return str.split(new RegExp(regex), limit);
    };

    Kotlin.nullArray = function (size) {
        var res = [];
        var i = size;
        while (i > 0) {
            res[--i] = null;
        }
        return res;
    };

    Kotlin.numberArrayOfSize = function (size) {
        return Kotlin.arrayFromFun(size, function(){ return 0; });
    };

    Kotlin.charArrayOfSize = function (size) {
        return Kotlin.arrayFromFun(size, function(){ return '\0'; });
    };

    Kotlin.booleanArrayOfSize = function (size) {
        return Kotlin.arrayFromFun(size, function(){ return false; });
    };

    Kotlin.arrayFromFun = function (size, initFun) {
        var result = new Array(size);
        for (var i = 0; i < size; i++) {
            result[i] = initFun(i);
        }
        return result;
    };

    Kotlin.arrayIndices = function (arr) {
        return new Kotlin.NumberRange(0, arr.length - 1);
    };

    Kotlin.arrayIterator = function (array) {
        return new ArrayIterator(array);
    };

    Kotlin.jsonFromTuples = function (pairArr) {
        var i = pairArr.length;
        var res = {};
        while (i > 0) {
            --i;
            res[pairArr[i][0]] = pairArr[i][1];
        }
        return res;
    };

    Kotlin.jsonAddProperties = function (obj1, obj2) {
        for (var p in obj2) {
            if (obj2.hasOwnProperty(p)) {
                obj1[p] = obj2[p];
            }
        }
        return obj1;
    };
})();

Kotlin.assignOwner = function(f, o) {
  f.o = o;
  return f;
};

/*
 * Copyright 2010-2013 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

"use strict";
(function () {
    var FUNCTION = "function";
    var arrayRemoveAt = (typeof Array.prototype.splice == FUNCTION) ?
                        function (arr, idx) {
                            arr.splice(idx, 1);
                        } :

                        function (arr, idx) {
                            var itemsAfterDeleted, i, len;
                            if (idx === arr.length - 1) {
                                arr.length = idx;
                            }
                            else {
                                itemsAfterDeleted = arr.slice(idx + 1);
                                arr.length = idx;
                                for (i = 0, len = itemsAfterDeleted.length; i < len; ++i) {
                                    arr[idx + i] = itemsAfterDeleted[i];
                                }
                            }
                        };

    function hashObject(obj) {
        var hashCode;
        if (typeof obj == "string") {
            return obj;
        }
        else if (typeof obj.hashCode == FUNCTION) {
            // Check the hashCode method really has returned a string
            hashCode = obj.hashCode();
            return (typeof hashCode == "string") ? hashCode : hashObject(hashCode);
        }
        else if (typeof obj.toString == FUNCTION) {
            return obj.toString();
        }
        else {
            try {
                return String(obj);
            }
            catch (ex) {
                // For host objects (such as ActiveObjects in IE) that have no toString() method and throw an error when
                // passed to String()
                return Object.prototype.toString.call(obj);
            }
        }
    }

    function equals_fixedValueHasEquals(fixedValue, variableValue) {
        return fixedValue.equals(variableValue);
    }

    function equals_fixedValueNoEquals(fixedValue, variableValue) {
        return (typeof variableValue.equals == FUNCTION) ?
               variableValue.equals(fixedValue) : (fixedValue === variableValue);
    }

    function createKeyValCheck(kvStr) {
        return function (kv) {
            if (kv === null) {
                throw new Error("null is not a valid " + kvStr);
            }
            else if (typeof kv == "undefined") {
                throw new Error(kvStr + " must not be undefined");
            }
        };
    }

    var checkKey = createKeyValCheck("key"), checkValue = createKeyValCheck("value");

    function Bucket(hash, firstKey, firstValue, equalityFunction) {
        this[0] = hash;
        this.entries = [];
        this.addEntry(firstKey, firstValue);

        if (equalityFunction !== null) {
            this.getEqualityFunction = function () {
                return equalityFunction;
            };
        }
    }

    var EXISTENCE = 0, ENTRY = 1, ENTRY_INDEX_AND_VALUE = 2;

    function createBucketSearcher(mode) {
        return function (key) {
            var i = this.entries.length, entry, equals = this.getEqualityFunction(key);
            while (i--) {
                entry = this.entries[i];
                if (equals(key, entry[0])) {
                    switch (mode) {
                        case EXISTENCE:
                            return true;
                        case ENTRY:
                            return entry;
                        case ENTRY_INDEX_AND_VALUE:
                            return [ i, entry[1] ];
                    }
                }
            }
            return false;
        };
    }

    function createBucketLister(entryProperty) {
        return function (aggregatedArr) {
            var startIndex = aggregatedArr.length;
            for (var i = 0, len = this.entries.length; i < len; ++i) {
                aggregatedArr[startIndex + i] = this.entries[i][entryProperty];
            }
        };
    }

    Bucket.prototype = {
        getEqualityFunction: function (searchValue) {
            return (typeof searchValue.equals == FUNCTION) ? equals_fixedValueHasEquals : equals_fixedValueNoEquals;
        },

        getEntryForKey: createBucketSearcher(ENTRY),

        getEntryAndIndexForKey: createBucketSearcher(ENTRY_INDEX_AND_VALUE),

        removeEntryForKey: function (key) {
            var result = this.getEntryAndIndexForKey(key);
            if (result) {
                arrayRemoveAt(this.entries, result[0]);
                return result[1];
            }
            return null;
        },

        addEntry: function (key, value) {
            this.entries[this.entries.length] = [key, value];
        },

        keys: createBucketLister(0),

        values: createBucketLister(1),

        getEntries: function (entries) {
            var startIndex = entries.length;
            for (var i = 0, len = this.entries.length; i < len; ++i) {
                // Clone the entry stored in the bucket before adding to array
                entries[startIndex + i] = this.entries[i].slice(0);
            }
        },

        containsKey: createBucketSearcher(EXISTENCE),

        containsValue: function (value) {
            var i = this.entries.length;
            while (i--) {
                if (value === this.entries[i][1]) {
                    return true;
                }
            }
            return false;
        }
    };

    /*----------------------------------------------------------------------------------------------------------------*/

    // Supporting functions for searching hashtable buckets

    function searchBuckets(buckets, hash) {
        var i = buckets.length, bucket;
        while (i--) {
            bucket = buckets[i];
            if (hash === bucket[0]) {
                return i;
            }
        }
        return null;
    }

    function getBucketForHash(bucketsByHash, hash) {
        var bucket = bucketsByHash[hash];

        // Check that this is a genuine bucket and not something inherited from the bucketsByHash's prototype
        return ( bucket && (bucket instanceof Bucket) ) ? bucket : null;
    }

    /*----------------------------------------------------------------------------------------------------------------*/

    var Hashtable = function (hashingFunctionParam, equalityFunctionParam) {
        var that = this;
        var buckets = [];
        var bucketsByHash = {};

        var hashingFunction = (typeof hashingFunctionParam == FUNCTION) ? hashingFunctionParam : hashObject;
        var equalityFunction = (typeof equalityFunctionParam == FUNCTION) ? equalityFunctionParam : null;

        this.put = function (key, value) {
            checkKey(key);
            checkValue(value);
            var hash = hashingFunction(key), bucket, bucketEntry, oldValue = null;

            // Check if a bucket exists for the bucket key
            bucket = getBucketForHash(bucketsByHash, hash);
            if (bucket) {
                // Check this bucket to see if it already contains this key
                bucketEntry = bucket.getEntryForKey(key);
                if (bucketEntry) {
                    // This bucket entry is the current mapping of key to value, so replace old value and we're done.
                    oldValue = bucketEntry[1];
                    bucketEntry[1] = value;
                }
                else {
                    // The bucket does not contain an entry for this key, so add one
                    bucket.addEntry(key, value);
                }
            }
            else {
                // No bucket exists for the key, so create one and put our key/value mapping in
                bucket = new Bucket(hash, key, value, equalityFunction);
                buckets[buckets.length] = bucket;
                bucketsByHash[hash] = bucket;
            }
            return oldValue;
        };

        this.get = function (key) {
            checkKey(key);

            var hash = hashingFunction(key);

            // Check if a bucket exists for the bucket key
            var bucket = getBucketForHash(bucketsByHash, hash);
            if (bucket) {
                // Check this bucket to see if it contains this key
                var bucketEntry = bucket.getEntryForKey(key);
                if (bucketEntry) {
                    // This bucket entry is the current mapping of key to value, so return the value.
                    return bucketEntry[1];
                }
            }
            return null;
        };

        this.containsKey = function (key) {
            checkKey(key);
            var bucketKey = hashingFunction(key);

            // Check if a bucket exists for the bucket key
            var bucket = getBucketForHash(bucketsByHash, bucketKey);

            return bucket ? bucket.containsKey(key) : false;
        };

        this.containsValue = function (value) {
            checkValue(value);
            var i = buckets.length;
            while (i--) {
                if (buckets[i].containsValue(value)) {
                    return true;
                }
            }
            return false;
        };

        this.clear = function () {
            buckets.length = 0;
            bucketsByHash = {};
        };

        this.isEmpty = function () {
            return !buckets.length;
        };

        var createBucketAggregator = function (bucketFuncName) {
            return function () {
                var aggregated = [], i = buckets.length;
                while (i--) {
                    buckets[i][bucketFuncName](aggregated);
                }
                return aggregated;
            };
        };

        this._keys = createBucketAggregator("keys");
        this._values = createBucketAggregator("values");
        this._entries = createBucketAggregator("getEntries");

        this.values = function () {
            var values = this._values();
            var i = values.length;
            var result = new Kotlin.ArrayList();
            while (i--) {
                result.add(values[i]);
            }
            return result;
        };

        this.remove = function (key) {
            checkKey(key);

            var hash = hashingFunction(key), bucketIndex, oldValue = null;

            // Check if a bucket exists for the bucket key
            var bucket = getBucketForHash(bucketsByHash, hash);

            if (bucket) {
                // Remove entry from this bucket for this key
                oldValue = bucket.removeEntryForKey(key);
                if (oldValue !== null) {
                    // Entry was removed, so check if bucket is empty
                    if (!bucket.entries.length) {
                        // Bucket is empty, so remove it from the bucket collections
                        bucketIndex = searchBuckets(buckets, hash);
                        arrayRemoveAt(buckets, bucketIndex);
                        delete bucketsByHash[hash];
                    }
                }
            }
            return oldValue;
        };

        this.size = function () {
            var total = 0, i = buckets.length;
            while (i--) {
                total += buckets[i].entries.length;
            }
            return total;
        };

        this.each = function (callback) {
            var entries = that._entries(), i = entries.length, entry;
            while (i--) {
                entry = entries[i];
                callback(entry[0], entry[1]);
            }
        };


        this.putAll = function (hashtable, conflictCallback) {
            var entries = hashtable._entries();
            var entry, key, value, thisValue, i = entries.length;
            var hasConflictCallback = (typeof conflictCallback == FUNCTION);
            while (i--) {
                entry = entries[i];
                key = entry[0];
                value = entry[1];

                // Check for a conflict. The default behaviour is to overwrite the value for an existing key
                if (hasConflictCallback && (thisValue = that.get(key))) {
                    value = conflictCallback(key, thisValue, value);
                }
                that.put(key, value);
            }
        };

        this.clone = function () {
            var clone = new Hashtable(hashingFunctionParam, equalityFunctionParam);
            clone.putAll(that);
            return clone;
        };

        this.keySet = function () {
            var res = new Kotlin.ComplexHashSet();
            var keys = this._keys();
            var i = keys.length;
            while (i--) {
                res.add(keys[i]);
            }
            return res;
        };
    };


    Kotlin.HashTable = Hashtable;
})();

Kotlin.Map = Kotlin.createClass();

Kotlin.HashMap = Kotlin.createClass(Kotlin.Map,
    function () {
        Kotlin.HashTable.call(this);
    }
);

Kotlin.ComplexHashMap = Kotlin.HashMap;

(function () {
    var PrimitiveHashMapValuesIterator = Kotlin.createClass(Kotlin.Iterator,
        function (map, keys) {
            this.map = map;
            this.keys = keys;
            this.size = keys.length;
            this.index = 0;
        }, {
            next: function () {
                return this.map[this.keys[this.index++]];
            },
            hasNext: function () {
                return this.index < this.size;
            }
    });

    var PrimitiveHashMapValues = Kotlin.createClass(Kotlin.Collection,
        function (map) {
            this.map = map;
        }, {
            iterator: function () {
                return new PrimitiveHashMapValuesIterator(this.map.map, Object.keys(this.map.map));
            },
            isEmpty: function () {
                return this.map.$size === 0;
            },
            contains: function (o) {
                return this.map.containsValue(o);
            }
    });

    Kotlin.PrimitiveHashMap = Kotlin.createClass(Kotlin.Map,
        function () {
            this.$size = 0;
            this.map = {};
        }, {
            size: function () {
                return this.$size;
            },
            isEmpty: function () {
                return this.$size === 0;
            },
            containsKey: function (key) {
                return this.map[key] !== undefined;
            },
            containsValue: function (value) {
                var map = this.map;
                for (var key in map) {
                    if (map.hasOwnProperty(key) && map[key] === value) {
                        return true;
                    }
                }

                return false;
            },
            get: function (key) {
                return this.map[key];
            },
            put: function (key, value) {
                var prevValue = this.map[key];
                this.map[key] = value === undefined ? null : value;
                if (prevValue === undefined) {
                    this.$size++;
                }
                return prevValue;
            },
            remove: function (key) {
                var prevValue = this.map[key];
                if (prevValue !== undefined) {
                    delete this.map[key];
                    this.$size--;
                }
                return prevValue;
            },
            clear: function () {
                this.$size = 0;
                this.map = {};
            },
            putAll: function (fromMap) {
                var map = fromMap.map;
                for (var key in map) {
                    if (map.hasOwnProperty(key)) {
                        this.map[key] = map[key];
                        this.$size++;
                    }
                }
            },
            keySet: function () {
                var result = new Kotlin.PrimitiveHashSet();
                var map = this.map;
                for (var key in map) {
                    if (map.hasOwnProperty(key)) {
                        result.add(key);
                    }
                }

                return result;
            },
            values: function () {
                return new PrimitiveHashMapValues(this);
            },
            toJSON: function () {
                return this.map;
            }
    });
}());

Kotlin.Set = Kotlin.createClass(Kotlin.Collection);

Kotlin.PrimitiveHashSet = Kotlin.createClass(Kotlin.AbstractCollection,
    function () {
        this.$size = 0;
        this.map = {};
    }, {
        contains: function (key) {
            return this.map[key] === true;
        },
        add: function (element) {
            var prevElement = this.map[element];
            this.map[element] = true;
            if (prevElement === true) {
                return false;
            }
            else {
                this.$size++;
                return true;
            }
        },
        remove: function (element) {
            if (this.map[element] === true) {
                delete this.map[element];
                this.$size--;
                return true;
            }
            else {
                return false;
            }
        },
        clear: function () {
            this.$size = 0;
            this.map = {};
        },
        toArray: function () {
            return Object.keys(this.map);
        }
});

(function () {
    function HashSet(hashingFunction, equalityFunction) {
        var hashTable = new Kotlin.HashTable(hashingFunction, equalityFunction);

        this.add = function (o) {
            hashTable.put(o, true);
        };

        this.addAll = function (arr) {
            var i = arr.length;
            while (i--) {
                hashTable.put(arr[i], true);
            }
        };

        this.values = function () {
            return hashTable._keys();
        };

        this.iterator = function () {
            return Kotlin.arrayIterator(this.values());
        };

        this.remove = function (o) {
            return hashTable.remove(o) ? o : null;
        };

        this.contains = function (o) {
            return hashTable.containsKey(o);
        };

        this.clear = function () {
            hashTable.clear();
        };

        this.size = function () {
            return hashTable.size();
        };

        this.isEmpty = function () {
            return hashTable.isEmpty();
        };

        this.clone = function () {
            var h = new HashSet(hashingFunction, equalityFunction);
            h.addAll(hashTable.keys());
            return h;
        };

        this.equals = function (o) {
            if (o === null || o === undefined) return false;
            if (this.size() === o.size()) {
                var iter1 = this.iterator();
                var iter2 = o.iterator();
                while (true) {
                    var hn1 = iter1.hasNext();
                    var hn2 = iter2.hasNext();
                    if (hn1 != hn2) return false;
                    if (!hn2)
                        return true;
                    else {
                        var o1 = iter1.next();
                        var o2 = iter2.next();
                        if (!Kotlin.equals(o1, o2)) return false;
                    }
                }
            }
            return false;
        };

        this.toString = function() {
            var builder = "[";
            var iter = this.iterator();
            var first = true;
            while (iter.hasNext()) {
                if (first)
                    first = false;
                else
                    builder += ", ";
                builder += iter.next();
            }
            builder += "]";
            return builder;
        };

        this.intersection = function (hashSet) {
            var intersection = new HashSet(hashingFunction, equalityFunction);
            var values = hashSet.values(), i = values.length, val;
            while (i--) {
                val = values[i];
                if (hashTable.containsKey(val)) {
                    intersection.add(val);
                }
            }
            return intersection;
        };

        this.union = function (hashSet) {
            var union = this.clone();
            var values = hashSet.values(), i = values.length, val;
            while (i--) {
                val = values[i];
                if (!hashTable.containsKey(val)) {
                    union.add(val);
                }
            }
            return union;
        };

        this.isSubsetOf = function (hashSet) {
            var values = hashTable.keys(), i = values.length;
            while (i--) {
                if (!hashSet.contains(values[i])) {
                    return false;
                }
            }
            return true;
        };
    }

    Kotlin.HashSet = Kotlin.createClass(Kotlin.Set,
        function () {
            HashSet.call(this);
        }
    );

    Kotlin.ComplexHashSet = Kotlin.HashSet;
}());

module.exports = Kotlin;
},{}],"kevoree-library":[function(require,module,exports){
module.exports=require('qQyNdC');
},{}],"qQyNdC":[function(require,module,exports){
var Kotlin = require('kevoree-kotlin');

(function () {
  'use strict';
  var _c = function () {
    var KMFContainer = Kotlin.createTrait(null)
    , NamedElement = Kotlin.createTrait(KMFContainer)
    , Instance = Kotlin.createTrait([NamedElement, KMFContainer])
    , TypeDefinition = Kotlin.createTrait([NamedElement, KMFContainer])
    , PortType = Kotlin.createTrait([TypeDefinition, KMFContainer])
    , LifeCycleTypeDefinition = Kotlin.createTrait([TypeDefinition, KMFContainer])
    , ModelLoader = Kotlin.createTrait(null)
    , KMFFactory = Kotlin.createTrait(null)
    , ModelSerializer = Kotlin.createTrait(null)
    , ModelElementListener = Kotlin.createTrait(null)
    , TypedElement = Kotlin.createTrait([NamedElement, KMFContainer])
    , ComponentType = Kotlin.createTrait([LifeCycleTypeDefinition, KMFContainer]);
    return {KMFContainer: KMFContainer, DeployUnit: Kotlin.createTrait(KMFContainer), NamedElement: NamedElement, Instance: Instance, ContainerNode: Kotlin.createTrait([Instance, NamedElement, KMFContainer]), TypeDefinition: TypeDefinition, PortType: PortType, MessagePortType: Kotlin.createTrait([PortType, KMFContainer]), LifeCycleTypeDefinition: LifeCycleTypeDefinition, GroupType: Kotlin.createTrait([LifeCycleTypeDefinition, KMFContainer]), ModelLoader: ModelLoader, KMFFactory: KMFFactory, XMIModelLoader: Kotlin.createClass(ModelLoader, function () {
      this.LOADER_XMI_LOCAL_NAME = 'type';
      this.LOADER_XMI_XSI = 'xsi';
      this.factory = null;
      this.attributesHashmap = new Kotlin.PrimitiveHashMap(0);
      this.referencesHashmap = new Kotlin.PrimitiveHashMap(0);
      this.attributeVisitor = _c.XMIModelLoader.f1(this);
      this.referencesVisitor = _c.XMIModelLoader.f3(this);
    }, /** @lends _c.XMIModelLoader.prototype */ {
      unescapeXml: function (src) {
        var builder = null;
        var i = 0;
        while (i < src.length) {
          var c = src.charAt(i);
          if (c === '&') {
            if (builder == null) {
              builder = new _.java.lang.StringBuilder();
              (builder != null ? builder : Kotlin.throwNPE()).append(src.substring(0, i));
            }
            if (src.charAt(i + 1) === 'a') {
              if (src.charAt(i + 2) === 'm') {
                builder != null ? builder.append('&') : null;
                i = i + 5;
              }
               else if (src.charAt(i + 2) === 'p') {
                builder != null ? builder.append("'") : null;
                i = i + 6;
              }
               else {
                Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1) + src.charAt(i + 2));
              }
            }
             else if (src.charAt(i + 1) === 'q') {
              builder != null ? builder.append('"') : null;
              i = i + 6;
            }
             else if (src.charAt(i + 1) === 'l') {
              builder != null ? builder.append('<') : null;
              i = i + 4;
            }
             else if (src.charAt(i + 1) === 'g') {
              builder != null ? builder.append('>') : null;
              i = i + 4;
            }
             else {
              Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1));
            }
          }
           else {
            if (builder != null) {
              builder != null ? builder.append_0(c) : null;
            }
            i++;
          }
        }
        if (builder != null) {
          return Kotlin.toString(builder);
        }
         else {
          return src;
        }
      },
      loadModelFromString: function (str) {
        var reader = new _.org.kevoree.modeling.api.xmi.XmlParser(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(str));
        if (reader.hasNext()) {
          return this.deserialize(reader);
        }
         else {
          Kotlin.println('Loader::Noting in the String !');
          return null;
        }
      },
      loadModelFromStream: function (inputStream) {
        var reader = new _.org.kevoree.modeling.api.xmi.XmlParser(inputStream);
        if (reader.hasNext()) {
          return this.deserialize(reader);
        }
         else {
          Kotlin.println('Loader::Noting in the file !');
          return null;
        }
      },
      loadObject: function (ctx, xmiAddress, objectType) {
        var tmp$0, tmp$12, tmp$13, tmp$14, tmp$15, tmp$16, tmp$17, tmp$18;
        var elementTagName = ((tmp$0 = ctx.xmiReader) != null ? tmp$0 : Kotlin.throwNPE()).getLocalName();
        var modelElem;
        if (objectType != null) {
          var tmp$1;
          modelElem = (tmp$1 = this.factory) != null ? tmp$1.create(objectType) : null;
          if (modelElem == null) {
            var xsiType = null;
            var tmp$2, tmp$3, tmp$4, tmp$5, tmp$6;
            {
              tmp$3 = new Kotlin.NumberRange(0, ((tmp$2 = ctx.xmiReader) != null ? tmp$2 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$4 = tmp$3.start, tmp$5 = tmp$3.end, tmp$6 = tmp$3.increment;
              for (var i = tmp$4; i <= tmp$5; i += tmp$6) {
                var tmp$7, tmp$8;
                var localName = ((tmp$7 = ctx.xmiReader) != null ? tmp$7 : Kotlin.throwNPE()).getAttributeLocalName(i);
                var xsi = ((tmp$8 = ctx.xmiReader) != null ? tmp$8 : Kotlin.throwNPE()).getAttributePrefix(i);
                if (Kotlin.equals(localName, this.LOADER_XMI_LOCAL_NAME) && Kotlin.equals(xsi, this.LOADER_XMI_XSI)) {
                  var tmp$9;
                  xsiType = ((tmp$9 = ctx.xmiReader) != null ? tmp$9 : Kotlin.throwNPE()).getAttributeValue(i);
                  break;
                }
              }
            }
            if (xsiType != null) {
              var tmp$10;
              modelElem = (tmp$10 = this.factory) != null ? tmp$10.create((xsiType != null ? xsiType : Kotlin.throwNPE()).substring((xsiType != null ? xsiType : Kotlin.throwNPE()).lastIndexOf(':') + 1, (xsiType != null ? xsiType : Kotlin.throwNPE()).length)) : null;
            }
          }
        }
         else {
          var tmp$11;
          modelElem = (tmp$11 = this.factory) != null ? tmp$11.create(elementTagName != null ? elementTagName : Kotlin.throwNPE()) : null;
        }
        if (modelElem == null) {
          Kotlin.println('Could not create an object for local name ' + elementTagName);
        }
        ctx.map.put(xmiAddress, modelElem != null ? modelElem : Kotlin.throwNPE());
        if (!this.attributesHashmap.containsKey((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) {
          modelElem != null ? modelElem.visitAttributes(this.attributeVisitor) : null;
        }
        var elemAttributesMap = (tmp$12 = this.attributesHashmap.get((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) != null ? tmp$12 : Kotlin.throwNPE();
        if (!this.referencesHashmap.containsKey((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) {
          modelElem != null ? modelElem.visit(this.referencesVisitor, false, true, false) : null;
        }
        var elemReferencesMap = (tmp$13 = this.referencesHashmap.get((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) != null ? tmp$13 : Kotlin.throwNPE();
        {
          tmp$15 = new Kotlin.NumberRange(0, ((tmp$14 = ctx.xmiReader) != null ? tmp$14 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$16 = tmp$15.start, tmp$17 = tmp$15.end, tmp$18 = tmp$15.increment;
          for (var i_0 = tmp$16; i_0 <= tmp$17; i_0 += tmp$18) {
            var tmp$19;
            var prefix = ((tmp$19 = ctx.xmiReader) != null ? tmp$19 : Kotlin.throwNPE()).getAttributePrefix(i_0);
            if (prefix == null || Kotlin.equals(prefix, '')) {
              var tmp$20, tmp$21;
              var attrName = ((tmp$20 = ctx.xmiReader) != null ? tmp$20 : Kotlin.throwNPE()).getAttributeLocalName(i_0);
              var valueAtt = ((tmp$21 = ctx.xmiReader) != null ? tmp$21 : Kotlin.throwNPE()).getAttributeValue(i_0);
              if (valueAtt != null) {
                if (elemAttributesMap.containsKey(attrName)) {
                  modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, attrName != null ? attrName : Kotlin.throwNPE(), this.unescapeXml(valueAtt), false, false) : null;
                }
                 else {
                  var tmp$22, tmp$23, tmp$24;
                  {
                    tmp$22 = Kotlin.splitString(valueAtt, ' '), tmp$23 = tmp$22.length;
                    for (var tmp$24 = 0; tmp$24 !== tmp$23; ++tmp$24) {
                      var xmiRef = tmp$22[tmp$24];
                      var tmp$25, tmp$26;
                      if (xmiRef.startsWith('#')) {
                        tmp$25 = xmiRef.substring(1);
                      }
                       else {
                        tmp$25 = xmiRef;
                      }
                      var adjustedRef = tmp$25;
                      if (adjustedRef.startsWith('//')) {
                        tmp$26 = '/0' + adjustedRef.substring(1);
                      }
                       else {
                        tmp$26 = adjustedRef;
                      }
                      adjustedRef = tmp$26;
                      adjustedRef = adjustedRef.replace('.0', '');
                      var ref = ctx.map.get(adjustedRef);
                      if (ref != null) {
                        modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, attrName != null ? attrName : Kotlin.throwNPE(), ref, true, false) : null;
                      }
                       else {
                        ctx.resolvers.add(new _.org.kevoree.modeling.api.xmi.XMIResolveCommand(ctx, modelElem != null ? modelElem : Kotlin.throwNPE(), _.org.kevoree.modeling.api.util.ActionType.ADD, attrName != null ? attrName : Kotlin.throwNPE(), adjustedRef));
                      }
                    }
                  }
                }
              }
            }
          }
        }
        var done = false;
        while (!done) {
          var tmp$27;
          var tmp$28 = ((tmp$27 = ctx.xmiReader) != null ? tmp$27 : Kotlin.throwNPE()).next();
          if (tmp$28 === _.org.kevoree.modeling.api.xmi.Token.START_TAG) {
            var tmp$29, tmp$30, tmp$32;
            var subElemName = ((tmp$29 = ctx.xmiReader) != null ? tmp$29 : Kotlin.throwNPE()).getLocalName();
            var i_1 = (tmp$30 = ctx.elementsCount.get(xmiAddress + '/@' + subElemName)) != null ? tmp$30 : 0;
            var tmp$31 = xmiAddress + '/@' + subElemName;
            if (i_1 !== 0) {
              tmp$32 = '.' + i_1;
            }
             else {
              tmp$32 = '';
            }
            var subElementId = tmp$31 + tmp$32;
            var containedElement = this.loadObject(ctx, subElementId, elemReferencesMap.get(subElemName));
            modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, subElemName != null ? subElemName : Kotlin.throwNPE(), containedElement, true, false) : null;
            ctx.elementsCount.put(xmiAddress + '/@' + subElemName, i_1 + 1);
          }
           else if (tmp$28 === _.org.kevoree.modeling.api.xmi.Token.END_TAG) {
            var tmp$33;
            if (Kotlin.equals(((tmp$33 = ctx.xmiReader) != null ? tmp$33 : Kotlin.throwNPE()).getLocalName(), elementTagName)) {
              done = true;
            }
          }
           else {
          }
        }
        return modelElem != null ? modelElem : Kotlin.throwNPE();
      },
      deserialize: function (reader) {
        var context = new _.org.kevoree.modeling.api.xmi.LoadingContext();
        context.xmiReader = reader;
        while (reader.hasNext()) {
          var nextTag = reader.next();
          if (nextTag === _.org.kevoree.modeling.api.xmi.Token.START_TAG) {
            var localName = reader.getLocalName();
            if (localName != null) {
              var loadedRootsSize = context.loadedRoots.size();
              context.loadedRoots.add(this.loadObject(context, '/' + loadedRootsSize, null));
            }
             else {
              Kotlin.println('Tried to read a tag with null tag_name.');
            }
          }
           else if (nextTag === _.org.kevoree.modeling.api.xmi.Token.END_TAG) {
            break;
          }
           else if (nextTag === _.org.kevoree.modeling.api.xmi.Token.END_DOCUMENT) {
            break;
          }
           else {
          }
        }
        {
          var tmp$0 = context.resolvers.iterator();
          while (tmp$0.hasNext()) {
            var res = tmp$0.next();
            res.run();
          }
        }
        return context.loadedRoots;
      }
    }, /** @lends _c.XMIModelLoader */ {
      f0: function () {
        return new Kotlin.PrimitiveHashMap(0);
      },
      f1: function ($outer) {
        return Kotlin.createObject(_c.ModelAttributeVisitor, null, {
          visit: function (value, name, parent) {
            _.kotlin.getOrPut($outer.attributesHashmap, parent.metaClassName(), _c.XMIModelLoader.f0).put(name, true);
          }
        });
      },
      f2: function () {
        return new Kotlin.PrimitiveHashMap(0);
      },
      f3: function ($outer) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
          this.refMap = null;
        }, {
          beginVisitElem: function (elem) {
            this.refMap = _.kotlin.getOrPut($outer.referencesHashmap, elem.metaClassName(), _c.XMIModelLoader.f2);
          },
          endVisitElem: function (elem) {
            this.refMap = null;
          },
          beginVisitRef: function (refName, refType) {
            var tmp$0;
            ((tmp$0 = this.refMap) != null ? tmp$0 : Kotlin.throwNPE()).put(refName, refType);
          },
          visit: function (elem, refNameInParent, parent) {
          }
        });
      }
    }), ModelSerializer: ModelSerializer, XMIModelSerializer: Kotlin.createClass(ModelSerializer, null, /** @lends _c.XMIModelSerializer.prototype */ {
      serialize: function (oMS) {
        var oo = new _.java.io.ByteArrayOutputStream();
        this.serializeToStream(oMS, oo);
        oo.flush();
        return oo.toString();
      },
      serializeToStream: function (oMS, ostream) {
        var wt = new _.java.io.PrintStream(new _.java.io.BufferedOutputStream(ostream), false);
        var addressTable = new Kotlin.ComplexHashMap(0);
        var packageList = new Kotlin.ArrayList(0);
        addressTable.put(oMS, '/');
        var elementsCount = new Kotlin.PrimitiveHashMap(0);
        var addressBuilderVisitor = new _.org.kevoree.modeling.api.xmi.ModelAddressVisitor(addressTable, elementsCount, packageList);
        oMS.visit(addressBuilderVisitor, true, true, false);
        var masterVisitor = new _.org.kevoree.modeling.api.xmi.ModelSerializationVisitor(wt, addressTable, elementsCount);
        wt.println_0('<?xml version="1.0" encoding="UTF-8"?>');
        wt.print('<' + this.formatMetaClassName(oMS.metaClassName()).replace('.', '_'));
        wt.print(' xmlns:xsi="http://wwww.w3.org/2001/XMLSchema-instance"');
        wt.print(' xmi:version="2.0"');
        wt.print(' xmlns:xmi="http://www.omg.org/XMI"');
        var index = 0;
        while (index < _.kotlin.get_size_1(packageList)) {
          wt.print(' xmlns:' + packageList.get(index).replace('.', '_') + '="http://' + packageList.get(index) + '"');
          index++;
        }
        oMS.visitAttributes(new _.org.kevoree.modeling.api.xmi.AttributesVisitor(wt));
        oMS.visit(new _.org.kevoree.modeling.api.xmi.ReferencesVisitor(wt, addressTable, elementsCount), false, false, true);
        wt.println_0('>');
        oMS.visit(masterVisitor, false, true, false);
        wt.println_0('<\/' + this.formatMetaClassName(oMS.metaClassName()).replace('.', '_') + '>');
        wt.flush();
      },
      formatMetaClassName: function (metaClassName) {
        var lastPoint = _.js.lastIndexOf(metaClassName, '.');
        var pack = metaClassName.substring(0, lastPoint);
        var cls = metaClassName.substring(lastPoint + 1);
        return pack + ':' + cls;
      }
    }), ModelCloner: Kotlin.createTrait(null, /** @lends _c.ModelCloner.prototype */ {
      clone: function (o) {
        return this.clone_0(o, false);
      },
      clone_0: function (o, readOnly) {
        return this.clone_1(o, readOnly, false);
      },
      cloneMutableOnly: function (o, readOnly) {
        return this.clone_1(o, readOnly, true);
      },
      cloneModelElem: function (src) {
        var tmp$0;
        var clonedSrc = (tmp$0 = this.mainFactory.create(src.metaClassName())) != null ? tmp$0 : Kotlin.throwNPE();
        var attributesCloner = _c.ModelCloner.f0(clonedSrc);
        src.visitAttributes(attributesCloner);
        return clonedSrc;
      },
      resolveModelElem: function (src, target, context, mutableOnly) {
        var refResolver = _c.ModelCloner.f1(mutableOnly, target, context);
        src.visit(refResolver, false, true, true);
      },
      clone_1: function (o, readOnly, mutableOnly) {
        var context = this.createContext();
        var clonedObject = this.cloneModelElem(o);
        context.put(o, clonedObject);
        var cloneGraphVisitor = _c.ModelCloner.f2(this, mutableOnly, context);
        o.visit(cloneGraphVisitor, true, true, false);
        var resolveGraphVisitor = _c.ModelCloner.f3(this, mutableOnly, context, readOnly);
        o.visit(resolveGraphVisitor, true, true, false);
        this.resolveModelElem(o, clonedObject, context, mutableOnly);
        if (readOnly) {
          clonedObject.setInternalReadOnly();
        }
        return clonedObject != null ? clonedObject : Kotlin.throwNPE();
      }
    }, /** @lends _c.ModelCloner */ {
      f0: function (clonedSrc) {
        return Kotlin.createObject(_c.ModelAttributeVisitor, null, {
          visit: function (value, name, parent) {
            if (value != null) {
              clonedSrc.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, name, value, false, false);
            }
          }
        });
      },
      f1: function (mutableOnly, target, context) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            if (mutableOnly && elem.isRecursiveReadOnly()) {
              target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, refNameInParent, elem, false, false);
            }
             else {
              target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, refNameInParent, context.get(elem), false, false);
            }
          }
        });
      },
      f2: function ($outer, mutableOnly, context) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            if (mutableOnly && elem.isRecursiveReadOnly()) {
              this.noChildrenVisit();
            }
             else {
              context.put(elem, $outer.cloneModelElem(elem));
            }
          }
        });
      },
      f3: function ($outer, mutableOnly, context, readOnly) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            if (mutableOnly && elem.isRecursiveReadOnly()) {
            }
             else {
              var tmp$0;
              var clonedObj = (tmp$0 = context.get(elem)) != null ? tmp$0 : Kotlin.throwNPE();
              $outer.resolveModelElem(elem, clonedObj, context, mutableOnly);
              if (readOnly) {
                clonedObj.setInternalReadOnly();
              }
            }
          }
        });
      }
    }), ModelCompare: Kotlin.createTrait(null, /** @lends _c.ModelCompare.prototype */ {
      diff: function (origin, target) {
        return this.createSequence().populate(this.internal_diff(origin, target, false, false));
      },
      merge: function (origin, target) {
        return this.createSequence().populate(this.internal_diff(origin, target, false, true));
      },
      inter: function (origin, target) {
        return this.createSequence().populate(this.internal_diff(origin, target, true, false));
      },
      internal_diff: function (origin, target, inter, merge) {
        var traces = new Kotlin.ArrayList(0);
        var tracesRef = new Kotlin.ArrayList(0);
        var objectsMap = new Kotlin.PrimitiveHashMap(0);
        traces.addAll(origin.createTraces(target, inter, merge, false, true));
        tracesRef.addAll(origin.createTraces(target, inter, merge, true, false));
        var visitor = _c.ModelCompare.f0(objectsMap);
        origin.visit(visitor, true, true, false);
        var visitor2 = _c.ModelCompare.f1(objectsMap, inter, traces, merge, tracesRef);
        target.visit(visitor2, true, true, false);
        if (!inter) {
          if (!merge) {
            {
              var tmp$0 = objectsMap.values().iterator();
              while (tmp$0.hasNext()) {
                var diffChild = tmp$0.next();
                var tmp$3, tmp$5, tmp$6;
                if (diffChild.eContainer() != null) {
                  var tmp$1, tmp$2;
                  tmp$3 = (tmp$2 = ((tmp$1 = diffChild.eContainer()) != null ? tmp$1 : Kotlin.throwNPE()).path()) != null ? tmp$2 : Kotlin.throwNPE();
                }
                 else {
                  tmp$3 = 'null';
                }
                var src = tmp$3;
                if (diffChild.getRefInParent() != null) {
                  var tmp$4;
                  tmp$5 = (tmp$4 = diffChild.getRefInParent()) != null ? tmp$4 : Kotlin.throwNPE();
                }
                 else {
                  tmp$5 = 'null';
                }
                var refNameInParent = tmp$5;
                traces.add(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace(src, refNameInParent, (tmp$6 = (diffChild != null ? diffChild : Kotlin.throwNPE()).path()) != null ? tmp$6 : Kotlin.throwNPE()));
              }
            }
          }
        }
        traces.addAll(tracesRef);
        return traces;
      }
    }, /** @lends _c.ModelCompare */ {
      f0: function (objectsMap) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            var childPath = elem.path();
            if (childPath != null) {
              objectsMap.put(childPath, elem);
            }
             else {
              throw new Error('Null child path ' + elem);
            }
          }
        });
      },
      f1: function (objectsMap, inter, traces, merge, tracesRef) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            var childPath = elem.path();
            if (childPath != null) {
              if (objectsMap.containsKey(childPath)) {
                if (inter) {
                  var tmp$0;
                  traces.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$0 = parent.path()) != null ? tmp$0 : Kotlin.throwNPE(), refNameInParent, elem.path(), elem.metaClassName()));
                }
                var tmp$1, tmp$2;
                traces.addAll(((tmp$1 = objectsMap.get(childPath)) != null ? tmp$1 : Kotlin.throwNPE()).createTraces(elem, inter, merge, false, true));
                tracesRef.addAll(((tmp$2 = objectsMap.get(childPath)) != null ? tmp$2 : Kotlin.throwNPE()).createTraces(elem, inter, merge, true, false));
                objectsMap.remove(childPath);
              }
               else {
                if (!inter) {
                  var tmp$3;
                  traces.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$3 = parent.path()) != null ? tmp$3 : Kotlin.throwNPE(), refNameInParent, elem.path(), elem.metaClassName()));
                  traces.addAll(elem.createTraces(elem, true, merge, false, true));
                  tracesRef.addAll(elem.createTraces(elem, true, merge, true, false));
                }
              }
            }
             else {
              throw new Error('Null child path ' + elem);
            }
          }
        });
      }
    }), JSONModelLoader: Kotlin.createClass(ModelLoader, function () {
      this.factory = null;
    }, /** @lends _c.JSONModelLoader.prototype */ {
      loadModelFromString: function (str) {
        return this.deserialize(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(str));
      },
      loadModelFromStream: function (inputStream) {
        return this.deserialize(inputStream);
      },
      deserialize: function (instream) {
        var resolverCommands = new Kotlin.ArrayList(0);
        var roots = new Kotlin.ArrayList(0);
        var lexer = new _.org.kevoree.modeling.api.json.Lexer(instream);
        var currentToken = lexer.nextToken();
        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
          this.loadObject(lexer, null, null, roots, resolverCommands);
        }
         else {
          throw new Error('Bad Format / {\xA0expected');
        }
        {
          var tmp$0 = resolverCommands.iterator();
          while (tmp$0.hasNext()) {
            var resol = tmp$0.next();
            resol.run();
          }
        }
        return roots;
      },
      loadObject: function (lexer, nameInParent, parent, roots, commands) {
        var currentToken = lexer.nextToken();
        var currentObject = null;
        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
          if (Kotlin.equals(currentToken.value, 'eClass')) {
            lexer.nextToken();
            currentToken = lexer.nextToken();
            var tmp$0, tmp$1;
            var name = (tmp$0 = Kotlin.toString(currentToken.value)) != null ? tmp$0 : Kotlin.throwNPE();
            currentObject = (tmp$1 = this.factory) != null ? tmp$1.create(name) : null;
            if (parent == null) {
              roots.add(currentObject != null ? currentObject : Kotlin.throwNPE());
            }
            var currentNameAttOrRef = null;
            var refModel = false;
            currentToken = lexer.nextToken();
            while (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.EOF) {
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                this.loadObject(lexer, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), currentObject, roots, commands);
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.COMMA) {
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                if (currentNameAttOrRef == null) {
                  currentNameAttOrRef = Kotlin.toString(currentToken.value);
                }
                 else {
                  if (refModel) {
                    var tmp$2;
                    commands.add(new _.org.kevoree.modeling.api.json.ResolveCommand(roots, Kotlin.toString((tmp$2 = currentToken.value) != null ? tmp$2 : Kotlin.throwNPE()), currentObject != null ? currentObject : Kotlin.throwNPE(), currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE()));
                  }
                   else {
                    (currentObject != null ? currentObject : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), this.unescapeJSON(Kotlin.toString(currentToken.value)), false, false);
                    currentNameAttOrRef = null;
                  }
                }
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET) {
                currentToken = lexer.nextToken();
                if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                  this.loadObject(lexer, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), currentObject, roots, commands);
                }
                 else {
                  refModel = true;
                  if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                    var tmp$3;
                    commands.add(new _.org.kevoree.modeling.api.json.ResolveCommand(roots, Kotlin.toString((tmp$3 = currentToken.value) != null ? tmp$3 : Kotlin.throwNPE()), currentObject != null ? currentObject : Kotlin.throwNPE(), currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE()));
                  }
                }
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET) {
                currentNameAttOrRef = null;
                refModel = false;
              }
              if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE) {
                if (parent != null) {
                  parent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, nameInParent != null ? nameInParent : Kotlin.throwNPE(), currentObject, false, false);
                }
                return;
              }
              currentToken = lexer.nextToken();
            }
          }
           else {
            throw new Error('Bad Format / eClass att must be first');
          }
        }
         else {
          throw new Error('Bad Format');
        }
      },
      unescapeJSON: function (src) {
        var builder = null;
        var i = 0;
        while (i < src.length) {
          var c = src.charAt(i);
          if (c === '&') {
            if (builder == null) {
              builder = src.substring(0, i);
            }
            if (src.charAt(i + 1) === 'a') {
              builder = (builder != null ? builder : Kotlin.throwNPE()) + "'";
              i = i + 6;
            }
             else if (src.charAt(i + 1) === 'q') {
              builder = (builder != null ? builder : Kotlin.throwNPE()) + '"';
              i = i + 6;
            }
             else {
              Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1));
            }
          }
           else {
            if (builder != null) {
              builder = (builder != null ? builder : Kotlin.throwNPE()) + c;
            }
            i++;
          }
        }
        if (builder != null) {
          return builder != null ? builder : Kotlin.throwNPE();
        }
         else {
          return src;
        }
      }
    }), JSONModelSerializer: Kotlin.createClass(ModelSerializer, null, /** @lends _c.JSONModelSerializer.prototype */ {
      serialize: function (model) {
        var outstream = new _.java.io.ByteArrayOutputStream();
        this.serializeToStream(model, outstream);
        outstream.close();
        return outstream.toString();
      },
      serializeToStream: function (model, raw) {
        var out = new _.java.io.PrintStream(new _.java.io.BufferedOutputStream(raw), false);
        var internalReferenceVisitor = new _.org.kevoree.modeling.api.json.ModelReferenceVisitor(out);
        var masterVisitor = _c.JSONModelSerializer.f0(this, out, internalReferenceVisitor);
        model.visit(masterVisitor, true, true, false);
        out.flush();
      },
      printAttName: function (elem, out) {
        out.print('\n{"eClass":"' + elem.metaClassName() + '"');
        var attributeVisitor = _c.JSONModelSerializer.f1(this, out);
        elem.visitAttributes(attributeVisitor);
      },
      escapeJson: function (ostream, chain) {
        if (chain == null) {
          return;
        }
        var i = 0;
        while (i < chain.length) {
          var c = chain.charAt(i);
          if (c === '"') {
            ostream.print('&quot;');
          }
           else if (c === "'") {
            ostream.print('&apos;');
          }
           else {
            ostream.print_0(c);
          }
          i = i + 1;
        }
      }
    }, /** @lends _c.JSONModelSerializer */ {
      f0: function ($outer, out, internalReferenceVisitor) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
          this.isFirstInRef = true;
        }, {
          beginVisitElem: function (elem) {
            if (!this.isFirstInRef) {
              out.print(',');
              this.isFirstInRef = false;
            }
            $outer.printAttName(elem, out);
            var tmp$0;
            (tmp$0 = internalReferenceVisitor.alreadyVisited) != null ? tmp$0.clear() : null;
            elem.visit(internalReferenceVisitor, false, false, true);
          },
          endVisitElem: function (elem) {
            out.println_0('}');
            this.isFirstInRef = false;
          },
          beginVisitRef: function (refName, refType) {
            out.print(',"' + refName + '":[');
            this.isFirstInRef = true;
          },
          endVisitRef: function (refName) {
            out.print(']');
            this.isFirstInRef = false;
          },
          visit: function (elem, refNameInParent, parent) {
          }
        });
      },
      f1: function ($outer, out) {
        return Kotlin.createObject(_c.ModelAttributeVisitor, null, {
          visit: function (value, name, parent) {
            if (value != null) {
              out.print(',"' + name + '":"');
              if (Kotlin.isType(value, Date)) {
                $outer.escapeJson(out, '' + value.getTime());
              }
               else {
                $outer.escapeJson(out, Kotlin.toString(value));
              }
              out.print('"');
            }
          }
        });
      }
    }), ModelElementListener: ModelElementListener, ModelTreeListener: Kotlin.createTrait(ModelElementListener), TraceConverter: Kotlin.createTrait(null), ModelTrace: Kotlin.createTrait(null), TraceSequence: Kotlin.createTrait(null, /** @lends _c.TraceSequence.prototype */ {
      populate: function (addtraces) {
        this.traces.addAll(addtraces);
        return this;
      },
      populateFromString: function (addtracesTxt) {
        return this.populateFromStream(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(addtracesTxt));
      },
      populateFromStream: function (inputStream) {
        var lexer = new _.org.kevoree.modeling.api.json.Lexer(inputStream);
        var currentToken = lexer.nextToken();
        if (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET) {
          throw new Error('Bad Format : expect [');
        }
        currentToken = lexer.nextToken();
        var keys = new Kotlin.PrimitiveHashMap(0);
        var previousName = null;
        while (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.EOF && currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET) {
          if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
            keys.clear();
          }
          if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
            if (previousName != null) {
              keys.put(previousName != null ? previousName : Kotlin.throwNPE(), Kotlin.toString(currentToken.value));
              previousName = null;
            }
             else {
              previousName = Kotlin.toString(currentToken.value);
            }
          }
          if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE) {
            var tmp$0;
            var tmp$1 = (tmp$0 = keys.get('traceType')) != null ? tmp$0 : Kotlin.throwNPE();
            if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.SET)) {
              var tmp$2, tmp$3;
              this.traces.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$2 = keys.get('src')) != null ? tmp$2 : Kotlin.throwNPE(), (tmp$3 = keys.get('refname')) != null ? tmp$3 : Kotlin.throwNPE(), keys.get('objpath'), keys.get('content'), keys.get('typename')));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.ADD)) {
              var tmp$4, tmp$5, tmp$6;
              this.traces.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$4 = keys.get('src')) != null ? tmp$4 : Kotlin.throwNPE(), (tmp$5 = keys.get('refname')) != null ? tmp$5 : Kotlin.throwNPE(), (tmp$6 = keys.get('previouspath')) != null ? tmp$6 : Kotlin.throwNPE(), keys.get('typename')));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.ADD_ALL)) {
              var tmp$7, tmp$8, tmp$9, tmp$10, tmp$11, tmp$12;
              this.traces.add(new _.org.kevoree.modeling.api.trace.ModelAddAllTrace((tmp$7 = keys.get('src')) != null ? tmp$7 : Kotlin.throwNPE(), (tmp$8 = keys.get('refname')) != null ? tmp$8 : Kotlin.throwNPE(), (tmp$10 = (tmp$9 = keys.get('content')) != null ? Kotlin.splitString(tmp$9, ';') : null) != null ? _.kotlin.toList_8(tmp$10) : null, (tmp$12 = (tmp$11 = keys.get('typename')) != null ? Kotlin.splitString(tmp$11, ';') : null) != null ? _.kotlin.toList_8(tmp$12) : null));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.REMOVE)) {
              var tmp$13, tmp$14, tmp$15;
              this.traces.add(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$13 = keys.get('src')) != null ? tmp$13 : Kotlin.throwNPE(), (tmp$14 = keys.get('refname')) != null ? tmp$14 : Kotlin.throwNPE(), (tmp$15 = keys.get('objpath')) != null ? tmp$15 : Kotlin.throwNPE()));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL)) {
              var tmp$16, tmp$17;
              this.traces.add(new _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace((tmp$16 = keys.get('src')) != null ? tmp$16 : Kotlin.throwNPE(), (tmp$17 = keys.get('refname')) != null ? tmp$17 : Kotlin.throwNPE()));
            }
             else if (tmp$1 === Kotlin.toString(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX)) {
            }
             else {
              Kotlin.println('Trace lost !!!');
            }
          }
          currentToken = lexer.nextToken();
        }
        return this;
      },
      exportToString: function () {
        var buffer = new _.java.lang.StringBuilder();
        buffer.append('[');
        var isFirst = true;
        {
          var tmp$0 = this.traces.iterator();
          while (tmp$0.hasNext()) {
            var trace = tmp$0.next();
            if (!isFirst) {
              buffer.append(',');
            }
            buffer.append(trace.toString());
            isFirst = false;
          }
        }
        buffer.append(']');
        return buffer.toString();
      },
      applyOn: function (target) {
        var tmp$0;
        var traceApplicator = new _.org.kevoree.modeling.api.trace.ModelTraceApplicator(target, (tmp$0 = this.factory) != null ? tmp$0 : Kotlin.throwNPE());
        traceApplicator.applyTraceOnModel(this);
        return true;
      }
    }), ModelVisitor: Kotlin.createClass(null, function () {
      this.visitStopped = false;
      this.visitChildren = true;
      this.alreadyVisited = null;
    }, /** @lends _c.ModelVisitor.prototype */ {
      stopVisit: function () {
        this.visitStopped = true;
      },
      noChildrenVisit: function () {
        this.visitChildren = true;
      },
      beginVisitElem: function (elem) {
      },
      endVisitElem: function (elem) {
      },
      beginVisitRef: function (refName, refType) {
      },
      endVisitRef: function (refName) {
      }
    }), ModelAttributeVisitor: Kotlin.createTrait(null), Wire: Kotlin.createTrait(KMFContainer), Repository: Kotlin.createTrait(KMFContainer), NetworkProperty: Kotlin.createTrait([NamedElement, KMFContainer]), ServicePortType: Kotlin.createTrait([PortType, KMFContainer]), ChannelType: Kotlin.createTrait([LifeCycleTypeDefinition, KMFContainer]), AdaptationPrimitiveTypeRef: Kotlin.createTrait(KMFContainer), ContainerRoot: Kotlin.createTrait(KMFContainer), Channel: Kotlin.createTrait([Instance, NamedElement, KMFContainer]), KMFContainerImpl: Kotlin.createTrait(KMFContainer, /** @lends _c.KMFContainerImpl.prototype */ {
      eContainer: function () {
        return this.internal_eContainer;
      },
      setRecursiveReadOnly: function () {
        if (Kotlin.equals(this.internal_recursive_readOnlyElem, true)) {
          return;
        }
        this.setInternalRecursiveReadOnly();
        var recVisitor = _c.KMFContainerImpl.f0();
        this.visit(recVisitor, true, true, true);
        this.setInternalReadOnly();
      },
      setInternalReadOnly: function () {
        this.internal_readOnlyElem = true;
      },
      setInternalRecursiveReadOnly: function () {
        this.internal_recursive_readOnlyElem = true;
      },
      getRefInParent: function () {
        return this.internal_containmentRefName;
      },
      isReadOnly: function () {
        return this.internal_readOnlyElem;
      },
      isRecursiveReadOnly: function () {
        return this.internal_recursive_readOnlyElem;
      },
      setEContainer: function (container, unsetCmd, refNameInParent) {
        if (this.internal_readOnlyElem) {
          return;
        }
        var tempUnsetCmd = this.internal_unsetCmd;
        this.internal_unsetCmd = null;
        if (tempUnsetCmd != null) {
          tempUnsetCmd.run();
        }
        this.internal_eContainer = container;
        this.internal_unsetCmd = unsetCmd;
        this.internal_containmentRefName = refNameInParent;
        this.path_cache = null;
        this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
      },
      selectByQuery: function (query) {
        throw new Error('Not activated, please add selector option in KMF generation plugin');
      },
      fireModelEvent: function (evt) {
        if (this.internal_modelElementListeners != null) {
          var tmp$0;
          {
            var tmp$1 = ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).iterator();
            while (tmp$1.hasNext()) {
              var lst = tmp$1.next();
              lst.elementChanged(evt);
            }
          }
        }
        this.fireModelEventOnTree(evt);
      },
      addModelElementListener: function (lst) {
        if (this.internal_modelElementListeners == null) {
          this.internal_modelElementListeners = new Kotlin.ArrayList(0);
        }
        var tmp$0;
        ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).add(lst);
      },
      removeModelElementListener: function (lst) {
        if (this.internal_modelElementListeners != null) {
          var tmp$0, tmp$1;
          ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).remove(lst);
          if (((tmp$1 = this.internal_modelElementListeners) != null ? tmp$1 : Kotlin.throwNPE()).isEmpty()) {
            this.internal_modelElementListeners = null;
          }
        }
      },
      removeAllModelElementListeners: function () {
        if (this.internal_modelElementListeners != null) {
          var tmp$0;
          ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).clear();
          this.internal_modelElementListeners = null;
        }
      },
      fireModelEventOnTree: function (evt) {
        if (this.internal_modelTreeListeners != null) {
          var tmp$0;
          {
            var tmp$1 = ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).iterator();
            while (tmp$1.hasNext()) {
              var lst = tmp$1.next();
              lst.elementChanged(evt);
            }
          }
        }
        if (this.eContainer() != null) {
          var tmp$2;
          ((tmp$2 = this.eContainer()) != null ? tmp$2 : Kotlin.throwNPE()).fireModelEventOnTree(evt);
        }
      },
      addModelTreeListener: function (lst) {
        if (this.internal_modelTreeListeners == null) {
          this.internal_modelTreeListeners = new Kotlin.ArrayList(0);
        }
        var tmp$0;
        ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).add(lst);
      },
      removeModelTreeListener: function (lst) {
        if (this.internal_modelTreeListeners != null) {
          var tmp$0, tmp$1;
          ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).remove(lst);
          if (((tmp$1 = this.internal_modelTreeListeners) != null ? tmp$1 : Kotlin.throwNPE()).isEmpty()) {
            this.internal_modelTreeListeners = null;
          }
        }
      },
      removeAllModelTreeListeners: function () {
        if (this.internal_modelTreeListeners != null) {
          var tmp$0;
          ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).clear();
          this.internal_modelElementListeners = null;
        }
      },
      visit: function (visitor, recursive, containedReference, nonContainedReference) {
      },
      visitAttributes: function (visitor) {
      },
      internal_visit: function (visitor, internalElem, recursive, containedReference, nonContainedReference, refName) {
        if (internalElem != null) {
          if (nonContainedReference && recursive) {
            var tmp$0, tmp$1, tmp$2;
            var elemPath = (tmp$0 = internalElem.path()) != null ? tmp$0 : Kotlin.throwNPE();
            if (visitor.alreadyVisited != null && ((tmp$1 = visitor.alreadyVisited) != null ? tmp$1 : Kotlin.throwNPE()).containsKey(elemPath)) {
              return;
            }
            if (visitor.alreadyVisited == null) {
              visitor.alreadyVisited = new Kotlin.PrimitiveHashMap(0);
            }
            ((tmp$2 = visitor.alreadyVisited) != null ? tmp$2 : Kotlin.throwNPE()).put(elemPath, internalElem);
          }
          visitor.visit(internalElem, refName, this);
          if (!visitor.visitStopped) {
            if (recursive && visitor.visitChildren) {
              internalElem.visit(visitor, recursive, containedReference, nonContainedReference);
            }
            visitor.visitChildren = true;
          }
        }
      },
      path: function () {
        if (this.path_cache != null) {
          return this.path_cache;
        }
        var container = this.eContainer();
        if (container != null) {
          var parentPath = container.path();
          if (parentPath == null) {
            return null;
          }
           else {
            var tmp$0;
            if (Kotlin.equals(parentPath, '')) {
              tmp$0 = '';
            }
             else {
              tmp$0 = parentPath + '/';
            }
            this.path_cache = tmp$0 + this.internal_containmentRefName + '[' + this.internalGetKey() + ']';
          }
        }
         else {
          this.path_cache = '';
        }
        return this.path_cache;
      },
      modelEquals: function (similarObj) {
        if (similarObj == null) {
          return false;
        }
        if (Kotlin.equals(this, similarObj)) {
          return true;
        }
        if (!Kotlin.equals(similarObj.metaClassName(), this.metaClassName())) {
          return false;
        }
        var values = new Kotlin.PrimitiveHashMap(0);
        var attVisitor = _c.KMFContainerImpl.f1(values);
        this.visitAttributes(attVisitor);
        similarObj.visitAttributes(attVisitor);
        if (!values.isEmpty()) {
          return false;
        }
        var payload = '';
        var refVisitor = _c.KMFContainerImpl.f2(values, payload);
        this.visit(refVisitor, false, false, true);
        similarObj.visit(refVisitor, false, false, true);
        if (!values.isEmpty()) {
          return false;
        }
        return true;
      },
      deepModelEquals: function (similarObj) {
        if (!this.modelEquals(similarObj)) {
          return false;
        }
        var similarRoot = similarObj != null ? similarObj : Kotlin.throwNPE();
        while (similarRoot.eContainer() != null) {
          var tmp$0;
          similarRoot = (tmp$0 = similarRoot.eContainer()) != null ? tmp$0 : Kotlin.throwNPE();
        }
        var resultTest = {v: true};
        var finalRoot = similarRoot;
        var objVisitor = _c.KMFContainerImpl.f3(finalRoot, resultTest);
        this.visit(objVisitor, true, true, false);
        return resultTest.v;
      },
      findByPath: function (query) {
        var firstSepIndex = _.js.indexOf(query, '[');
        if (firstSepIndex === -1) {
          if (query.length === 0) {
            return this;
          }
           else {
            return null;
          }
        }
        var queryID = '';
        var extraReadChar = 2;
        var relationName = query.substring(0, _.js.indexOf(query, '['));
        if (_.js.indexOf(query, '{') === firstSepIndex + 1) {
          queryID = query.substring(_.js.indexOf(query, '{') + 1, _.js.indexOf(query, '}'));
          extraReadChar = extraReadChar + 2;
        }
         else {
          var indexFirstClose = _.js.indexOf(query, ']');
          while (indexFirstClose + 1 < query.length && query.charAt(indexFirstClose + 1) !== '/') {
            indexFirstClose = _.js.indexOf_0(query, ']', indexFirstClose + 1);
          }
          queryID = query.substring(_.js.indexOf(query, '[') + 1, indexFirstClose);
        }
        var subquery = query.substring(relationName.length + queryID.length + extraReadChar, query.length);
        if (_.js.indexOf(subquery, '/') !== -1) {
          subquery = subquery.substring(_.js.indexOf(subquery, '/') + 1, subquery.length);
        }
        var objFound = this.findByID(relationName, queryID);
        if (!Kotlin.equals(subquery, '') && objFound != null) {
          return objFound.findByPath(subquery);
        }
         else {
          return objFound;
        }
      },
      createTraces: function (similarObj, isInter, isMerge, onlyReferences, onlyAttributes) {
        var traces = new Kotlin.ArrayList(0);
        var values = new Kotlin.PrimitiveHashMap(0);
        if (onlyAttributes) {
          var attVisitorFill = _c.KMFContainerImpl.f4(values);
          this.visitAttributes(attVisitorFill);
          var attVisitor = _c.KMFContainerImpl.f5(this, values, isInter, traces);
          if (similarObj != null) {
            similarObj.visitAttributes(attVisitor);
          }
          if (!isInter && !isMerge && _.kotlin.get_size(values) !== 0) {
            {
              var tmp$0 = values.keySet().iterator();
              while (tmp$0.hasNext()) {
                var hashLoopRes = tmp$0.next();
                var tmp$1;
                traces.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$1 = this.path()) != null ? tmp$1 : Kotlin.throwNPE(), hashLoopRes, null, null, null));
              }
            }
          }
        }
        if (onlyReferences) {
          var payload = '';
          var refVisitorFill = _c.KMFContainerImpl.f6(values, payload);
          this.visit(refVisitorFill, false, false, true);
          var refVisitor = _c.KMFContainerImpl.f7(this, values, isInter, traces);
          if (similarObj != null) {
            similarObj.visit(refVisitor, false, false, true);
          }
          if (!isInter && !isMerge && _.kotlin.get_size(values) !== 0) {
            {
              var tmp$2 = values.keySet().iterator();
              while (tmp$2.hasNext()) {
                var hashLoopRes_0 = tmp$2.next();
                var splittedVal = Kotlin.splitString(hashLoopRes_0, '_');
                var tmp$3;
                traces.add(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$3 = this.path()) != null ? tmp$3 : Kotlin.throwNPE(), splittedVal[0], splittedVal[1]));
              }
            }
          }
        }
        return traces;
      }
    }, /** @lends _c.KMFContainerImpl */ {
      f0: function () {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            if (elem.isRecursiveReadOnly()) {
              this.noChildrenVisit();
            }
             else {
              (elem != null ? elem : Kotlin.throwNPE()).setInternalRecursiveReadOnly();
              elem.setInternalReadOnly();
            }
          }
        });
      },
      f1: function (values) {
        return Kotlin.createObject(_c.ModelAttributeVisitor, null, {
          visit: function (value, name, parent) {
            if (values.containsKey(name)) {
              if (Kotlin.equals(values.get(name), Kotlin.toString(value))) {
                values.remove(name);
              }
            }
             else {
              values.put(name, Kotlin.toString(value));
            }
          }
        });
      },
      f2: function (values, payload) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            var concatedKey = refNameInParent + '_' + elem.path();
            if (values.containsKey(concatedKey)) {
              values.remove(concatedKey);
            }
             else {
              values.put(concatedKey, payload);
            }
          }
        });
      },
      f3: function (finalRoot, resultTest) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            var tmp$0;
            var similarSubObj = finalRoot.findByPath((tmp$0 = elem.path()) != null ? tmp$0 : Kotlin.throwNPE());
            if (!elem.modelEquals(similarSubObj)) {
              resultTest.v = false;
              this.stopVisit();
            }
          }
        });
      },
      f4: function (values) {
        return Kotlin.createObject(_c.ModelAttributeVisitor, null, {
          visit: function (value, name, parent) {
            values.put(name, Kotlin.toString(value));
          }
        });
      },
      f5: function ($outer, values, isInter, traces) {
        return Kotlin.createObject(_c.ModelAttributeVisitor, null, {
          visit: function (value, name, parent) {
            var attVal2;
            if (value != null) {
              attVal2 = Kotlin.toString(value);
            }
             else {
              attVal2 = null;
            }
            if (Kotlin.equals(values.get(name), attVal2)) {
              if (isInter) {
                var tmp$0;
                traces.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$0 = $outer.path()) != null ? tmp$0 : Kotlin.throwNPE(), name, null, attVal2, null));
              }
            }
             else {
              if (!isInter) {
                var tmp$1;
                traces.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$1 = $outer.path()) != null ? tmp$1 : Kotlin.throwNPE(), name, null, attVal2, null));
              }
            }
            values.remove(name);
          }
        });
      },
      f6: function (values, payload) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            var concatedKey = refNameInParent + '_' + elem.path();
            values.put(concatedKey, payload);
          }
        });
      },
      f7: function ($outer, values, isInter, traces) {
        return Kotlin.createObject(_c.ModelVisitor, function $fun() {
          $fun.baseInitializer.call(this);
        }, {
          visit: function (elem, refNameInParent, parent) {
            var concatedKey = refNameInParent + '_' + elem.path();
            if (values.get(concatedKey) != null) {
              if (isInter) {
                var tmp$0, tmp$1;
                traces.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$0 = $outer.path()) != null ? tmp$0 : Kotlin.throwNPE(), refNameInParent, (tmp$1 = elem.path()) != null ? tmp$1 : Kotlin.throwNPE(), null));
              }
            }
             else {
              if (!isInter) {
                var tmp$2, tmp$3;
                traces.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$2 = $outer.path()) != null ? tmp$2 : Kotlin.throwNPE(), refNameInParent, (tmp$3 = elem.path()) != null ? tmp$3 : Kotlin.throwNPE(), null));
              }
            }
            values.remove(concatedKey);
          }
        });
      }
    }), TypedElement: TypedElement, Parameter: Kotlin.createTrait([NamedElement, KMFContainer]), NodeNetwork: Kotlin.createTrait(KMFContainer), NodeLink: Kotlin.createTrait(KMFContainer), MBinding: Kotlin.createTrait(KMFContainer), Operation: Kotlin.createTrait([NamedElement, KMFContainer]), NodeType: Kotlin.createTrait([LifeCycleTypeDefinition, KMFContainer]), PortTypeRef: Kotlin.createTrait([NamedElement, KMFContainer]), DictionaryAttribute: Kotlin.createTrait([TypedElement, KMFContainer]), ComponentType: ComponentType, CompositeType: Kotlin.createTrait([ComponentType, KMFContainer]), KevoreeFactory: Kotlin.createTrait(KMFFactory), DictionaryValue: Kotlin.createTrait(KMFContainer), PortTypeMapping: Kotlin.createTrait(KMFContainer), Group: Kotlin.createTrait([Instance, KMFContainer]), ExtraFonctionalProperty: Kotlin.createTrait(KMFContainer), DictionaryType: Kotlin.createTrait(KMFContainer), Namespace: Kotlin.createTrait([NamedElement, KMFContainer]), AdaptationPrimitiveType: Kotlin.createTrait([NamedElement, KMFContainer]), TypeLibrary: Kotlin.createTrait([NamedElement, KMFContainer]), Port: Kotlin.createTrait(KMFContainer), IntegrationPattern: Kotlin.createTrait([NamedElement, KMFContainer]), Dictionary: Kotlin.createTrait(KMFContainer), ComponentInstance: Kotlin.createTrait([Instance, NamedElement, KMFContainer]), InputStream: Kotlin.createTrait(null), OutputStream: Kotlin.createTrait(null), EventListener: Kotlin.createTrait(null, /** @lends _c.EventListener.prototype */ {
      handleEvent: function (arg1) {
        noImpl;
      }
    }), Asserter: Kotlin.createTrait(null), AbstractIterator: Kotlin.createClass(Kotlin.Iterator, function () {
      this.state = _.kotlin.support.State.NotReady;
      this.nextValue = null;
    }, /** @lends _c.AbstractIterator.prototype */ {
      hasNext: function () {
        _.kotlin.require(this.state !== _.kotlin.support.State.Failed, 'Failed requirement');
        var tmp$0 = this.state, tmp$1;
        if (tmp$0 === _.kotlin.support.State.Done)
          tmp$1 = false;
        else if (tmp$0 === _.kotlin.support.State.Ready)
          tmp$1 = true;
        else
          tmp$1 = this.tryToComputeNext();
        return tmp$1;
      },
      next: function () {
        if (!this.hasNext())
          throw new Kotlin.NoSuchElementException();
        this.state = _.kotlin.support.State.NotReady;
        var tmp$0;
        return (tmp$0 = this.nextValue) != null ? tmp$0 : Kotlin.throwNPE();
      },
      peek: function () {
        if (!this.hasNext())
          throw new Kotlin.NoSuchElementException();
        var tmp$0;
        return (tmp$0 = this.nextValue) != null ? tmp$0 : Kotlin.throwNPE();
      },
      tryToComputeNext: function () {
        this.state = _.kotlin.support.State.Failed;
        this.computeNext();
        return this.state === _.kotlin.support.State.Ready;
      },
      setNext: function (value) {
        this.nextValue = value;
        this.state = _.kotlin.support.State.Ready;
      },
      done: function () {
        this.state = _.kotlin.support.State.Done;
      }
    })};
  }()
  , _ = Kotlin.defineRootPackage(null, /** @lends _ */ {
    kotlin: Kotlin.definePackage(null, /** @lends _.kotlin */ {
      hashMap: function (values) {
        var answer = new Kotlin.ComplexHashMap(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var v = tmp$0[tmp$2];
            answer.put(v.first, v.second);
          }
        }
        return answer;
      },
      toString: function ($receiver) {
        return _.kotlin.makeString($receiver, ', ', '[', ']', -1, '...');
      },
      arrayList: function (values) {
        var list = new Kotlin.ArrayList(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var value = tmp$0[tmp$2];
            list.add(value);
          }
        }
        return list;
      },
      hashSet: function (values) {
        var list = new Kotlin.ComplexHashSet();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var value = tmp$0[tmp$2];
            list.add(value);
          }
        }
        return list;
      },
      map: function ($receiver, transform) {
        return _.kotlin.mapTo($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapValues: function ($receiver, transform) {
        return _.kotlin.mapValuesTo($receiver, new Kotlin.ComplexHashMap(0), transform);
      },
      Pair: Kotlin.createClass(null, function (first, second) {
        this.first = first;
        this.second = second;
      }, /** @lends _.kotlin.Pair.prototype */ {
        component1: function () {
          return this.first;
        },
        component2: function () {
          return this.second;
        },
        toString: function () {
          return '(' + this.first + ', ' + this.second + ')';
        }
      }),
      Triple: Kotlin.createClass(null, function (first, second, third) {
        this.first = first;
        this.second = second;
        this.third = third;
      }, /** @lends _.kotlin.Triple.prototype */ {
        component1: function () {
          return this.first;
        },
        component2: function () {
          return this.second;
        },
        component3: function () {
          return this.third;
        },
        toString: function () {
          return '(' + this.first + ', ' + this.second + ', ' + this.third + ')';
        }
      }),
      all: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter: function ($receiver, predicate) {
        return _.kotlin.filterTo($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot: function ($receiver, predicate) {
        return _.kotlin.filterNotTo($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_0: function ($receiver, transform) {
        return _.kotlin.mapTo_0($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_0: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap: function ($receiver, transform) {
        return _.kotlin.flatMapTo($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy: function ($receiver, toKey) {
        return _.kotlin.groupByTo($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      f0: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f0);
            list.add(element);
          }
        }
        return result;
      },
      drop: function ($receiver, n) {
        return _.kotlin.dropWhile($receiver, _.kotlin.countTo(n));
      },
      dropWhile: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take: function ($receiver, n) {
        return _.kotlin.takeWhile($receiver, _.kotlin.countTo(n));
      },
      takeWhile: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse: function ($receiver) {
        var list = _.kotlin.toCollection($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList: function ($receiver) {
        return _.kotlin.toCollection($receiver, new Kotlin.LinkedList());
      },
      toList_0: function ($receiver) {
        return _.kotlin.toCollection($receiver, new Kotlin.ArrayList(0));
      },
      toSet: function ($receiver) {
        return _.kotlin.toCollection($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet: function ($receiver) {
        return _.kotlin.toCollection($receiver, new Kotlin.TreeSet());
      },
      plus: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_0: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_1: function ($receiver, collection) {
        return _.kotlin.plus_0($receiver, collection.iterator());
      },
      withIndices: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      f1: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f1.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_0: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      test: Kotlin.definePackage(function () {
        this.asserter = new _.kotlin.test.QUnitAsserter();
      }, /** @lends _.kotlin.test */ {
        todo: function (block) {
          Kotlin.println('TODO at ' + block);
        },
        QUnitAsserter: Kotlin.createClass(_c.Asserter, null, /** @lends _.kotlin.test.QUnitAsserter.prototype */ {
          assertTrue: function (message, actual) {
            ok(actual, message);
          },
          assertEquals: function (message, expected, actual) {
            ok(Kotlin.equals(expected, actual), message + '. Expected <' + Kotlin.toString(expected) + '> actual <' + Kotlin.toString(actual) + '>');
          },
          assertNotNull: function (message, actual) {
            ok(actual != null, message);
          },
          assertNull: function (message, actual) {
            ok(actual == null, message);
          },
          fail: function (message) {
            ok(false, message);
          }
        }),
        assertTrue: function (message, block) {
          var actual = block();
          _.kotlin.test.asserter.assertTrue(message, actual);
        },
        assertTrue_0: function (block) {
          _.kotlin.test.assertTrue(Kotlin.toString(block), block);
        },
        f0: function (block) {
          return !block();
        },
        assertNot: function (message, block) {
          _.kotlin.test.assertTrue(message, _.kotlin.test.f0.bind(null, block));
        },
        assertNot_0: function (block) {
          _.kotlin.test.assertNot(Kotlin.toString(block), block);
        },
        assertTrue_1: function (actual, message) {
          return _.kotlin.test.assertEquals(true, actual, message);
        },
        assertFalse: function (actual, message) {
          return _.kotlin.test.assertEquals(false, actual, message);
        },
        assertEquals: function (expected, actual, message) {
          _.kotlin.test.asserter.assertEquals(message, expected, actual);
        },
        assertNotNull: function (actual, message) {
          _.kotlin.test.asserter.assertNotNull(message, actual);
          return actual != null ? actual : Kotlin.throwNPE();
        },
        assertNotNull_0: function (actual, message, block) {
          _.kotlin.test.asserter.assertNotNull(message, actual);
          if (actual != null) {
            block(actual);
          }
        },
        assertNull: function (actual, message) {
          _.kotlin.test.asserter.assertNull(message, actual);
        },
        fail: function (message) {
          _.kotlin.test.asserter.fail(message);
        },
        expect: function (expected, block) {
          _.kotlin.test.expect_0(expected, Kotlin.toString(block), block);
        },
        expect_0: function (expected, message, block) {
          var actual = block();
          _.kotlin.test.assertEquals(expected, actual, message);
        },
        fails: function (block) {
          try {
            block();
            _.kotlin.test.asserter.fail('Expected an exception to be thrown');
            return null;
          }
           catch (e) {
            return e;
          }
        }
      }),
      dom: Kotlin.definePackage(null, /** @lends _.kotlin.dom */ {
        createDocument: function () {
          return document.implementation.createDocument(null, null, null);
        },
        toXmlString: function ($receiver) {
          return $receiver.outerHTML;
        },
        toXmlString_0: function ($receiver, xmlDeclaration) {
          return $receiver.outerHTML;
        },
        eventHandler: function (handler) {
          return new _.kotlin.dom.EventListenerHandler(handler);
        },
        EventListenerHandler: Kotlin.createClass(_c.EventListener, function (handler) {
          this.handler = handler;
        }, /** @lends _.kotlin.dom.EventListenerHandler.prototype */ {
          handleEvent: function (e) {
            if (e != null) {
              this.handler(e);
            }
          }
        }),
        f0: function (handler, e) {
          if (Kotlin.isType(e, MouseEvent)) {
            handler(e);
          }
        },
        mouseEventHandler: function (handler) {
          return _.kotlin.dom.eventHandler(_.kotlin.dom.f0.bind(null, handler));
        },
        on: function ($receiver, name, capture, handler) {
          return _.kotlin.dom.on_0($receiver, name, capture, _.kotlin.dom.eventHandler(handler));
        },
        on_0: function ($receiver, name, capture, listener) {
          var tmp$0;
          if (Kotlin.isType($receiver, EventTarget)) {
            addEventListener(name, listener, capture);
            tmp$0 = new _.kotlin.dom.CloseableEventListener($receiver, listener, name, capture);
          }
           else {
            tmp$0 = null;
          }
          return tmp$0;
        },
        CloseableEventListener: Kotlin.createClass(Kotlin.Closeable, function (target, listener, name, capture) {
          this.target = target;
          this.listener = listener;
          this.name = name;
          this.capture = capture;
        }, /** @lends _.kotlin.dom.CloseableEventListener.prototype */ {
          close: function () {
            this.target.removeEventListener(this.name, this.listener, this.capture);
          }
        }),
        onClick: function ($receiver, capture, handler) {
          return _.kotlin.dom.on_0($receiver, 'click', capture, _.kotlin.dom.mouseEventHandler(handler));
        },
        onDoubleClick: function ($receiver, capture, handler) {
          return _.kotlin.dom.on_0($receiver, 'dblclick', capture, _.kotlin.dom.mouseEventHandler(handler));
        },
        emptyElementList: function () {
          return Kotlin.emptyList();
        },
        emptyNodeList: function () {
          return Kotlin.emptyList();
        },
        get_text: {value: function ($receiver) {
          return $receiver.textContent;
        }},
        set_text: {value: function ($receiver, value) {
          $receiver.textContent = value;
        }},
        get_childrenText: {value: function ($receiver) {
          var buffer = new Kotlin.StringBuilder();
          var nodeList = $receiver.childNodes;
          var i = 0;
          var size = nodeList.length;
          while (i < size) {
            var node = nodeList.item(i);
            if (node != null) {
              if (_.kotlin.dom.isText(node)) {
                buffer.append(node.nodeValue);
              }
            }
            i++;
          }
          return buffer.toString();
        }},
        set_childrenText: {value: function ($receiver, value) {
          var element = $receiver;
          {
            var tmp$0 = _.kotlin.dom.children(element).iterator();
            while (tmp$0.hasNext()) {
              var node = tmp$0.next();
              if (_.kotlin.dom.isText(node)) {
                $receiver.removeChild(node);
              }
            }
          }
          _.kotlin.dom.addText(element, value, null);
        }},
        get_id: {value: function ($receiver) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute('id')) != null ? tmp$0 : '';
        }},
        set_id: {value: function ($receiver, value) {
          $receiver.setAttribute('id', value);
          $receiver.setIdAttribute('id', true);
        }},
        get_style: {value: function ($receiver) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute('style')) != null ? tmp$0 : '';
        }},
        set_style: {value: function ($receiver, value) {
          $receiver.setAttribute('style', value);
        }},
        get_classes: {value: function ($receiver) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute('class')) != null ? tmp$0 : '';
        }},
        set_classes: {value: function ($receiver, value) {
          $receiver.setAttribute('class', value);
        }},
        hasClass: function ($receiver, cssClass) {
          var c = _.kotlin.dom.get_classes($receiver);
          return _.js.matches(c, '(^|.*' + '\\' + 's+)' + cssClass + '(' + '$' + '|' + '\\' + 's+.*)');
        },
        children: function ($receiver) {
          return _.kotlin.dom.toList($receiver != null ? $receiver.childNodes : null);
        },
        f1: function (it) {
          return it.nodeType === Node.ELEMENT_NODE;
        },
        f2: function (it) {
          return it != null ? it : Kotlin.throwNPE();
        },
        childElements: function ($receiver) {
          return _.kotlin.map_3(_.kotlin.filter_2(_.kotlin.dom.children($receiver), _.kotlin.dom.f1), _.kotlin.dom.f2);
        },
        f3: function (name, it) {
          return it.nodeType === Node.ELEMENT_NODE && Kotlin.equals(it.nodeName, name);
        },
        f4: function (it) {
          return it != null ? it : Kotlin.throwNPE();
        },
        childElements_0: function ($receiver, name) {
          return _.kotlin.map_3(_.kotlin.filter_2(_.kotlin.dom.children($receiver), _.kotlin.dom.f3.bind(null, name)), _.kotlin.dom.f4);
        },
        get_elements: {value: function ($receiver) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName('*') : null);
        }},
        get_elements_0: {value: function ($receiver) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName('*') : null);
        }},
        elements_1: function ($receiver, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName(localName) : null);
        },
        elements_2: function ($receiver, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName(localName) : null);
        },
        elements_3: function ($receiver, namespaceUri, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagNameNS(namespaceUri, localName) : null);
        },
        elements_4: function ($receiver, namespaceUri, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagNameNS(namespaceUri, localName) : null);
        },
        toList: function ($receiver) {
          var tmp$0;
          if ($receiver == null) {
            tmp$0 = _.kotlin.dom.emptyNodeList();
          }
           else {
            tmp$0 = new _.kotlin.dom.NodeListAsList($receiver);
          }
          return tmp$0;
        },
        toElementList: function ($receiver) {
          var tmp$0;
          if ($receiver == null) {
            tmp$0 = new Kotlin.ArrayList(0);
          }
           else {
            tmp$0 = new _.kotlin.dom.ElementListAsList($receiver);
          }
          return tmp$0;
        },
        f5: function (selector, it) {
          return _.kotlin.dom.hasClass(it, selector.substring(1));
        },
        get: function ($receiver, selector) {
          var root = $receiver != null ? $receiver.documentElement : null;
          var tmp$0;
          if (root != null) {
            if (Kotlin.equals(selector, '*')) {
              tmp$0 = _.kotlin.dom.get_elements($receiver);
            }
             else if (selector.startsWith('.')) {
              tmp$0 = _.kotlin.toList(_.kotlin.filter_2(_.kotlin.dom.get_elements($receiver), _.kotlin.dom.f5.bind(null, selector)));
            }
             else if (selector.startsWith('#')) {
              var id = selector.substring(1);
              var element = $receiver != null ? $receiver.getElementById(id) : null;
              return element != null ? _.kotlin.arrayList([element]) : _.kotlin.dom.emptyElementList();
            }
             else {
              tmp$0 = _.kotlin.dom.elements_2($receiver, selector);
            }
          }
           else {
            tmp$0 = _.kotlin.dom.emptyElementList();
          }
          return tmp$0;
        },
        f6: function (selector, it) {
          return _.kotlin.dom.hasClass(it, selector.substring(1));
        },
        get_0: function ($receiver, selector) {
          var tmp$1;
          if (Kotlin.equals(selector, '*')) {
            tmp$1 = _.kotlin.dom.get_elements_0($receiver);
          }
           else if (selector.startsWith('.')) {
            tmp$1 = _.kotlin.toList(_.kotlin.filter_2(_.kotlin.dom.get_elements_0($receiver), _.kotlin.dom.f6.bind(null, selector)));
          }
           else if (selector.startsWith('#')) {
            var tmp$0;
            var element = (tmp$0 = $receiver.ownerDocument) != null ? tmp$0.getElementById(selector.substring(1)) : null;
            return element != null ? _.kotlin.arrayList([element]) : _.kotlin.dom.emptyElementList();
          }
           else {
            tmp$1 = _.kotlin.dom.elements_1($receiver, selector);
          }
          return tmp$1;
        },
        NodeListAsList: Kotlin.createClass(Kotlin.AbstractList, function $fun(nodeList) {
          this.nodeList = nodeList;
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.NodeListAsList.prototype */ {
          get: function (index) {
            var node = this.nodeList.item(index);
            if (node == null) {
              throw new RangeError('NodeList does not contain a node at index: ' + index);
            }
             else {
              return node;
            }
          },
          size: function () {
            return this.nodeList.length;
          }
        }),
        ElementListAsList: Kotlin.createClass(Kotlin.AbstractList, function $fun(nodeList) {
          this.nodeList = nodeList;
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.ElementListAsList.prototype */ {
          get: function (index) {
            var node = this.nodeList.item(index);
            if (node == null) {
              throw new RangeError('NodeList does not contain a node at index: ' + index);
            }
             else if (node.nodeType === Node.ELEMENT_NODE) {
              return node != null ? node : Kotlin.throwNPE();
            }
             else {
              throw new Kotlin.IllegalArgumentException('Node is not an Element as expected but is ' + node);
            }
          },
          size: function () {
            return this.nodeList.length;
          }
        }),
        clear: function ($receiver) {
          while (true) {
            var child = $receiver.firstChild;
            if (child == null) {
              return;
            }
             else {
              $receiver.removeChild(child);
            }
          }
        },
        nextSiblings: function ($receiver) {
          return new _.kotlin.dom.NextSiblingIterator($receiver);
        },
        NextSiblingIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(node) {
          this.node = node;
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.NextSiblingIterator.prototype */ {
          computeNext: function () {
            var nextValue = this.node.nextSibling;
            if (nextValue != null) {
              this.setNext(nextValue);
              this.node = nextValue;
            }
             else {
              this.done();
            }
          }
        }),
        previousSiblings: function ($receiver) {
          return new _.kotlin.dom.PreviousSiblingIterator($receiver);
        },
        PreviousSiblingIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(node) {
          this.node = node;
          $fun.baseInitializer.call(this);
        }, /** @lends _.kotlin.dom.PreviousSiblingIterator.prototype */ {
          computeNext: function () {
            var nextValue = this.node.previousSibling;
            if (nextValue != null) {
              this.setNext(nextValue);
              this.node = nextValue;
            }
             else {
              this.done();
            }
          }
        }),
        isText: function ($receiver) {
          var nt = $receiver.nodeType;
          return nt === Node.TEXT_NODE || nt === Node.CDATA_SECTION_NODE;
        },
        attribute: function ($receiver, name) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute(name)) != null ? tmp$0 : '';
        },
        get_head: {value: function ($receiver) {
          return $receiver != null && $receiver.length > 0 ? $receiver.item(0) : null;
        }},
        get_first: {value: function ($receiver) {
          return _.kotlin.dom.get_head($receiver);
        }},
        get_tail: {value: function ($receiver) {
          if ($receiver == null) {
            return null;
          }
           else {
            var s = $receiver.length;
            return s > 0 ? $receiver.item(s - 1) : null;
          }
        }},
        get_last: {value: function ($receiver) {
          return _.kotlin.dom.get_tail($receiver);
        }},
        toXmlString_1: function ($receiver, xmlDeclaration) {
          var tmp$0;
          if ($receiver == null)
            tmp$0 = '';
          else {
            tmp$0 = _.kotlin.dom.nodesToXmlString(_.kotlin.dom.toList($receiver), xmlDeclaration);
          }
          return tmp$0;
        },
        nodesToXmlString: function (nodes, xmlDeclaration) {
          var builder = new Kotlin.StringBuilder();
          {
            var tmp$0 = nodes.iterator();
            while (tmp$0.hasNext()) {
              var n = tmp$0.next();
              builder.append(_.kotlin.dom.toXmlString_0(n, xmlDeclaration));
            }
          }
          return builder.toString();
        },
        plus: function ($receiver, child) {
          if (child != null) {
            $receiver.appendChild(child);
          }
          return $receiver;
        },
        plus_0: function ($receiver, text) {
          return _.kotlin.dom.addText($receiver, text, null);
        },
        plusAssign: function ($receiver, text) {
          return _.kotlin.dom.addText($receiver, text, null);
        },
        createElement: function ($receiver, name, init) {
          var tmp$0;
          var elem = (tmp$0 = $receiver.createElement(name)) != null ? tmp$0 : Kotlin.throwNPE();
          init(elem);
          return elem;
        },
        createElement_0: function ($receiver, name, doc, init) {
          var tmp$0;
          var elem = (tmp$0 = _.kotlin.dom.ownerDocument($receiver, doc).createElement(name)) != null ? tmp$0 : Kotlin.throwNPE();
          init(elem);
          return elem;
        },
        ownerDocument: function ($receiver, doc) {
          var tmp$0;
          if ($receiver.nodeType === Node.DOCUMENT_NODE)
            tmp$0 = $receiver != null ? $receiver : Kotlin.throwNPE();
          else if (doc == null)
            tmp$0 = $receiver.ownerDocument;
          else
            tmp$0 = doc;
          var answer = tmp$0;
          if (answer == null) {
            throw new Kotlin.IllegalArgumentException('Element does not have an ownerDocument and none was provided for: ' + $receiver);
          }
           else {
            return answer;
          }
        },
        addElement: function ($receiver, name, init) {
          var child = _.kotlin.dom.createElement($receiver, name, init);
          $receiver.appendChild(child);
          return child;
        },
        addElement_0: function ($receiver, name, doc, init) {
          var child = _.kotlin.dom.createElement_0($receiver, name, doc, init);
          $receiver.appendChild(child);
          return child;
        },
        addText: function ($receiver, text, doc) {
          if (text != null) {
            var tmp$0;
            var child = (tmp$0 = _.kotlin.dom.ownerDocument($receiver, doc).createTextNode(text)) != null ? tmp$0 : Kotlin.throwNPE();
            $receiver.appendChild(child);
          }
          return $receiver;
        }
      }),
      all_0: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_0: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_0: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_0: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_0: function ($receiver, predicate) {
        return _.kotlin.filterTo_0($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_0: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_0: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_0($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_0: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition_0: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_1: function ($receiver, transform) {
        return _.kotlin.mapTo_1($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_1: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_0: function ($receiver, transform) {
        return _.kotlin.flatMapTo_0($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_0: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_0: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_0: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_0: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_0: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_0: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_0: function ($receiver, toKey) {
        return _.kotlin.groupByTo_0($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      f2: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_0: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f2);
            list.add(element);
          }
        }
        return result;
      },
      drop_0: function ($receiver, n) {
        return _.kotlin.dropWhile_0($receiver, _.kotlin.countTo(n));
      },
      dropWhile_0: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_0($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_0: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_0: function ($receiver, n) {
        return _.kotlin.takeWhile_0($receiver, _.kotlin.countTo(n));
      },
      takeWhile_0: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_0($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_0: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_0: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_0: function ($receiver) {
        var list = _.kotlin.toCollection_0($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_0: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, new Kotlin.LinkedList());
      },
      toList_1: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, new Kotlin.ArrayList(0));
      },
      toSet_0: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_0: function ($receiver) {
        return _.kotlin.toCollection_0($receiver, new Kotlin.TreeSet());
      },
      plus_2: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_0($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_3: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_0($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_4: function ($receiver, collection) {
        return _.kotlin.plus_3($receiver, collection.iterator());
      },
      withIndices_0: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      f3: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_0: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_0($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f3.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_0: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_1: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_0($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      iterator: function ($receiver) {
        return Kotlin.createObject(Kotlin.Iterator, null, {
          hasNext: function () {
            return $receiver.hasMoreElements();
          },
          next: function () {
            return $receiver.nextElement();
          }
        });
      },
      toArrayList: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, new Kotlin.ArrayList(0));
      },
      toHashSet: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, new Kotlin.ComplexHashSet());
      },
      to: function ($receiver, that) {
        return new _.kotlin.Pair($receiver, that);
      },
      run: function (f) {
        return f();
      },
      with: function (receiver, f) {
        return f(receiver);
      },
      let: function ($receiver, f) {
        return f($receiver);
      },
      all_1: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_1: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_1: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_1: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_1: function ($receiver, predicate) {
        return _.kotlin.filterTo_1($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_1: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_1: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_1($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_1: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition_1: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_2: function ($receiver, transform) {
        return _.kotlin.mapTo_2($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_2: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_1: function ($receiver, transform) {
        return _.kotlin.flatMapTo_1($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_1: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_1: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_1: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_1: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_1: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_1: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_1: function ($receiver, toKey) {
        return _.kotlin.groupByTo_1($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      f4: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_1: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f4);
            list.add(element);
          }
        }
        return result;
      },
      drop_1: function ($receiver, n) {
        return _.kotlin.dropWhile_1($receiver, _.kotlin.countTo(n));
      },
      dropWhile_1: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_1($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_1: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_1: function ($receiver, n) {
        return _.kotlin.takeWhile_1($receiver, _.kotlin.countTo(n));
      },
      takeWhile_1: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_1($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_1: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_2: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_1: function ($receiver) {
        var list = _.kotlin.toCollection_2($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_1: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, new Kotlin.LinkedList());
      },
      toList_2: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, new Kotlin.ArrayList(0));
      },
      toSet_1: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_1: function ($receiver) {
        return _.kotlin.toCollection_2($receiver, new Kotlin.TreeSet());
      },
      plus_5: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_2($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_6: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_2($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_7: function ($receiver, collection) {
        return _.kotlin.plus_6($receiver, collection.iterator());
      },
      withIndices_1: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      f5: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_1: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_2($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f5.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_1: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_2: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_1($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      all_2: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_2: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_2: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_2: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_3: function ($receiver, predicate) {
        return _.kotlin.filterTo_2($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_2: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_2: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_2($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_2: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition_2: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_4: function ($receiver, transform) {
        return _.kotlin.mapTo_3($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_3: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_2: function ($receiver, transform) {
        return _.kotlin.flatMapTo_2($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_2: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_2: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_2: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_2: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_2: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_2: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_2: function ($receiver, toKey) {
        return _.kotlin.groupByTo_2($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      f6: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_2: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f6);
            list.add(element);
          }
        }
        return result;
      },
      drop_2: function ($receiver, n) {
        return _.kotlin.dropWhile_2($receiver, _.kotlin.countTo(n));
      },
      dropWhile_2: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_2($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_2: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_2: function ($receiver, n) {
        return _.kotlin.takeWhile_2($receiver, _.kotlin.countTo(n));
      },
      takeWhile_2: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_2($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_2: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_3: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_2: function ($receiver) {
        var list = _.kotlin.toCollection_3($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_2: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, new Kotlin.LinkedList());
      },
      toList_3: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, new Kotlin.ArrayList(0));
      },
      toSet_2: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_2: function ($receiver) {
        return _.kotlin.toCollection_3($receiver, new Kotlin.TreeSet());
      },
      plus_8: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_3($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_9: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_3($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_10: function ($receiver, collection) {
        return _.kotlin.plus_9($receiver, collection.iterator());
      },
      withIndices_2: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      f7: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_2: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_3($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f7.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_2: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_3: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_2($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      downTo: function ($receiver, to) {
        return new _.jet.ByteProgression($receiver, to, -1);
      },
      downTo_0: function ($receiver, to) {
        return new _.jet.CharProgression($receiver.toChar(), to, -1);
      },
      downTo_1: function ($receiver, to) {
        return new _.jet.ShortProgression($receiver, to, -1);
      },
      downTo_2: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_3: function ($receiver, to) {
        return new _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_4: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to, -1);
      },
      downTo_5: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_6: function ($receiver, to) {
        return new _.jet.CharProgression($receiver, to.toChar(), -1);
      },
      downTo_7: function ($receiver, to) {
        return new _.jet.CharProgression($receiver, to, -1);
      },
      downTo_8: function ($receiver, to) {
        return new _.jet.ShortProgression($receiver.toShort(), to, -1);
      },
      downTo_9: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver.toInt(), to, -1);
      },
      downTo_10: function ($receiver, to) {
        return new _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_11: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver.toFloat(), to, -1);
      },
      downTo_12: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver.toDouble(), to, -1.0);
      },
      downTo_13: function ($receiver, to) {
        return new _.jet.ShortProgression($receiver, to, -1);
      },
      downTo_14: function ($receiver, to) {
        return new _.jet.ShortProgression($receiver, to.toShort(), -1);
      },
      downTo_15: function ($receiver, to) {
        return new _.jet.ShortProgression($receiver, to, -1);
      },
      downTo_16: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_17: function ($receiver, to) {
        return new _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_18: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to, -1);
      },
      downTo_19: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_20: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_21: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to.toInt(), -1);
      },
      downTo_22: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_23: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_24: function ($receiver, to) {
        return new _.jet.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_25: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to, -1);
      },
      downTo_26: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_27: function ($receiver, to) {
        return new _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_28: function ($receiver, to) {
        return new _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_29: function ($receiver, to) {
        return new _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_30: function ($receiver, to) {
        return new _.jet.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_31: function ($receiver, to) {
        return new _.jet.LongProgression($receiver, to, -(1).toLong());
      },
      downTo_32: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver.toFloat(), to, -1);
      },
      downTo_33: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver.toDouble(), to, -1.0);
      },
      downTo_34: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to, -1);
      },
      downTo_35: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to.toFloat(), -1);
      },
      downTo_36: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to, -1);
      },
      downTo_37: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to, -1);
      },
      downTo_38: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to.toFloat(), -1);
      },
      downTo_39: function ($receiver, to) {
        return new _.jet.FloatProgression($receiver, to, -1);
      },
      downTo_40: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_41: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_42: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to.toDouble(), -1.0);
      },
      downTo_43: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_44: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_45: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to.toDouble(), -1.0);
      },
      downTo_46: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      downTo_47: function ($receiver, to) {
        return new _.jet.DoubleProgression($receiver, to, -1.0);
      },
      all_3: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_3: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_3: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_3: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_4: function ($receiver, predicate) {
        return _.kotlin.filterTo_3($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_3: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_3: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_3($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_3: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition_3: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_5: function ($receiver, transform) {
        return _.kotlin.mapTo_4($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_4: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_3: function ($receiver, transform) {
        return _.kotlin.flatMapTo_3($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_3: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_3: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_3: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_3: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_3: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_3: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_3: function ($receiver, toKey) {
        return _.kotlin.groupByTo_3($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      f8: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_3: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.f8);
            list.add(element);
          }
        }
        return result;
      },
      drop_3: function ($receiver, n) {
        return _.kotlin.dropWhile_3($receiver, _.kotlin.countTo(n));
      },
      dropWhile_3: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_3($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_3: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_3: function ($receiver, n) {
        return _.kotlin.takeWhile_3($receiver, _.kotlin.countTo(n));
      },
      takeWhile_3: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_3($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_3: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_4: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_3: function ($receiver) {
        var list = _.kotlin.toCollection_4($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_3: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, new Kotlin.LinkedList());
      },
      toList_4: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, new Kotlin.ArrayList(0));
      },
      toSet_3: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_3: function ($receiver) {
        return _.kotlin.toCollection_4($receiver, new Kotlin.TreeSet());
      },
      plus_11: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_4($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_12: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_4($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_13: function ($receiver, collection) {
        return _.kotlin.plus_12($receiver, collection.iterator());
      },
      withIndices_3: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      f9: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_3: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_4($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.f9.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_3: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_4: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_3($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      trim: function ($receiver, text) {
        return _.kotlin.trimTrailing(_.kotlin.trimLeading($receiver, text), text);
      },
      trim_0: function ($receiver, prefix, postfix) {
        return _.kotlin.trimTrailing(_.kotlin.trimLeading($receiver, prefix), postfix);
      },
      trimLeading: function ($receiver, prefix) {
        var answer = $receiver;
        if (answer.startsWith(prefix)) {
          answer = answer.substring(prefix.length);
        }
        return answer;
      },
      trimTrailing: function ($receiver, postfix) {
        var answer = $receiver;
        if (answer.endsWith(postfix)) {
          answer = answer.substring(0, $receiver.length - postfix.length);
        }
        return answer;
      },
      isNotEmpty: function ($receiver) {
        return $receiver != null && $receiver.length > 0;
      },
      iterator_0: function ($receiver) {
        return Kotlin.createObject(_.jet.CharIterator, function $fun() {
          $fun.baseInitializer.call(this);
          this.index = 0;
        }, {
          nextChar: function () {
            var tmp$0, tmp$1;
            return $receiver.get((tmp$0 = this.index, tmp$1 = tmp$0, this.index = tmp$0 + 1, tmp$1));
          },
          hasNext: function () {
            return this.index < $receiver.length;
          }
        });
      },
      orEmpty: function ($receiver) {
        return $receiver != null ? $receiver : '';
      },
      get_size_0: {value: function ($receiver) {
        return $receiver.length;
      }},
      count_4: function ($receiver, predicate) {
        var answer = 0;
        {
          var tmp$0 = _.kotlin.iterator_0($receiver);
          while (tmp$0.hasNext()) {
            var c = tmp$0.next();
            if (predicate(c)) {
              answer++;
            }
          }
        }
        return answer;
      },
      count_5: function ($receiver) {
        if (Kotlin.isType($receiver, _.jet.Collection)) {
          return $receiver.size();
        }
        var number = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var elem = tmp$0.next();
            ++number;
          }
        }
        return number;
      },
      fa: function (count, n, it) {
        ++count.v;
        return count.v <= n;
      },
      countTo: function (n) {
        var count = {v: 0};
        return _.kotlin.fa.bind(null, count, n);
      },
      first: function ($receiver) {
        if (Kotlin.isType($receiver, _.jet.List)) {
          return _.kotlin.first($receiver);
        }
        return $receiver.iterator().next();
      },
      containsItem: function ($receiver, item) {
        if (Kotlin.isType($receiver, Kotlin.AbstractCollection)) {
          return $receiver.contains(item);
        }
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var elem = tmp$0.next();
            if (Kotlin.equals(elem, item)) {
              return true;
            }
          }
        }
        return false;
      },
      sort: function ($receiver) {
        var list = _.kotlin.toCollection_5($receiver, new Kotlin.ArrayList(0));
        Kotlin.collectionsSort(list);
        return list;
      },
      sort_0: function ($receiver, comparator) {
        var list = _.kotlin.toCollection_5($receiver, new Kotlin.ArrayList(0));
        Kotlin.collectionsSort(list, comparator);
        return list;
      },
      all_4: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_4: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_6: function ($receiver, predicate) {
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_4: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_5: function ($receiver, predicate) {
        return _.kotlin.filterTo_4($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_4: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_4: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_4($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_4: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition_4: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_6: function ($receiver, transform) {
        return _.kotlin.mapTo_5($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_5: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_4: function ($receiver, transform) {
        return _.kotlin.flatMapTo_4($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_4: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var list = transform(element);
            {
              var tmp$3 = list.iterator();
              while (tmp$3.hasNext()) {
                var r = tmp$3.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_4: function ($receiver, operation) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            operation(element);
          }
        }
      },
      fold_4: function ($receiver, initial, operation) {
        var answer = initial;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_4: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_4: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_4: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_4: function ($receiver, toKey) {
        return _.kotlin.groupByTo_4($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      fb: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_4: function ($receiver, result, toKey) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fb);
            list.add(element);
          }
        }
        return result;
      },
      drop_4: function ($receiver, n) {
        return _.kotlin.dropWhile_4($receiver, _.kotlin.countTo(n));
      },
      dropWhile_4: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_4($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_4: function ($receiver, result, predicate) {
        var start = true;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_4: function ($receiver, n) {
        return _.kotlin.takeWhile_4($receiver, _.kotlin.countTo(n));
      },
      takeWhile_4: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_4($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_4: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_6: function ($receiver, result) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            result.add(element);
          }
        }
        return result;
      },
      reverse_4: function ($receiver) {
        var list = _.kotlin.toCollection_6($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_4: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, new Kotlin.LinkedList());
      },
      toList_5: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, new Kotlin.ArrayList(0));
      },
      toSet_4: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_4: function ($receiver) {
        return _.kotlin.toCollection_6($receiver, new Kotlin.TreeSet());
      },
      plus_14: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_6($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_15: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_6($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_16: function ($receiver, collection) {
        return _.kotlin.plus_15($receiver, collection.iterator());
      },
      withIndices_4: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      fc: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_4: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_6($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fc.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_4: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_5: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_4($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      all_5: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_5: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_7: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_5: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_6: function ($receiver, predicate) {
        return _.kotlin.filterTo_5($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_5: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_5: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_5($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_5: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition_5: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_7: function ($receiver, transform) {
        return _.kotlin.mapTo_6($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_6: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_5: function ($receiver, transform) {
        return _.kotlin.flatMapTo_5($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_5: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_5: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_5: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_5: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_5: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_5: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_5: function ($receiver, toKey) {
        return _.kotlin.groupByTo_5($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      fd: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_5: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fd);
            list.add(element);
          }
        }
        return result;
      },
      drop_5: function ($receiver, n) {
        return _.kotlin.dropWhile_5($receiver, _.kotlin.countTo(n));
      },
      dropWhile_5: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_5($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_5: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_5: function ($receiver, n) {
        return _.kotlin.takeWhile_5($receiver, _.kotlin.countTo(n));
      },
      takeWhile_5: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_5($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_5: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_7: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_5: function ($receiver) {
        var list = _.kotlin.toCollection_7($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_5: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, new Kotlin.LinkedList());
      },
      toList_6: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, new Kotlin.ArrayList(0));
      },
      toSet_5: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_5: function ($receiver) {
        return _.kotlin.toCollection_7($receiver, new Kotlin.TreeSet());
      },
      plus_17: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_7($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_18: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_7($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_19: function ($receiver, collection) {
        return _.kotlin.plus_18($receiver, collection.iterator());
      },
      withIndices_5: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      fe: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_5: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_7($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fe.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_5: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_6: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_5($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      get_size: {value: function ($receiver) {
        return $receiver.size();
      }},
      get_empty: {value: function ($receiver) {
        return $receiver.isEmpty();
      }},
      set: function ($receiver, key, value) {
        return $receiver.put(key, value);
      },
      orEmpty_0: function ($receiver) {
        var tmp$0;
        return $receiver != null ? $receiver : (tmp$0 = Kotlin.emptyMap()) != null ? tmp$0 : Kotlin.throwNPE();
      },
      get_key: {value: function ($receiver) {
        return $receiver.getKey();
      }},
      get_value: {value: function ($receiver) {
        return $receiver.getValue();
      }},
      component1: function ($receiver) {
        return $receiver.getKey();
      },
      component2: function ($receiver) {
        return $receiver.getValue();
      },
      getOrElse: function ($receiver, key, defaultValue) {
        if ($receiver.containsKey(key)) {
          var tmp$0;
          return (tmp$0 = $receiver.get(key)) != null ? tmp$0 : Kotlin.throwNPE();
        }
         else {
          return defaultValue();
        }
      },
      getOrPut: function ($receiver, key, defaultValue) {
        if ($receiver.containsKey(key)) {
          var tmp$0;
          return (tmp$0 = $receiver.get(key)) != null ? tmp$0 : Kotlin.throwNPE();
        }
         else {
          var answer = defaultValue();
          $receiver.put(key, answer);
          return answer;
        }
      },
      iterator_1: function ($receiver) {
        var entrySet = $receiver.entrySet();
        return entrySet.iterator();
      },
      mapTo: function ($receiver, result, transform) {
        {
          var tmp$0 = _.kotlin.iterator_1($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      mapValuesTo: function ($receiver, result, transform) {
        {
          var tmp$0 = _.kotlin.iterator_1($receiver);
          while (tmp$0.hasNext()) {
            var e = tmp$0.next();
            var newValue = transform(e);
            result.put(_.kotlin.get_key(e), newValue);
          }
        }
        return result;
      },
      putAll: function ($receiver, values) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = values, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var v = tmp$0[tmp$2];
            $receiver.put(v.first, v.second);
          }
        }
      },
      toMap: function ($receiver, map) {
        map.putAll($receiver);
        return map;
      },
      map_8: function ($receiver, transform) {
        return _.kotlin.mapTo($receiver, new Kotlin.ArrayList(_.kotlin.get_size($receiver)), transform);
      },
      mapValues_0: function ($receiver, transform) {
        return _.kotlin.mapValuesTo($receiver, new Kotlin.ComplexHashMap(_.kotlin.get_size($receiver)), transform);
      },
      iterate: function (nextFunction) {
        return new _.kotlin.FunctionIterator(nextFunction);
      },
      FilterIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(iterator, predicate) {
        this.iterator = iterator;
        this.predicate = predicate;
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.FilterIterator.prototype */ {
        computeNext: function () {
          while (this.iterator.hasNext()) {
            var next = this.iterator.next();
            if (this.predicate(next)) {
              this.setNext(next);
              return;
            }
          }
          this.done();
        }
      }),
      FilterNotNullIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(iterator) {
        this.iterator = iterator;
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.FilterNotNullIterator.prototype */ {
        computeNext: function () {
          if (this.iterator != null) {
            while (this.iterator.hasNext()) {
              var next = this.iterator.next();
              if (next != null) {
                this.setNext(next);
                return;
              }
            }
          }
          this.done();
        }
      }),
      MapIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(iterator, transform) {
        this.iterator = iterator;
        this.transform = transform;
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.MapIterator.prototype */ {
        computeNext: function () {
          if (this.iterator.hasNext()) {
            this.setNext(this.transform(this.iterator.next()));
          }
           else {
            this.done();
          }
        }
      }),
      FlatMapIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(iterator, transform) {
        this.iterator = iterator;
        this.transform = transform;
        $fun.baseInitializer.call(this);
        this.transformed = _.kotlin.iterate(function () {
          return null;
        });
      }, /** @lends _.kotlin.FlatMapIterator.prototype */ {
        computeNext: function () {
          while (true) {
            if (this.transformed.hasNext()) {
              this.setNext(this.transformed.next());
              return;
            }
            if (this.iterator.hasNext()) {
              this.transformed = this.transform(this.iterator.next());
            }
             else {
              this.done();
              return;
            }
          }
        }
      }),
      TakeWhileIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(iterator, predicate) {
        this.iterator = iterator;
        this.predicate = predicate;
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.TakeWhileIterator.prototype */ {
        computeNext: function () {
          if (this.iterator.hasNext()) {
            var item = this.iterator.next();
            if (this.predicate(item)) {
              this.setNext(item);
              return;
            }
          }
          this.done();
        }
      }),
      FunctionIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(nextFunction) {
        this.nextFunction = nextFunction;
        $fun.baseInitializer.call(this);
      }, /** @lends _.kotlin.FunctionIterator.prototype */ {
        computeNext: function () {
          var next = this.nextFunction();
          if (next == null) {
            this.done();
          }
           else {
            this.setNext(next);
          }
        }
      }),
      CompositeIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(iterators) {
        $fun.baseInitializer.call(this);
        this.iteratorsIter = Kotlin.arrayIterator(iterators);
        this.currentIter = null;
      }, /** @lends _.kotlin.CompositeIterator.prototype */ {
        computeNext: function () {
          while (true) {
            if (this.currentIter == null) {
              if (this.iteratorsIter.hasNext()) {
                this.currentIter = this.iteratorsIter.next();
              }
               else {
                this.done();
                return;
              }
            }
            var iter = this.currentIter;
            if (iter != null) {
              if (iter.hasNext()) {
                this.setNext(iter.next());
                return;
              }
               else {
                this.currentIter = null;
              }
            }
          }
        }
      }),
      SingleIterator: Kotlin.createClass(_c.AbstractIterator, function $fun(value) {
        this.value = value;
        $fun.baseInitializer.call(this);
        this.first = true;
      }, /** @lends _.kotlin.SingleIterator.prototype */ {
        computeNext: function () {
          if (this.first) {
            this.first = false;
            this.setNext(this.value);
          }
           else {
            this.done();
          }
        }
      }),
      IndexIterator: Kotlin.createClass(Kotlin.Iterator, function (iterator) {
        this.iterator = iterator;
        this.index = 0;
      }, /** @lends _.kotlin.IndexIterator.prototype */ {
        next: function () {
          var tmp$0, tmp$1;
          return new _.kotlin.Pair((tmp$0 = this.index, tmp$1 = tmp$0, this.index = tmp$0 + 1, tmp$1), this.iterator.next());
        },
        hasNext: function () {
          return this.iterator.hasNext();
        }
      }),
      all_6: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_6: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_8: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_6: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_7: function ($receiver, predicate) {
        return _.kotlin.filterTo_6($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_6: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_6: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_6($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_6: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      partition_6: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_9: function ($receiver, transform) {
        return _.kotlin.mapTo_7($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_7: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_6: function ($receiver, transform) {
        return _.kotlin.flatMapTo_6($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_6: function ($receiver, result, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_6: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_6: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_6: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_6: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_6: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_6: function ($receiver, toKey) {
        return _.kotlin.groupByTo_6($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      ff: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_6: function ($receiver, result, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.ff);
            list.add(element);
          }
        }
        return result;
      },
      drop_6: function ($receiver, n) {
        return _.kotlin.dropWhile_6($receiver, _.kotlin.countTo(n));
      },
      dropWhile_6: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_6($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_6: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_6: function ($receiver, n) {
        return _.kotlin.takeWhile_6($receiver, _.kotlin.countTo(n));
      },
      takeWhile_6: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_6($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_6: function ($receiver, result, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_8: function ($receiver, result) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_6: function ($receiver) {
        var list = _.kotlin.toCollection_8($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_6: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, new Kotlin.LinkedList());
      },
      toList_7: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, new Kotlin.ArrayList(0));
      },
      toSet_6: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_6: function ($receiver) {
        return _.kotlin.toCollection_8($receiver, new Kotlin.TreeSet());
      },
      plus_20: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_8($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_21: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_8($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_22: function ($receiver, collection) {
        return _.kotlin.plus_21($receiver, collection.iterator());
      },
      withIndices_6: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      fg: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_6: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_8($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fg.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_6: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_7: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_6($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      all_7: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_7: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_9: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_7: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filterTo_7: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNotTo_7: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNotNullTo: function ($receiver, result) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null)
              result.add(element);
          }
        }
        return result;
      },
      partition_7: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      mapTo_8: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMapTo_7: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_7: function ($receiver, operation) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_7: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      reduce_7: function ($receiver, operation) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      groupBy_7: function ($receiver, toKey) {
        return _.kotlin.groupByTo_7($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      fh: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_7: function ($receiver, result, toKey) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fh);
            list.add(element);
          }
        }
        return result;
      },
      drop_7: function ($receiver, n) {
        return _.kotlin.dropWhile_7($receiver, _.kotlin.countTo(n));
      },
      dropWhile_7: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_7($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_7: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      takeWhileTo_7: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_5: function ($receiver, result) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_7: function ($receiver) {
        var list = _.kotlin.toCollection_5($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_7: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, new Kotlin.LinkedList());
      },
      toList: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, new Kotlin.ArrayList(0));
      },
      toSet_7: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_7: function ($receiver) {
        return _.kotlin.toCollection_5($receiver, new Kotlin.TreeSet());
      },
      withIndices_7: function ($receiver) {
        return new _.kotlin.IndexIterator($receiver.iterator());
      },
      fi: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_7: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_5($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fi.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_7: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_7($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      isNotEmpty_0: function ($receiver) {
        return !_.kotlin.isEmpty($receiver);
      },
      isEmpty: function ($receiver) {
        return $receiver.length === 0;
      },
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_0: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_1: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_2: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_3: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_4: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_5: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_6: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_7: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_size_1: {value: function ($receiver) {
        return $receiver.size();
      }},
      get_empty_0: {value: function ($receiver) {
        return $receiver.isEmpty();
      }},
      get_indices: {value: function ($receiver) {
        return new Kotlin.NumberRange(0, _.kotlin.get_size_1($receiver) - 1);
      }},
      get_indices_0: {value: function ($receiver) {
        return new Kotlin.NumberRange(0, $receiver - 1);
      }},
      isNotEmpty_1: function ($receiver) {
        return !$receiver.isEmpty();
      },
      get_notEmpty: {value: function ($receiver) {
        return _.kotlin.isNotEmpty_1($receiver);
      }},
      orEmpty_1: function ($receiver) {
        var tmp$0;
        return $receiver != null ? $receiver : (tmp$0 = Kotlin.emptyList()) != null ? tmp$0 : Kotlin.throwNPE();
      },
      toSortedList: function ($receiver) {
        return _.kotlin.sort(_.kotlin.toCollection_5($receiver, new Kotlin.ArrayList(0)));
      },
      toSortedList_0: function ($receiver, comparator) {
        return _.kotlin.sort_0(_.kotlin.toList($receiver), comparator);
      },
      orEmpty_2: function ($receiver) {
        var tmp$0;
        return $receiver != null ? $receiver : (tmp$0 = Kotlin.emptyList()) != null ? tmp$0 : Kotlin.throwNPE();
      },
      get_first_0: {value: function ($receiver) {
        return _.kotlin.get_head($receiver);
      }},
      get_last: {value: function ($receiver) {
        var s = _.kotlin.get_size_1($receiver);
        return s > 0 ? $receiver.get(s - 1) : null;
      }},
      get_lastIndex_8: {value: function ($receiver) {
        return _.kotlin.get_size_1($receiver) - 1;
      }},
      get_head: {value: function ($receiver) {
        return $receiver.get(0);
      }},
      get_tail: {value: function ($receiver) {
        return _.kotlin.drop_7($receiver, 1);
      }},
      require: function (value, message) {
        if (!value) {
          throw new Kotlin.IllegalArgumentException(Kotlin.toString(message));
        }
      },
      require_0: function (value, lazyMessage) {
        if (!value) {
          var message = lazyMessage();
          throw new Kotlin.IllegalArgumentException(message.toString());
        }
      },
      requireNotNull: function (value, message) {
        if (value == null) {
          throw new Kotlin.IllegalArgumentException(Kotlin.toString(message));
        }
         else {
          return value;
        }
      },
      check: function (value, message) {
        if (!value) {
          throw new Kotlin.IllegalStateException(Kotlin.toString(message));
        }
      },
      check_0: function (value, lazyMessage) {
        if (!value) {
          var message = lazyMessage();
          throw new Kotlin.IllegalStateException(message.toString());
        }
      },
      checkNotNull: function (value, message) {
        if (value == null) {
          throw new Kotlin.IllegalStateException(message);
        }
         else {
          return value;
        }
      },
      filter_8: function ($receiver, predicate) {
        return new _.kotlin.FilterIterator($receiver, predicate);
      },
      fj: function (predicate, it) {
        return !predicate(it);
      },
      filterNot_7: function ($receiver, predicate) {
        return _.kotlin.filter_8($receiver, _.kotlin.fj.bind(null, predicate));
      },
      filterNotNull: function ($receiver) {
        return new _.kotlin.FilterNotNullIterator($receiver);
      },
      map_10: function ($receiver, transform) {
        return new _.kotlin.MapIterator($receiver, transform);
      },
      flatMap_7: function ($receiver, transform) {
        return new _.kotlin.FlatMapIterator($receiver, transform);
      },
      fk: function (it) {
        if (it == null)
          throw new Kotlin.IllegalArgumentException('null element in iterator ' + $receiver);
        else
          return it;
      },
      requireNoNulls: function ($receiver) {
        return _.kotlin.map_10($receiver, _.kotlin.fk);
      },
      fl: function (count, it) {
        return --count.v >= 0;
      },
      take_7: function ($receiver, n) {
        var count = {v: n};
        return _.kotlin.takeWhile_7($receiver, _.kotlin.fl.bind(null, count));
      },
      takeWhile_7: function ($receiver, predicate) {
        return new _.kotlin.TakeWhileIterator($receiver, predicate);
      },
      plus_23: function ($receiver, element) {
        return new _.kotlin.CompositeIterator([$receiver, new _.kotlin.SingleIterator(element)]);
      },
      plus_24: function ($receiver, iterator) {
        return new _.kotlin.CompositeIterator([$receiver, iterator]);
      },
      plus_25: function ($receiver, collection) {
        return _.kotlin.plus_24($receiver, collection.iterator());
      },
      all_8: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_8: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_10: function ($receiver, predicate) {
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_8: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filter_9: function ($receiver, predicate) {
        return _.kotlin.filterTo_8($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterTo_8: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNot_8: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_8($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotTo_8: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNotNull_0: function ($receiver) {
        return _.kotlin.filterNotNullTo_0($receiver, new Kotlin.ArrayList(0));
      },
      filterNotNullTo_0: function ($receiver, result) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (element != null)
              result.add(element);
          }
        }
        return result;
      },
      partition_8: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      map_11: function ($receiver, transform) {
        return _.kotlin.mapTo_9($receiver, new Kotlin.ArrayList(0), transform);
      },
      mapTo_9: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMap_8: function ($receiver, transform) {
        return _.kotlin.flatMapTo_8($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMapTo_8: function ($receiver, result, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var list = transform(element);
            {
              var tmp$3 = list.iterator();
              while (tmp$3.hasNext()) {
                var r = tmp$3.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_8: function ($receiver, operation) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            operation(element);
          }
        }
      },
      fold_8: function ($receiver, initial, operation) {
        var answer = initial;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      foldRight_7: function ($receiver, initial, operation) {
        var r = initial;
        var index = $receiver.length - 1;
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      reduce_8: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      reduceRight_7: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var r = $receiver[index--];
        while (index >= 0) {
          r = operation($receiver[index--], r);
        }
        return r;
      },
      groupBy_8: function ($receiver, toKey) {
        return _.kotlin.groupByTo_8($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      fm: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_8: function ($receiver, result, toKey) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fm);
            list.add(element);
          }
        }
        return result;
      },
      drop_8: function ($receiver, n) {
        return _.kotlin.dropWhile_8($receiver, _.kotlin.countTo(n));
      },
      dropWhile_8: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_8($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_8: function ($receiver, result, predicate) {
        var start = true;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      take_8: function ($receiver, n) {
        return _.kotlin.takeWhile_8($receiver, _.kotlin.countTo(n));
      },
      takeWhile_8: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_8($receiver, new Kotlin.ArrayList(0), predicate);
      },
      takeWhileTo_8: function ($receiver, result, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_9: function ($receiver, result) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            result.add(element);
          }
        }
        return result;
      },
      reverse_8: function ($receiver) {
        var list = _.kotlin.toCollection_9($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_8: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, new Kotlin.LinkedList());
      },
      toList_8: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, new Kotlin.ArrayList(0));
      },
      toSet_8: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_8: function ($receiver) {
        return _.kotlin.toCollection_9($receiver, new Kotlin.TreeSet());
      },
      requireNoNulls_0: function ($receiver) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (element == null) {
              throw new Kotlin.IllegalArgumentException('null element found in ' + $receiver);
            }
          }
        }
        return $receiver != null ? $receiver : Kotlin.throwNPE();
      },
      plus_26: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_9($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_27: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_9($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_28: function ($receiver, collection) {
        return _.kotlin.plus_27($receiver, collection.iterator());
      },
      withIndices_8: function ($receiver) {
        return new _.kotlin.IndexIterator(Kotlin.arrayIterator($receiver));
      },
      fn: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_8: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_9($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fn.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_8: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_8: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_8($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      filter_2: function ($receiver, predicate) {
        return _.kotlin.filterTo_7($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNot_9: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_7($receiver, new Kotlin.ArrayList(0), predicate);
      },
      filterNotNull_1: function ($receiver) {
        return _.kotlin.filterNotNullTo($receiver, new Kotlin.ArrayList(0));
      },
      map_3: function ($receiver, transform) {
        return _.kotlin.mapTo_8($receiver, new Kotlin.ArrayList(0), transform);
      },
      flatMap_9: function ($receiver, transform) {
        return _.kotlin.flatMapTo_7($receiver, new Kotlin.ArrayList(0), transform);
      },
      take_9: function ($receiver, n) {
        return _.kotlin.takeWhile_9($receiver, _.kotlin.countTo(n));
      },
      takeWhile_9: function ($receiver, predicate) {
        return _.kotlin.takeWhileTo_7($receiver, new Kotlin.ArrayList(0), predicate);
      },
      requireNoNulls_1: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element == null) {
              throw new Kotlin.IllegalArgumentException('null element found in ' + $receiver);
            }
          }
        }
        return $receiver != null ? $receiver : Kotlin.throwNPE();
      },
      plus_29: function ($receiver, element) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_5($receiver, answer);
        answer.add(element);
        return answer;
      },
      plus_30: function ($receiver, iterator) {
        var answer = new Kotlin.ArrayList(0);
        _.kotlin.toCollection_5($receiver, answer);
        {
          var tmp$0 = iterator;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer.add(element);
          }
        }
        return answer;
      },
      plus_31: function ($receiver, collection) {
        return _.kotlin.plus_30($receiver, collection.iterator());
      },
      all_9: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_9: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_11: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      find_9: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      filterTo_9: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNotTo_9: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              result.add(element);
          }
        }
        return result;
      },
      filterNotNullTo_1: function ($receiver, result) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null)
              result.add(element);
          }
        }
        return result;
      },
      partition_9: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList(0);
        var second = new Kotlin.ArrayList(0);
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add(element);
            }
             else {
              second.add(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      mapTo_10: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add(transform(item));
          }
        }
        return result;
      },
      flatMapTo_9: function ($receiver, result, transform) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            {
              var tmp$1 = list.iterator();
              while (tmp$1.hasNext()) {
                var r = tmp$1.next();
                result.add(r);
              }
            }
          }
        }
        return result;
      },
      forEach_9: function ($receiver, operation) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      fold_9: function ($receiver, initial, operation) {
        var answer = initial;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            answer = operation(answer, element);
          }
        }
        return answer;
      },
      reduce_9: function ($receiver, operation) {
        var iterator = $receiver;
        if (!iterator.hasNext()) {
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        }
        var result = iterator.next();
        while (iterator.hasNext()) {
          result = operation(result, iterator.next());
        }
        return result;
      },
      groupBy_9: function ($receiver, toKey) {
        return _.kotlin.groupByTo_9($receiver, new Kotlin.ComplexHashMap(0), toKey);
      },
      fo: function () {
        return new Kotlin.ArrayList(0);
      },
      groupByTo_9: function ($receiver, result, toKey) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut(result, key, _.kotlin.fo);
            list.add(element);
          }
        }
        return result;
      },
      drop_9: function ($receiver, n) {
        return _.kotlin.dropWhile_9($receiver, _.kotlin.countTo(n));
      },
      dropWhile_9: function ($receiver, predicate) {
        return _.kotlin.dropWhileTo_9($receiver, new Kotlin.ArrayList(0), predicate);
      },
      dropWhileTo_9: function ($receiver, result, predicate) {
        var start = true;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (start && predicate(element)) {
            }
             else {
              start = false;
              result.add(element);
            }
          }
        }
        return result;
      },
      takeWhileTo_9: function ($receiver, result, predicate) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              result.add(element);
            else
              break;
          }
        }
        return result;
      },
      toCollection_1: function ($receiver, result) {
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            result.add(element);
          }
        }
        return result;
      },
      reverse_9: function ($receiver) {
        var list = _.kotlin.toCollection_1($receiver, new Kotlin.ArrayList(0));
        Kotlin.reverse(list);
        return list;
      },
      toLinkedList_9: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, new Kotlin.LinkedList());
      },
      toList_9: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, new Kotlin.ArrayList(0));
      },
      toSet_9: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_9: function ($receiver) {
        return _.kotlin.toCollection_1($receiver, new Kotlin.TreeSet());
      },
      withIndices_9: function ($receiver) {
        return new _.kotlin.IndexIterator($receiver);
      },
      fp: function (f, x, y) {
        var xr = f(x);
        var yr = f(y);
        return xr.compareTo(yr);
      },
      sortBy_9: function ($receiver, f) {
        var sortedList = _.kotlin.toCollection_1($receiver, new Kotlin.ArrayList(0));
        var sortBy = Kotlin.comparator(_.kotlin.fp.bind(null, f));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      appendString_9: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = $receiver;
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : Kotlin.toString(element);
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
      },
      makeString_9: function ($receiver, separator, prefix, postfix, limit, truncated) {
        var buffer = new Kotlin.StringBuilder();
        _.kotlin.appendString_9($receiver, buffer, separator, prefix, postfix, limit, truncated);
        return buffer.toString();
      },
      support: Kotlin.definePackage(function () {
        this.State = Kotlin.createObject(null, function () {
          this.Ready = 0;
          this.NotReady = 1;
          this.Done = 2;
          this.Failed = 3;
        });
      }, /** @lends _.kotlin.support */ {
        AbstractIterator: _c.AbstractIterator
      })
    }),
    org: Kotlin.definePackage(null, /** @lends _.org */ {
      kevoree: Kotlin.definePackage(null, /** @lends _.org.kevoree */ {
        loader: Kotlin.definePackage(null, /** @lends _.org.kevoree.loader */ {
          XMIModelLoader: Kotlin.createClass(_c.XMIModelLoader, function $fun() {
            $fun.baseInitializer.call(this);
            this.factory = new _.org.kevoree.factory.MainFactory();
          }),
          JSONModelLoader: Kotlin.createClass(_c.JSONModelLoader, function $fun() {
            $fun.baseInitializer.call(this);
            this.factory = new _.org.kevoree.factory.MainFactory();
          })
        }),
        impl: Kotlin.definePackage(null, /** @lends _.org.kevoree.impl */ {
          CompositeTypeImpl: Kotlin.createClass([_c.CompositeType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$factoryBean = null;
            this.$bean = null;
            this.$abstract = null;
            this.$startMethod = null;
            this.$stopMethod = null;
            this.$updateMethod = null;
            this._deployUnits = new Kotlin.PrimitiveHashMap(0);
            this.$dictionaryType = null;
            this._superTypes = new Kotlin.PrimitiveHashMap(0);
            this._required = new Kotlin.PrimitiveHashMap(0);
            this.removeAllRequiredCurrentlyProcessing = false;
            this._integrationPatterns = new Kotlin.PrimitiveHashMap(0);
            this.removeAllIntegrationPatternsCurrentlyProcessing = false;
            this.$extraFonctionalProperties = null;
            this._provided = new Kotlin.PrimitiveHashMap(0);
            this.removeAllProvidedCurrentlyProcessing = false;
            this._childs = new Kotlin.PrimitiveHashMap(0);
            this._wires = new Kotlin.PrimitiveHashMap(0);
            this.removeAllWiresCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.CompositeTypeImpl.prototype */ {
            delete: function () {
              var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._required) != null ? tmp$2.clear() : null;
              (tmp$3 = this._integrationPatterns) != null ? tmp$3.clear() : null;
              this.extraFonctionalProperties = null;
              (tmp$4 = this._provided) != null ? tmp$4.clear() : null;
              (tmp$5 = this._childs) != null ? tmp$5.clear() : null;
              (tmp$6 = this._wires) != null ? tmp$6.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            },
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            },
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            },
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            },
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            },
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw new Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            },
            required: {
              get: function () {
                return _.kotlin.toList(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            },
            doAddRequired: function (requiredP) {
              var _key_ = (requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey(_key_)) {
                this._required.put(_key_, requiredP);
                (requiredP != null ? requiredP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
              }
            },
            addRequired: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
            },
            addAllRequired: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
            },
            internal_addRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            },
            internal_addAllRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            },
            removeRequired: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
            },
            removeAllRequired: function () {
              this.internal_removeAllRequired(true, true);
            },
            internal_removeRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey())) {
                this._required.remove((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey());
                ((requiredP != null ? requiredP : Kotlin.throwNPE()) != null ? requiredP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            },
            internal_removeAllRequired: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.required) != null ? tmp$0 : Kotlin.throwNPE();
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            },
            integrationPatterns: {
              get: function () {
                return _.kotlin.toList(this._integrationPatterns.values());
              },
              set: function (integrationPatternsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (integrationPatternsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_integrationPatterns(integrationPatternsP, true, true);
              }
            },
            internal_integrationPatterns: function (integrationPatternsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._integrationPatterns.values(), integrationPatternsP)) {
                this._integrationPatterns.clear();
                {
                  var tmp$0 = integrationPatternsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._integrationPatterns.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_integrationPatterns, el), _.org.kevoree.util.Constants.Ref_integrationPatterns);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
                }
              }
            },
            doAddIntegrationPatterns: function (integrationPatternsP) {
              var _key_ = (integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._integrationPatterns.containsKey(_key_)) {
                this._integrationPatterns.put(_key_, integrationPatternsP);
                (integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP), _.org.kevoree.util.Constants.Ref_integrationPatterns);
              }
            },
            addIntegrationPatterns: function (integrationPatternsP) {
              this.internal_addIntegrationPatterns(integrationPatternsP, true, true);
            },
            addAllIntegrationPatterns: function (integrationPatternsP) {
              this.internal_addAllIntegrationPatterns(integrationPatternsP, true, true);
            },
            internal_addIntegrationPatterns: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddIntegrationPatterns(integrationPatternsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
              }
            },
            internal_addAllIntegrationPatterns: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = integrationPatternsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddIntegrationPatterns(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = integrationPatternsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddIntegrationPatterns(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
              }
            },
            removeIntegrationPatterns: function (integrationPatternsP) {
              this.internal_removeIntegrationPatterns(integrationPatternsP, true, true);
            },
            removeAllIntegrationPatterns: function () {
              this.internal_removeAllIntegrationPatterns(true, true);
            },
            internal_removeIntegrationPatterns: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._integrationPatterns.size() !== 0 && this._integrationPatterns.containsKey((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey())) {
                this._integrationPatterns.remove((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey());
                ((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()) != null ? integrationPatternsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllIntegrationPatternsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
                }
              }
            },
            internal_removeAllIntegrationPatterns: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllIntegrationPatternsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.integrationPatterns) != null ? tmp$0 : Kotlin.throwNPE();
              this._integrationPatterns.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, temp_els));
                this.removeAllIntegrationPatternsCurrentlyProcessing = false;
              }
            },
            extraFonctionalProperties: {
              get: function () {
                return this.$extraFonctionalProperties;
              },
              set: function (extraFonctionalPropertiesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_extraFonctionalProperties(extraFonctionalPropertiesP, true, true);
              }
            },
            internal_extraFonctionalProperties: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$extraFonctionalProperties, extraFonctionalPropertiesP)) {
                if (this.$extraFonctionalProperties != null) {
                  var tmp$0;
                  (((tmp$0 = this.$extraFonctionalProperties) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (extraFonctionalPropertiesP != null) {
                  (extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                }
                this.$extraFonctionalProperties = extraFonctionalPropertiesP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
                }
              }
            },
            provided: {
              get: function () {
                return _.kotlin.toList(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            },
            doAddProvided: function (providedP) {
              var _key_ = (providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey(_key_)) {
                this._provided.put(_key_, providedP);
                (providedP != null ? providedP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
              }
            },
            addProvided: function (providedP) {
              this.internal_addProvided(providedP, true, true);
            },
            addAllProvided: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
            },
            internal_addProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            },
            internal_addAllProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            },
            removeProvided: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
            },
            removeAllProvided: function () {
              this.internal_removeAllProvided(true, true);
            },
            internal_removeProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey())) {
                this._provided.remove((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey());
                ((providedP != null ? providedP : Kotlin.throwNPE()) != null ? providedP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            },
            internal_removeAllProvided: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.provided) != null ? tmp$0 : Kotlin.throwNPE();
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            },
            childs: {
              get: function () {
                return _.kotlin.toList(this._childs.values());
              },
              set: function (childsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (childsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_childs(childsP, true, true);
              }
            },
            internal_childs: function (childsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._childs.values(), childsP)) {
                this._childs.clear();
                {
                  var tmp$0 = childsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._childs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, childsP));
                }
              }
            },
            doAddChilds: function (childsP) {
              var _key_ = (childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._childs.containsKey(_key_)) {
                this._childs.put(_key_, childsP);
              }
            },
            addChilds: function (childsP) {
              this.internal_addChilds(childsP, true, true);
            },
            addAllChilds: function (childsP) {
              this.internal_addAllChilds(childsP, true, true);
            },
            internal_addChilds: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddChilds(childsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, childsP));
              }
            },
            internal_addAllChilds: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = childsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddChilds(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = childsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddChilds(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, childsP));
              }
            },
            removeChilds: function (childsP) {
              this.internal_removeChilds(childsP, true, true);
            },
            removeAllChilds: function () {
              this.internal_removeAllChilds(true, true);
            },
            internal_removeChilds: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._childs.size() !== 0 && this._childs.containsKey((childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey())) {
                this._childs.remove((childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, childsP));
                }
              }
            },
            internal_removeAllChilds: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.childs) != null ? tmp$0 : Kotlin.throwNPE();
              this._childs.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_childs, temp_els));
              }
            },
            wires: {
              get: function () {
                return _.kotlin.toList(this._wires.values());
              },
              set: function (wiresP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (wiresP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_wires(wiresP, true, true);
              }
            },
            internal_wires: function (wiresP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._wires.values(), wiresP)) {
                this._wires.clear();
                {
                  var tmp$0 = wiresP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._wires.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_wires, el), _.org.kevoree.util.Constants.Ref_wires);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, wiresP));
                }
              }
            },
            doAddWires: function (wiresP) {
              var _key_ = (wiresP != null ? wiresP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._wires.containsKey(_key_)) {
                this._wires.put(_key_, wiresP);
                (wiresP != null ? wiresP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_wires, wiresP), _.org.kevoree.util.Constants.Ref_wires);
              }
            },
            addWires: function (wiresP) {
              this.internal_addWires(wiresP, true, true);
            },
            addAllWires: function (wiresP) {
              this.internal_addAllWires(wiresP, true, true);
            },
            internal_addWires: function (wiresP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddWires(wiresP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, wiresP));
              }
            },
            internal_addAllWires: function (wiresP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = wiresP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddWires(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = wiresP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddWires(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, wiresP));
              }
            },
            removeWires: function (wiresP) {
              this.internal_removeWires(wiresP, true, true);
            },
            removeAllWires: function () {
              this.internal_removeAllWires(true, true);
            },
            internal_removeWires: function (wiresP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._wires.size() !== 0 && this._wires.containsKey((wiresP != null ? wiresP : Kotlin.throwNPE()).internalGetKey())) {
                this._wires.remove((wiresP != null ? wiresP : Kotlin.throwNPE()).internalGetKey());
                ((wiresP != null ? wiresP : Kotlin.throwNPE()) != null ? wiresP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllWiresCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, wiresP));
                }
              }
            },
            internal_removeAllWires: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllWiresCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.wires) != null ? tmp$0 : Kotlin.throwNPE();
              this._wires.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_wires, temp_els));
                this.removeAllWiresCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRequired();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._required.size() !== 0 && this._required.containsKey(value)) {
                    var obj_1 = this._required.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._required.remove(value);
                    this._required.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_integrationPatterns) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllIntegrationPatterns();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._integrationPatterns.size() !== 0 && this._integrationPatterns.containsKey(value)) {
                    var obj_2 = this._integrationPatterns.get(value);
                    var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_2 == null) {
                      throw new Error('Key newed to null ' + obj_2);
                    }
                    this._integrationPatterns.remove(value);
                    this._integrationPatterns.put(objNewKey_2, obj_2);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_extraFonctionalProperties(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_extraFonctionalProperties(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_extraFonctionalProperties(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllProvided();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._provided.size() !== 0 && this._provided.containsKey(value)) {
                    var obj_3 = this._provided.get(value);
                    var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_3 == null) {
                      throw new Error('Key newed to null ' + obj_3);
                    }
                    this._provided.remove(value);
                    this._provided.put(objNewKey_3, obj_3);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_childs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllChilds();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._childs.size() !== 0 && this._childs.containsKey(value)) {
                    var obj_4 = this._childs.get(value);
                    var objNewKey_4 = (obj_4 != null ? obj_4 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_4 == null) {
                      throw new Error('Key newed to null ' + obj_4);
                    }
                    this._childs.remove(value);
                    this._childs.put(objNewKey_4, obj_4);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_wires) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addWires(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllWires(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeWires(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllWires();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._wires.size() !== 0 && this._wires.containsKey(value)) {
                    var obj_5 = this._wires.get(value);
                    var objNewKey_5 = (obj_5 != null ? obj_5 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_5 == null) {
                      throw new Error('Key newed to null ' + obj_5);
                    }
                    this._wires.remove(value);
                    this._wires.put(objNewKey_5, obj_5);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get(key);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get(key);
            },
            findRequiredByID: function (key) {
              return this._required.get(key);
            },
            findIntegrationPatternsByID: function (key) {
              return this._integrationPatterns.get(key);
            },
            findProvidedByID: function (key) {
              return this._provided.get(key);
            },
            findChildsByID: function (key) {
              return this._childs.get(key);
            },
            findWiresByID: function (key) {
              return this._wires.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                return this.findRequiredByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_integrationPatterns) {
                return this.findIntegrationPatternsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                var objFound_0 = this.extraFonctionalProperties;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                return this.findProvidedByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_childs) {
                return this.findChildsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_wires) {
                return this.findWiresByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$0 = this._required.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._required.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_integrationPatterns, _.org.kevoree.util.Constants.org_kevoree_IntegrationPattern);
                {
                  var tmp$1 = this._integrationPatterns.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._integrationPatterns.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_integrationPatterns);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_integrationPatterns);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties, _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty);
                this.internal_visit(visitor, this.extraFonctionalProperties, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$2 = this._provided.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._provided.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_wires, _.org.kevoree.util.Constants.org_kevoree_Wire);
                {
                  var tmp$3 = this._wires.keySet().iterator();
                  while (tmp$3.hasNext()) {
                    var KMFLoopEntryKey_2 = tmp$3.next();
                    this.internal_visit(visitor, this._wires.get(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_wires);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_wires);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$4 = this._deployUnits.keySet().iterator();
                  while (tmp$4.hasNext()) {
                    var KMFLoopEntryKey_3 = tmp$4.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$5 = this._superTypes.keySet().iterator();
                  while (tmp$5.hasNext()) {
                    var KMFLoopEntryKey_4 = tmp$5.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_4), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_childs, _.org.kevoree.util.Constants.org_kevoree_ComponentType);
                {
                  var tmp$6 = this._childs.keySet().iterator();
                  while (tmp$6.hasNext()) {
                    var KMFLoopEntryKey_5 = tmp$6.next();
                    this.internal_visit(visitor, this._childs.get(KMFLoopEntryKey_5), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_childs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_childs);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_CompositeType;
            }
          }),
          DictionaryTypeImpl: Kotlin.createClass([_c.DictionaryType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this._attributes = new Kotlin.PrimitiveHashMap(0);
            this.removeAllAttributesCurrentlyProcessing = false;
            this._defaultValues = new Kotlin.PrimitiveHashMap(0);
            this.removeAllDefaultValuesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.DictionaryTypeImpl.prototype */ {
            delete: function () {
              var tmp$0, tmp$1;
              (tmp$0 = this._attributes) != null ? tmp$0.clear() : null;
              (tmp$1 = this._defaultValues) != null ? tmp$1.clear() : null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            },
            attributes: {
              get: function () {
                return _.kotlin.toList(this._attributes.values());
              },
              set: function (attributesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (attributesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_attributes(attributesP, true, true);
              }
            },
            internal_attributes: function (attributesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._attributes.values(), attributesP)) {
                this._attributes.clear();
                {
                  var tmp$0 = attributesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._attributes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_attributes, el), _.org.kevoree.util.Constants.Ref_attributes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP));
                }
              }
            },
            doAddAttributes: function (attributesP) {
              var _key_ = (attributesP != null ? attributesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._attributes.containsKey(_key_)) {
                this._attributes.put(_key_, attributesP);
                (attributesP != null ? attributesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_attributes, attributesP), _.org.kevoree.util.Constants.Ref_attributes);
              }
            },
            addAttributes: function (attributesP) {
              this.internal_addAttributes(attributesP, true, true);
            },
            addAllAttributes: function (attributesP) {
              this.internal_addAllAttributes(attributesP, true, true);
            },
            internal_addAttributes: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddAttributes(attributesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP));
              }
            },
            internal_addAllAttributes: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = attributesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddAttributes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = attributesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddAttributes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP));
              }
            },
            removeAttributes: function (attributesP) {
              this.internal_removeAttributes(attributesP, true, true);
            },
            removeAllAttributes: function () {
              this.internal_removeAllAttributes(true, true);
            },
            internal_removeAttributes: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._attributes.size() !== 0 && this._attributes.containsKey((attributesP != null ? attributesP : Kotlin.throwNPE()).internalGetKey())) {
                this._attributes.remove((attributesP != null ? attributesP : Kotlin.throwNPE()).internalGetKey());
                ((attributesP != null ? attributesP : Kotlin.throwNPE()) != null ? attributesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllAttributesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP));
                }
              }
            },
            internal_removeAllAttributes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllAttributesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.attributes) != null ? tmp$0 : Kotlin.throwNPE();
              this._attributes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, temp_els));
                this.removeAllAttributesCurrentlyProcessing = false;
              }
            },
            defaultValues: {
              get: function () {
                return _.kotlin.toList(this._defaultValues.values());
              },
              set: function (defaultValuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (defaultValuesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_defaultValues(defaultValuesP, true, true);
              }
            },
            internal_defaultValues: function (defaultValuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._defaultValues.values(), defaultValuesP)) {
                this._defaultValues.clear();
                {
                  var tmp$0 = defaultValuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._defaultValues.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_defaultValues, el), _.org.kevoree.util.Constants.Ref_defaultValues);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP));
                }
              }
            },
            doAddDefaultValues: function (defaultValuesP) {
              var _key_ = (defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._defaultValues.containsKey(_key_)) {
                this._defaultValues.put(_key_, defaultValuesP);
                (defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP), _.org.kevoree.util.Constants.Ref_defaultValues);
              }
            },
            addDefaultValues: function (defaultValuesP) {
              this.internal_addDefaultValues(defaultValuesP, true, true);
            },
            addAllDefaultValues: function (defaultValuesP) {
              this.internal_addAllDefaultValues(defaultValuesP, true, true);
            },
            internal_addDefaultValues: function (defaultValuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDefaultValues(defaultValuesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP));
              }
            },
            internal_addAllDefaultValues: function (defaultValuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = defaultValuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDefaultValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = defaultValuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDefaultValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP));
              }
            },
            removeDefaultValues: function (defaultValuesP) {
              this.internal_removeDefaultValues(defaultValuesP, true, true);
            },
            removeAllDefaultValues: function () {
              this.internal_removeAllDefaultValues(true, true);
            },
            internal_removeDefaultValues: function (defaultValuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._defaultValues.size() !== 0 && this._defaultValues.containsKey((defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()).internalGetKey())) {
                this._defaultValues.remove((defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()).internalGetKey());
                ((defaultValuesP != null ? defaultValuesP : Kotlin.throwNPE()) != null ? defaultValuesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllDefaultValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, defaultValuesP));
                }
              }
            },
            internal_removeAllDefaultValues: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllDefaultValuesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.defaultValues) != null ? tmp$0 : Kotlin.throwNPE();
              this._defaultValues.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_defaultValues, temp_els));
                this.removeAllDefaultValuesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_attributes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllAttributes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._attributes.size() !== 0 && this._attributes.containsKey(value)) {
                    var obj = this._attributes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._attributes.remove(value);
                    this._attributes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_defaultValues) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDefaultValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDefaultValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDefaultValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDefaultValues();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._defaultValues.size() !== 0 && this._defaultValues.containsKey(value)) {
                    var obj_0 = this._defaultValues.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._defaultValues.remove(value);
                    this._defaultValues.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.generated_KMF_ID;
            },
            findAttributesByID: function (key) {
              return this._attributes.get(key);
            },
            findDefaultValuesByID: function (key) {
              return this._defaultValues.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_attributes) {
                return this.findAttributesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_defaultValues) {
                return this.findDefaultValuesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_attributes, _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute);
                {
                  var tmp$0 = this._attributes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._attributes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_attributes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_attributes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_defaultValues, _.org.kevoree.util.Constants.org_kevoree_DictionaryValue);
                {
                  var tmp$1 = this._defaultValues.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._defaultValues.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_defaultValues);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_defaultValues);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryType;
            }
          }),
          ChannelImpl: Kotlin.createClass([_c.Channel, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$metaData = null;
            this.$started = true;
            this.$typeDefinition = null;
            this.$dictionary = null;
            this._bindings = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.ChannelImpl.prototype */ {
            delete: function () {
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$0;
              (tmp$0 = this._bindings) != null ? tmp$0.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            },
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            },
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            },
            bindings: {
              get: function () {
                return _.kotlin.toList(this._bindings.values());
              },
              set: function (bindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (bindingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_bindings(bindingsP, true, true);
              }
            },
            internal_bindings: function (bindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._bindings.values(), bindingsP)) {
                this.internal_removeAllBindings(true, false);
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._bindings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
                }
              }
            },
            doAddBindings: function (bindingsP) {
              var _key_ = (bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._bindings.containsKey(_key_)) {
                this._bindings.put(_key_, bindingsP);
              }
            },
            addBindings: function (bindingsP) {
              this.internal_addBindings(bindingsP, true, true);
            },
            addAllBindings: function (bindingsP) {
              this.internal_addAllBindings(bindingsP, true, true);
            },
            internal_addBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddBindings(bindingsP);
              if (setOpposite) {
                (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
              }
            },
            internal_addAllBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddBindings(el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = bindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
              }
            },
            removeBindings: function (bindingsP) {
              this.internal_removeBindings(bindingsP, true, true);
            },
            removeAllBindings: function () {
              this.internal_removeAllBindings(true, true);
            },
            internal_removeBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._bindings.size() !== 0 && this._bindings.containsKey((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._bindings.remove((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
                }
                if (setOpposite) {
                  (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, null, false, fireEvents);
                }
              }
            },
            internal_removeAllBindings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.bindings) != null ? tmp$0 : Kotlin.throwNPE();
              if (setOpposite) {
                {
                  var tmp$1 = (temp_els != null ? temp_els : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var el = tmp$1.next();
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_hub, null, false, fireEvents);
                  }
                }
              }
              this._bindings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, temp_els));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_bindings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.internal_removeAllBindings(setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._bindings.size() !== 0 && this._bindings.containsKey(value)) {
                    var obj = this._bindings.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._bindings.remove(value);
                    this._bindings.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findBindingsByID: function (key) {
              return this._bindings.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_bindings) {
                return this.findBindingsByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_bindings, _.org.kevoree.util.Constants.org_kevoree_MBinding);
                {
                  var tmp$0 = this._bindings.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._bindings.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_bindings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_bindings);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Channel;
            }
          }),
          NamespaceImpl: Kotlin.createClass([_c.Namespace, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this._childs = new Kotlin.PrimitiveHashMap(0);
            this.removeAllChildsCurrentlyProcessing = false;
            this.$parent = null;
          }, /** @lends _.org.kevoree.impl.NamespaceImpl.prototype */ {
            delete: function () {
              var tmp$0;
              (tmp$0 = this._childs) != null ? tmp$0.clear() : null;
              this.parent = null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            childs: {
              get: function () {
                return _.kotlin.toList(this._childs.values());
              },
              set: function (childsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (childsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_childs(childsP, true, true);
              }
            },
            internal_childs: function (childsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._childs.values(), childsP)) {
                this._childs.clear();
                {
                  var tmp$0 = childsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._childs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_childs, el), _.org.kevoree.util.Constants.Ref_childs);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, childsP));
                }
              }
            },
            doAddChilds: function (childsP) {
              var _key_ = (childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._childs.containsKey(_key_)) {
                this._childs.put(_key_, childsP);
                (childsP != null ? childsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_childs, childsP), _.org.kevoree.util.Constants.Ref_childs);
              }
            },
            addChilds: function (childsP) {
              this.internal_addChilds(childsP, true, true);
            },
            addAllChilds: function (childsP) {
              this.internal_addAllChilds(childsP, true, true);
            },
            internal_addChilds: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddChilds(childsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, childsP));
              }
            },
            internal_addAllChilds: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = childsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddChilds(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = childsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddChilds(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, childsP));
              }
            },
            removeChilds: function (childsP) {
              this.internal_removeChilds(childsP, true, true);
            },
            removeAllChilds: function () {
              this.internal_removeAllChilds(true, true);
            },
            internal_removeChilds: function (childsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._childs.size() !== 0 && this._childs.containsKey((childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey())) {
                this._childs.remove((childsP != null ? childsP : Kotlin.throwNPE()).internalGetKey());
                ((childsP != null ? childsP : Kotlin.throwNPE()) != null ? childsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllChildsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, childsP));
                }
              }
            },
            internal_removeAllChilds: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllChildsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.childs) != null ? tmp$0 : Kotlin.throwNPE();
              this._childs.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_childs, temp_els));
                this.removeAllChildsCurrentlyProcessing = false;
              }
            },
            parent: {
              get: function () {
                return this.$parent;
              },
              set: function (parentP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_parent(parentP, true, true);
              }
            },
            internal_parent: function (parentP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$parent, parentP)) {
                this.$parent = parentP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_parent, parentP));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_childs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeChilds(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllChilds();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._childs.size() !== 0 && this._childs.containsKey(value)) {
                    var obj = this._childs.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._childs.remove(value);
                    this._childs.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_parent) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_parent(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_parent(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_parent(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findChildsByID: function (key) {
              return this._childs.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_childs) {
                return this.findChildsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_parent) {
                var objFound = this.parent;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_childs, _.org.kevoree.util.Constants.org_kevoree_Namespace);
                {
                  var tmp$0 = this._childs.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._childs.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_childs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_childs);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_parent, _.org.kevoree.util.Constants.org_kevoree_Namespace);
                this.internal_visit(visitor, this.parent, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_parent);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_parent);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Namespace;
            }
          }),
          ContainerNodeImpl: Kotlin.createClass([_c.ContainerNode, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$metaData = null;
            this.$started = true;
            this.$typeDefinition = null;
            this.$dictionary = null;
            this._components = new Kotlin.PrimitiveHashMap(0);
            this.removeAllComponentsCurrentlyProcessing = false;
            this._hosts = new Kotlin.PrimitiveHashMap(0);
            this.$host = null;
          }, /** @lends _.org.kevoree.impl.ContainerNodeImpl.prototype */ {
            delete: function () {
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$0, tmp$1;
              (tmp$0 = this._components) != null ? tmp$0.clear() : null;
              (tmp$1 = this._hosts) != null ? tmp$1.clear() : null;
              this.host = null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            },
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            },
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            },
            components: {
              get: function () {
                return _.kotlin.toList(this._components.values());
              },
              set: function (componentsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (componentsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_components(componentsP, true, true);
              }
            },
            internal_components: function (componentsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._components.values(), componentsP)) {
                this._components.clear();
                {
                  var tmp$0 = componentsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._components.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_components, el), _.org.kevoree.util.Constants.Ref_components);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP));
                }
              }
            },
            doAddComponents: function (componentsP) {
              var _key_ = (componentsP != null ? componentsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._components.containsKey(_key_)) {
                this._components.put(_key_, componentsP);
                (componentsP != null ? componentsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_components, componentsP), _.org.kevoree.util.Constants.Ref_components);
              }
            },
            addComponents: function (componentsP) {
              this.internal_addComponents(componentsP, true, true);
            },
            addAllComponents: function (componentsP) {
              this.internal_addAllComponents(componentsP, true, true);
            },
            internal_addComponents: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddComponents(componentsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP));
              }
            },
            internal_addAllComponents: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = componentsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddComponents(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = componentsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddComponents(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP));
              }
            },
            removeComponents: function (componentsP) {
              this.internal_removeComponents(componentsP, true, true);
            },
            removeAllComponents: function () {
              this.internal_removeAllComponents(true, true);
            },
            internal_removeComponents: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._components.size() !== 0 && this._components.containsKey((componentsP != null ? componentsP : Kotlin.throwNPE()).internalGetKey())) {
                this._components.remove((componentsP != null ? componentsP : Kotlin.throwNPE()).internalGetKey());
                ((componentsP != null ? componentsP : Kotlin.throwNPE()) != null ? componentsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllComponentsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP));
                }
              }
            },
            internal_removeAllComponents: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllComponentsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.components) != null ? tmp$0 : Kotlin.throwNPE();
              this._components.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, temp_els));
                this.removeAllComponentsCurrentlyProcessing = false;
              }
            },
            hosts: {
              get: function () {
                return _.kotlin.toList(this._hosts.values());
              },
              set: function (hostsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (hostsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_hosts(hostsP, true, true);
              }
            },
            internal_hosts: function (hostsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._hosts.values(), hostsP)) {
                this.internal_removeAllHosts(true, false);
                {
                  var tmp$0 = hostsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._hosts.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP));
                }
              }
            },
            doAddHosts: function (hostsP) {
              var _key_ = (hostsP != null ? hostsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._hosts.containsKey(_key_)) {
                this._hosts.put(_key_, hostsP);
              }
            },
            addHosts: function (hostsP) {
              this.internal_addHosts(hostsP, true, true);
            },
            addAllHosts: function (hostsP) {
              this.internal_addAllHosts(hostsP, true, true);
            },
            internal_addHosts: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddHosts(hostsP);
              if (setOpposite) {
                (hostsP != null ? hostsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP));
              }
            },
            internal_addAllHosts: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = hostsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddHosts(el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = hostsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddHosts(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP));
              }
            },
            removeHosts: function (hostsP) {
              this.internal_removeHosts(hostsP, true, true);
            },
            removeAllHosts: function () {
              this.internal_removeAllHosts(true, true);
            },
            internal_removeHosts: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._hosts.size() !== 0 && this._hosts.containsKey((hostsP != null ? hostsP : Kotlin.throwNPE()).internalGetKey())) {
                this._hosts.remove((hostsP != null ? hostsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP));
                }
                if (setOpposite) {
                  (hostsP != null ? hostsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, null, false, fireEvents);
                }
              }
            },
            internal_removeAllHosts: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.hosts) != null ? tmp$0 : Kotlin.throwNPE();
              if (setOpposite) {
                {
                  var tmp$1 = (temp_els != null ? temp_els : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var el = tmp$1.next();
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_host, null, false, fireEvents);
                  }
                }
              }
              this._hosts.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, temp_els));
              }
            },
            host: {
              get: function () {
                return this.$host;
              },
              set: function (hostP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_host(hostP, true, true);
              }
            },
            internal_host: function (hostP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$host, hostP)) {
                if (setOpposite) {
                  if (this.$host != null) {
                    var tmp$0;
                    ((tmp$0 = this.$host) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_hosts, this, false, fireEvents);
                  }
                  if (hostP != null) {
                    hostP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.util.Constants.Ref_hosts, this, false, fireEvents);
                  }
                }
                this.$host = hostP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_host, hostP));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_components) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllComponents();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._components.size() !== 0 && this._components.containsKey(value)) {
                    var obj = this._components.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._components.remove(value);
                    this._components.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_hosts) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.internal_removeAllHosts(setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._hosts.size() !== 0 && this._hosts.containsKey(value)) {
                    var obj_0 = this._hosts.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._hosts.remove(value);
                    this._hosts.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_host) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_host(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_host(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_host(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findComponentsByID: function (key) {
              return this._components.get(key);
            },
            findHostsByID: function (key) {
              return this._hosts.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_components) {
                return this.findComponentsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_hosts) {
                return this.findHostsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_host) {
                var objFound_1 = this.host;
                if (objFound_1 != null && Kotlin.equals((objFound_1 != null ? objFound_1 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_1;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_components, _.org.kevoree.util.Constants.org_kevoree_ComponentInstance);
                {
                  var tmp$0 = this._components.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._components.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_components);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_components);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hosts, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                {
                  var tmp$1 = this._hosts.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._hosts.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hosts);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hosts);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_host, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.host, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_host);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_host);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ContainerNode;
            }
          }),
          ComponentInstanceImpl: Kotlin.createClass([_c.ComponentInstance, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$metaData = null;
            this.$started = true;
            this.$typeDefinition = null;
            this.$dictionary = null;
            this._provided = new Kotlin.PrimitiveHashMap(0);
            this.removeAllProvidedCurrentlyProcessing = false;
            this._required = new Kotlin.PrimitiveHashMap(0);
            this.removeAllRequiredCurrentlyProcessing = false;
            this.$namespace = null;
          }, /** @lends _.org.kevoree.impl.ComponentInstanceImpl.prototype */ {
            delete: function () {
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$0, tmp$1;
              (tmp$0 = this._provided) != null ? tmp$0.clear() : null;
              (tmp$1 = this._required) != null ? tmp$1.clear() : null;
              this.namespace = null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            },
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            },
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            },
            provided: {
              get: function () {
                return _.kotlin.toList(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            },
            doAddProvided: function (providedP) {
              var _key_ = (providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey(_key_)) {
                this._provided.put(_key_, providedP);
                (providedP != null ? providedP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
              }
            },
            addProvided: function (providedP) {
              this.internal_addProvided(providedP, true, true);
            },
            addAllProvided: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
            },
            internal_addProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            },
            internal_addAllProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            },
            removeProvided: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
            },
            removeAllProvided: function () {
              this.internal_removeAllProvided(true, true);
            },
            internal_removeProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey())) {
                this._provided.remove((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey());
                ((providedP != null ? providedP : Kotlin.throwNPE()) != null ? providedP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            },
            internal_removeAllProvided: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.provided) != null ? tmp$0 : Kotlin.throwNPE();
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            },
            required: {
              get: function () {
                return _.kotlin.toList(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            },
            doAddRequired: function (requiredP) {
              var _key_ = (requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey(_key_)) {
                this._required.put(_key_, requiredP);
                (requiredP != null ? requiredP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
              }
            },
            addRequired: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
            },
            addAllRequired: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
            },
            internal_addRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            },
            internal_addAllRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            },
            removeRequired: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
            },
            removeAllRequired: function () {
              this.internal_removeAllRequired(true, true);
            },
            internal_removeRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey())) {
                this._required.remove((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey());
                ((requiredP != null ? requiredP : Kotlin.throwNPE()) != null ? requiredP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            },
            internal_removeAllRequired: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.required) != null ? tmp$0 : Kotlin.throwNPE();
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            },
            namespace: {
              get: function () {
                return this.$namespace;
              },
              set: function (namespaceP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_namespace(namespaceP, true, true);
              }
            },
            internal_namespace: function (namespaceP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$namespace, namespaceP)) {
                this.$namespace = namespaceP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_namespace, namespaceP));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllProvided();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._provided.size() !== 0 && this._provided.containsKey(value)) {
                    var obj = this._provided.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._provided.remove(value);
                    this._provided.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRequired();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._required.size() !== 0 && this._required.containsKey(value)) {
                    var obj_0 = this._required.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._required.remove(value);
                    this._required.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_namespace) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_namespace(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_namespace(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_namespace(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findProvidedByID: function (key) {
              return this._provided.get(key);
            },
            findRequiredByID: function (key) {
              return this._required.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                return this.findProvidedByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                return this.findRequiredByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_namespace) {
                var objFound_1 = this.namespace;
                if (objFound_1 != null && Kotlin.equals((objFound_1 != null ? objFound_1 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_1;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_Port);
                {
                  var tmp$0 = this._provided.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._provided.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_Port);
                {
                  var tmp$1 = this._required.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._required.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_namespace, _.org.kevoree.util.Constants.org_kevoree_Namespace);
                this.internal_visit(visitor, this.namespace, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_namespace);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_namespace);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ComponentInstance;
            }
          }),
          MessagePortTypeImpl: Kotlin.createClass([_c.MessagePortType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$factoryBean = null;
            this.$bean = null;
            this.$abstract = null;
            this.$synchrone = null;
            this._deployUnits = new Kotlin.PrimitiveHashMap(0);
            this.$dictionaryType = null;
            this._superTypes = new Kotlin.PrimitiveHashMap(0);
            this._filters = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.MessagePortTypeImpl.prototype */ {
            delete: function () {
              var tmp$0, tmp$1, tmp$2;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._filters) != null ? tmp$2.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            },
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            },
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            },
            synchrone: {
              get: function () {
                return this.$synchrone;
              },
              set: function (iP) {
                this.internal_synchrone(iP, true);
              }
            },
            internal_synchrone: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.synchrone)) {
                var oldPath = this.path();
                this.$synchrone = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_synchrone, this.synchrone));
                }
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw new Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            },
            filters: {
              get: function () {
                return _.kotlin.toList(this._filters.values());
              },
              set: function (filtersP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (filtersP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_filters(filtersP, true, true);
              }
            },
            internal_filters: function (filtersP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._filters.values(), filtersP)) {
                this._filters.clear();
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._filters.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP));
                }
              }
            },
            doAddFilters: function (filtersP) {
              var _key_ = (filtersP != null ? filtersP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._filters.containsKey(_key_)) {
                this._filters.put(_key_, filtersP);
              }
            },
            addFilters: function (filtersP) {
              this.internal_addFilters(filtersP, true, true);
            },
            addAllFilters: function (filtersP) {
              this.internal_addAllFilters(filtersP, true, true);
            },
            internal_addFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFilters(filtersP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP));
              }
            },
            internal_addAllFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFilters(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = filtersP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFilters(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP));
              }
            },
            removeFilters: function (filtersP) {
              this.internal_removeFilters(filtersP, true, true);
            },
            removeAllFilters: function () {
              this.internal_removeAllFilters(true, true);
            },
            internal_removeFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._filters.size() !== 0 && this._filters.containsKey((filtersP != null ? filtersP : Kotlin.throwNPE()).internalGetKey())) {
                this._filters.remove((filtersP != null ? filtersP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP));
                }
              }
            },
            internal_removeAllFilters: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.filters) != null ? tmp$0 : Kotlin.throwNPE();
              this._filters.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, temp_els));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_synchrone) {
                this.internal_synchrone(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_filters) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllFilters();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._filters.size() !== 0 && this._filters.containsKey(value)) {
                    var obj_1 = this._filters.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._filters.remove(value);
                    this._filters.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get(key);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get(key);
            },
            findFiltersByID: function (key) {
              return this._filters.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_filters) {
                return this.findFiltersByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._deployUnits.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$1 = this._superTypes.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_filters, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$2 = this._filters.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._filters.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_filters);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_filters);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.synchrone, _.org.kevoree.util.Constants.Att_synchrone, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_MessagePortType;
            }
          }),
          ParameterImpl: Kotlin.createClass([_c.Parameter, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$order = null;
            this.$type = null;
          }, /** @lends _.org.kevoree.impl.ParameterImpl.prototype */ {
            delete: function () {
              this.type = null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            order: {
              get: function () {
                return this.$order;
              },
              set: function (iP) {
                this.internal_order(iP, true);
              }
            },
            internal_order: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.order) {
                var oldPath = this.path();
                this.$order = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_order, this.order));
                }
              }
            },
            type: {
              get: function () {
                return this.$type;
              },
              set: function (typeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_type(typeP, true, true);
              }
            },
            internal_type: function (typeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$type, typeP)) {
                this.$type = typeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_type, typeP));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_order) {
                this.internal_order(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_type) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_type(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_type(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_type(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_type) {
                var objFound = this.type;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_type, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                this.internal_visit(visitor, this.type, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_type);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_type);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.order, _.org.kevoree.util.Constants.Att_order, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Parameter;
            }
          }),
          DictionaryAttributeImpl: Kotlin.createClass([_c.DictionaryAttribute, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$optional = null;
            this.$state = null;
            this.$datatype = null;
            this.$fragmentDependant = null;
            this._genericTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.DictionaryAttributeImpl.prototype */ {
            delete: function () {
              var tmp$0;
              (tmp$0 = this._genericTypes) != null ? tmp$0.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            optional: {
              get: function () {
                return this.$optional;
              },
              set: function (iP) {
                this.internal_optional(iP, true);
              }
            },
            internal_optional: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.optional)) {
                var oldPath = this.path();
                this.$optional = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_optional, this.optional));
                }
              }
            },
            state: {
              get: function () {
                return this.$state;
              },
              set: function (iP) {
                this.internal_state(iP, true);
              }
            },
            internal_state: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.state)) {
                var oldPath = this.path();
                this.$state = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_state, this.state));
                }
              }
            },
            datatype: {
              get: function () {
                return this.$datatype;
              },
              set: function (iP) {
                this.internal_datatype(iP, true);
              }
            },
            internal_datatype: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.datatype)) {
                var oldPath = this.path();
                this.$datatype = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_datatype, this.datatype));
                }
              }
            },
            fragmentDependant: {
              get: function () {
                return this.$fragmentDependant;
              },
              set: function (iP) {
                this.internal_fragmentDependant(iP, true);
              }
            },
            internal_fragmentDependant: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.fragmentDependant)) {
                var oldPath = this.path();
                this.$fragmentDependant = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_fragmentDependant, this.fragmentDependant));
                }
              }
            },
            genericTypes: {
              get: function () {
                return _.kotlin.toList(this._genericTypes.values());
              },
              set: function (genericTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (genericTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_genericTypes(genericTypesP, true, true);
              }
            },
            internal_genericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._genericTypes.values(), genericTypesP)) {
                this._genericTypes.clear();
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._genericTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
                }
              }
            },
            doAddGenericTypes: function (genericTypesP) {
              var _key_ = (genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._genericTypes.containsKey(_key_)) {
                this._genericTypes.put(_key_, genericTypesP);
              }
            },
            addGenericTypes: function (genericTypesP) {
              this.internal_addGenericTypes(genericTypesP, true, true);
            },
            addAllGenericTypes: function (genericTypesP) {
              this.internal_addAllGenericTypes(genericTypesP, true, true);
            },
            internal_addGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGenericTypes(genericTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
              }
            },
            internal_addAllGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGenericTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = genericTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGenericTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
              }
            },
            removeGenericTypes: function (genericTypesP) {
              this.internal_removeGenericTypes(genericTypesP, true, true);
            },
            removeAllGenericTypes: function () {
              this.internal_removeAllGenericTypes(true, true);
            },
            internal_removeGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._genericTypes.remove((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
                }
              }
            },
            internal_removeAllGenericTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.genericTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._genericTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, temp_els));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_optional) {
                this.internal_optional(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_state) {
                this.internal_state(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_datatype) {
                this.internal_datatype(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_fragmentDependant) {
                this.internal_fragmentDependant(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllGenericTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey(value)) {
                    var obj = this._genericTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._genericTypes.remove(value);
                    this._genericTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findGenericTypesByID: function (key) {
              return this._genericTypes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                return this.findGenericTypesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$0 = this._genericTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._genericTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_genericTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.fragmentDependant, _.org.kevoree.util.Constants.Att_fragmentDependant, this);
              visitor.visit(this.optional, _.org.kevoree.util.Constants.Att_optional, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.state, _.org.kevoree.util.Constants.Att_state, this);
              visitor.visit(this.datatype, _.org.kevoree.util.Constants.Att_datatype, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute;
            }
          }),
          InstanceImpl: Kotlin.createClass([_c.Instance, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$metaData = null;
            this.$started = true;
            this.$typeDefinition = null;
            this.$dictionary = null;
          }, /** @lends _.org.kevoree.impl.InstanceImpl.prototype */ {
            delete: function () {
              this.typeDefinition = null;
              this.dictionary = null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            },
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            },
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Instance;
            }
          }),
          TypedElementImpl: Kotlin.createClass([_c.TypedElement, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this._genericTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.TypedElementImpl.prototype */ {
            delete: function () {
              var tmp$0;
              (tmp$0 = this._genericTypes) != null ? tmp$0.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            genericTypes: {
              get: function () {
                return _.kotlin.toList(this._genericTypes.values());
              },
              set: function (genericTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (genericTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_genericTypes(genericTypesP, true, true);
              }
            },
            internal_genericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._genericTypes.values(), genericTypesP)) {
                this._genericTypes.clear();
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._genericTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
                }
              }
            },
            doAddGenericTypes: function (genericTypesP) {
              var _key_ = (genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._genericTypes.containsKey(_key_)) {
                this._genericTypes.put(_key_, genericTypesP);
              }
            },
            addGenericTypes: function (genericTypesP) {
              this.internal_addGenericTypes(genericTypesP, true, true);
            },
            addAllGenericTypes: function (genericTypesP) {
              this.internal_addAllGenericTypes(genericTypesP, true, true);
            },
            internal_addGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGenericTypes(genericTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
              }
            },
            internal_addAllGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGenericTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = genericTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGenericTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
              }
            },
            removeGenericTypes: function (genericTypesP) {
              this.internal_removeGenericTypes(genericTypesP, true, true);
            },
            removeAllGenericTypes: function () {
              this.internal_removeAllGenericTypes(true, true);
            },
            internal_removeGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._genericTypes.remove((genericTypesP != null ? genericTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP));
                }
              }
            },
            internal_removeAllGenericTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.genericTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._genericTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, temp_els));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllGenericTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey(value)) {
                    var obj = this._genericTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._genericTypes.remove(value);
                    this._genericTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findGenericTypesByID: function (key) {
              return this._genericTypes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                return this.findGenericTypesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$0 = this._genericTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._genericTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_genericTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_TypedElement;
            }
          }),
          NodeTypeImpl: Kotlin.createClass([_c.NodeType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$factoryBean = null;
            this.$bean = null;
            this.$abstract = null;
            this.$startMethod = null;
            this.$stopMethod = null;
            this.$updateMethod = null;
            this._deployUnits = new Kotlin.PrimitiveHashMap(0);
            this.$dictionaryType = null;
            this._superTypes = new Kotlin.PrimitiveHashMap(0);
            this._managedPrimitiveTypes = new Kotlin.PrimitiveHashMap(0);
            this._managedPrimitiveTypeRefs = new Kotlin.PrimitiveHashMap(0);
            this.removeAllManagedPrimitiveTypeRefsCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.NodeTypeImpl.prototype */ {
            delete: function () {
              var tmp$0, tmp$1, tmp$2, tmp$3;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._managedPrimitiveTypes) != null ? tmp$2.clear() : null;
              (tmp$3 = this._managedPrimitiveTypeRefs) != null ? tmp$3.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            },
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            },
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            },
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            },
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            },
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw new Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            },
            managedPrimitiveTypes: {
              get: function () {
                return _.kotlin.toList(this._managedPrimitiveTypes.values());
              },
              set: function (managedPrimitiveTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (managedPrimitiveTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_managedPrimitiveTypes(managedPrimitiveTypesP, true, true);
              }
            },
            internal_managedPrimitiveTypes: function (managedPrimitiveTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._managedPrimitiveTypes.values(), managedPrimitiveTypesP)) {
                this._managedPrimitiveTypes.clear();
                {
                  var tmp$0 = managedPrimitiveTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._managedPrimitiveTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, managedPrimitiveTypesP));
                }
              }
            },
            doAddManagedPrimitiveTypes: function (managedPrimitiveTypesP) {
              var _key_ = (managedPrimitiveTypesP != null ? managedPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._managedPrimitiveTypes.containsKey(_key_)) {
                this._managedPrimitiveTypes.put(_key_, managedPrimitiveTypesP);
              }
            },
            addManagedPrimitiveTypes: function (managedPrimitiveTypesP) {
              this.internal_addManagedPrimitiveTypes(managedPrimitiveTypesP, true, true);
            },
            addAllManagedPrimitiveTypes: function (managedPrimitiveTypesP) {
              this.internal_addAllManagedPrimitiveTypes(managedPrimitiveTypesP, true, true);
            },
            internal_addManagedPrimitiveTypes: function (managedPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddManagedPrimitiveTypes(managedPrimitiveTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, managedPrimitiveTypesP));
              }
            },
            internal_addAllManagedPrimitiveTypes: function (managedPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = managedPrimitiveTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddManagedPrimitiveTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = managedPrimitiveTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddManagedPrimitiveTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, managedPrimitiveTypesP));
              }
            },
            removeManagedPrimitiveTypes: function (managedPrimitiveTypesP) {
              this.internal_removeManagedPrimitiveTypes(managedPrimitiveTypesP, true, true);
            },
            removeAllManagedPrimitiveTypes: function () {
              this.internal_removeAllManagedPrimitiveTypes(true, true);
            },
            internal_removeManagedPrimitiveTypes: function (managedPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._managedPrimitiveTypes.size() !== 0 && this._managedPrimitiveTypes.containsKey((managedPrimitiveTypesP != null ? managedPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._managedPrimitiveTypes.remove((managedPrimitiveTypesP != null ? managedPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, managedPrimitiveTypesP));
                }
              }
            },
            internal_removeAllManagedPrimitiveTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.managedPrimitiveTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._managedPrimitiveTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, temp_els));
              }
            },
            managedPrimitiveTypeRefs: {
              get: function () {
                return _.kotlin.toList(this._managedPrimitiveTypeRefs.values());
              },
              set: function (managedPrimitiveTypeRefsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (managedPrimitiveTypeRefsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_managedPrimitiveTypeRefs(managedPrimitiveTypeRefsP, true, true);
              }
            },
            internal_managedPrimitiveTypeRefs: function (managedPrimitiveTypeRefsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._managedPrimitiveTypeRefs.values(), managedPrimitiveTypeRefsP)) {
                this._managedPrimitiveTypeRefs.clear();
                {
                  var tmp$0 = managedPrimitiveTypeRefsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._managedPrimitiveTypeRefs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, el), _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP));
                }
              }
            },
            doAddManagedPrimitiveTypeRefs: function (managedPrimitiveTypeRefsP) {
              var _key_ = (managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._managedPrimitiveTypeRefs.containsKey(_key_)) {
                this._managedPrimitiveTypeRefs.put(_key_, managedPrimitiveTypeRefsP);
                (managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP), _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs);
              }
            },
            addManagedPrimitiveTypeRefs: function (managedPrimitiveTypeRefsP) {
              this.internal_addManagedPrimitiveTypeRefs(managedPrimitiveTypeRefsP, true, true);
            },
            addAllManagedPrimitiveTypeRefs: function (managedPrimitiveTypeRefsP) {
              this.internal_addAllManagedPrimitiveTypeRefs(managedPrimitiveTypeRefsP, true, true);
            },
            internal_addManagedPrimitiveTypeRefs: function (managedPrimitiveTypeRefsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddManagedPrimitiveTypeRefs(managedPrimitiveTypeRefsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP));
              }
            },
            internal_addAllManagedPrimitiveTypeRefs: function (managedPrimitiveTypeRefsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = managedPrimitiveTypeRefsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddManagedPrimitiveTypeRefs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = managedPrimitiveTypeRefsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddManagedPrimitiveTypeRefs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP));
              }
            },
            removeManagedPrimitiveTypeRefs: function (managedPrimitiveTypeRefsP) {
              this.internal_removeManagedPrimitiveTypeRefs(managedPrimitiveTypeRefsP, true, true);
            },
            removeAllManagedPrimitiveTypeRefs: function () {
              this.internal_removeAllManagedPrimitiveTypeRefs(true, true);
            },
            internal_removeManagedPrimitiveTypeRefs: function (managedPrimitiveTypeRefsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._managedPrimitiveTypeRefs.size() !== 0 && this._managedPrimitiveTypeRefs.containsKey((managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).internalGetKey())) {
                this._managedPrimitiveTypeRefs.remove((managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).internalGetKey());
                ((managedPrimitiveTypeRefsP != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()) != null ? managedPrimitiveTypeRefsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllManagedPrimitiveTypeRefsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, managedPrimitiveTypeRefsP));
                }
              }
            },
            internal_removeAllManagedPrimitiveTypeRefs: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllManagedPrimitiveTypeRefsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.managedPrimitiveTypeRefs) != null ? tmp$0 : Kotlin.throwNPE();
              this._managedPrimitiveTypeRefs.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, temp_els));
                this.removeAllManagedPrimitiveTypeRefsCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addManagedPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllManagedPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeManagedPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllManagedPrimitiveTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._managedPrimitiveTypes.size() !== 0 && this._managedPrimitiveTypes.containsKey(value)) {
                    var obj_1 = this._managedPrimitiveTypes.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._managedPrimitiveTypes.remove(value);
                    this._managedPrimitiveTypes.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addManagedPrimitiveTypeRefs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllManagedPrimitiveTypeRefs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeManagedPrimitiveTypeRefs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllManagedPrimitiveTypeRefs();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._managedPrimitiveTypeRefs.size() !== 0 && this._managedPrimitiveTypeRefs.containsKey(value)) {
                    var obj_2 = this._managedPrimitiveTypeRefs.get(value);
                    var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_2 == null) {
                      throw new Error('Key newed to null ' + obj_2);
                    }
                    this._managedPrimitiveTypeRefs.remove(value);
                    this._managedPrimitiveTypeRefs.put(objNewKey_2, obj_2);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get(key);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get(key);
            },
            findManagedPrimitiveTypesByID: function (key) {
              return this._managedPrimitiveTypes.get(key);
            },
            findManagedPrimitiveTypeRefsByID: function (key) {
              return this._managedPrimitiveTypeRefs.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes) {
                return this.findManagedPrimitiveTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs) {
                return this.findManagedPrimitiveTypeRefsByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs, _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveTypeRef);
                {
                  var tmp$0 = this._managedPrimitiveTypeRefs.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._managedPrimitiveTypeRefs.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_managedPrimitiveTypeRefs);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$1 = this._deployUnits.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$2 = this._superTypes.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_managedPrimitiveTypes, _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType);
                {
                  var tmp$3 = this._managedPrimitiveTypes.keySet().iterator();
                  while (tmp$3.hasNext()) {
                    var KMFLoopEntryKey_2 = tmp$3.next();
                    this.internal_visit(visitor, this._managedPrimitiveTypes.get(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_managedPrimitiveTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_managedPrimitiveTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NodeType;
            }
          }),
          DeployUnitImpl: Kotlin.createClass([_c.DeployUnit, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$groupName = null;
            this.$unitName = null;
            this.$version = null;
            this.$url = null;
            this.$hashcode = null;
            this.$type = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this._requiredLibs = new Kotlin.PrimitiveHashMap(0);
            this.$targetNodeType = null;
          }, /** @lends _.org.kevoree.impl.DeployUnitImpl.prototype */ {
            delete: function () {
              var tmp$0;
              (tmp$0 = this._requiredLibs) != null ? tmp$0.clear() : null;
              this.targetNodeType = null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
              }
            },
            groupName: {
              get: function () {
                return this.$groupName;
              },
              set: function (iP) {
                this.internal_groupName(iP, true);
              }
            },
            internal_groupName: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.groupName)) {
                var oldPath = this.path();
                this.$groupName = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_groupName, this.groupName));
                }
              }
            },
            unitName: {
              get: function () {
                return this.$unitName;
              },
              set: function (iP) {
                this.internal_unitName(iP, true);
              }
            },
            internal_unitName: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.unitName)) {
                var oldPath = this.path();
                this.$unitName = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_unitName, this.unitName));
                }
              }
            },
            version: {
              get: function () {
                return this.$version;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                this.$version = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version));
                }
              }
            },
            url: {
              get: function () {
                return this.$url;
              },
              set: function (iP) {
                this.internal_url(iP, true);
              }
            },
            internal_url: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.url)) {
                var oldPath = this.path();
                this.$url = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_url, this.url));
                }
              }
            },
            hashcode: {
              get: function () {
                return this.$hashcode;
              },
              set: function (iP) {
                this.internal_hashcode(iP, true);
              }
            },
            internal_hashcode: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.hashcode)) {
                var oldPath = this.path();
                this.$hashcode = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_hashcode, this.hashcode));
                }
              }
            },
            type: {
              get: function () {
                return this.$type;
              },
              set: function (iP) {
                this.internal_type(iP, true);
              }
            },
            internal_type: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.type)) {
                var oldPath = this.path();
                this.$type = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_type, this.type));
                }
              }
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            },
            requiredLibs: {
              get: function () {
                return _.kotlin.toList(this._requiredLibs.values());
              },
              set: function (requiredLibsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredLibsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_requiredLibs(requiredLibsP, true, true);
              }
            },
            internal_requiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._requiredLibs.values(), requiredLibsP)) {
                this._requiredLibs.clear();
                {
                  var tmp$0 = requiredLibsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._requiredLibs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP));
                }
              }
            },
            doAddRequiredLibs: function (requiredLibsP) {
              var _key_ = (requiredLibsP != null ? requiredLibsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._requiredLibs.containsKey(_key_)) {
                this._requiredLibs.put(_key_, requiredLibsP);
              }
            },
            addRequiredLibs: function (requiredLibsP) {
              this.internal_addRequiredLibs(requiredLibsP, true, true);
            },
            addAllRequiredLibs: function (requiredLibsP) {
              this.internal_addAllRequiredLibs(requiredLibsP, true, true);
            },
            internal_addRequiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequiredLibs(requiredLibsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP));
              }
            },
            internal_addAllRequiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredLibsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequiredLibs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredLibsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequiredLibs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP));
              }
            },
            removeRequiredLibs: function (requiredLibsP) {
              this.internal_removeRequiredLibs(requiredLibsP, true, true);
            },
            removeAllRequiredLibs: function () {
              this.internal_removeAllRequiredLibs(true, true);
            },
            internal_removeRequiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._requiredLibs.size() !== 0 && this._requiredLibs.containsKey((requiredLibsP != null ? requiredLibsP : Kotlin.throwNPE()).internalGetKey())) {
                this._requiredLibs.remove((requiredLibsP != null ? requiredLibsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP));
                }
              }
            },
            internal_removeAllRequiredLibs: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.requiredLibs) != null ? tmp$0 : Kotlin.throwNPE();
              this._requiredLibs.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, temp_els));
              }
            },
            targetNodeType: {
              get: function () {
                return this.$targetNodeType;
              },
              set: function (targetNodeTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_targetNodeType(targetNodeTypeP, true, true);
              }
            },
            internal_targetNodeType: function (targetNodeTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$targetNodeType, targetNodeTypeP)) {
                this.$targetNodeType = targetNodeTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_targetNodeType, targetNodeTypeP));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_groupName) {
                this.internal_groupName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_unitName) {
                this.internal_unitName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_version) {
                this.internal_version(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_url) {
                this.internal_url(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_hashcode) {
                this.internal_hashcode(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_type) {
                this.internal_type(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_requiredLibs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRequiredLibs();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._requiredLibs.size() !== 0 && this._requiredLibs.containsKey(value)) {
                    var obj = this._requiredLibs.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._requiredLibs.remove(value);
                    this._requiredLibs.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_targetNodeType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_targetNodeType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_targetNodeType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_targetNodeType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.generated_KMF_ID;
            },
            findRequiredLibsByID: function (key) {
              return this._requiredLibs.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_requiredLibs) {
                return this.findRequiredLibsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_targetNodeType) {
                var objFound = this.targetNodeType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_requiredLibs, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._requiredLibs.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._requiredLibs.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_requiredLibs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_requiredLibs);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_targetNodeType, _.org.kevoree.util.Constants.org_kevoree_NodeType);
                this.internal_visit(visitor, this.targetNodeType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_targetNodeType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_targetNodeType);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.groupName, _.org.kevoree.util.Constants.Att_groupName, this);
              visitor.visit(this.unitName, _.org.kevoree.util.Constants.Att_unitName, this);
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.hashcode, _.org.kevoree.util.Constants.Att_hashcode, this);
              visitor.visit(this.type, _.org.kevoree.util.Constants.Att_type, this);
              visitor.visit(this.url, _.org.kevoree.util.Constants.Att_url, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DeployUnit;
            }
          }),
          GroupTypeImpl: Kotlin.createClass([_c.GroupType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$factoryBean = null;
            this.$bean = null;
            this.$abstract = null;
            this.$startMethod = null;
            this.$stopMethod = null;
            this.$updateMethod = null;
            this._deployUnits = new Kotlin.PrimitiveHashMap(0);
            this.$dictionaryType = null;
            this._superTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.GroupTypeImpl.prototype */ {
            delete: function () {
              var tmp$0, tmp$1;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            },
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            },
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            },
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            },
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            },
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw new Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get(key);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._deployUnits.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$1 = this._superTypes.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_GroupType;
            }
          }),
          AdaptationPrimitiveTypeRefImpl: Kotlin.createClass([_c.AdaptationPrimitiveTypeRef, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$maxTime = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this.$ref = null;
          }, /** @lends _.org.kevoree.impl.AdaptationPrimitiveTypeRefImpl.prototype */ {
            delete: function () {
              this.ref = null;
            },
            maxTime: {
              get: function () {
                return this.$maxTime;
              },
              set: function (iP) {
                this.internal_maxTime(iP, true);
              }
            },
            internal_maxTime: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.maxTime)) {
                var oldPath = this.path();
                this.$maxTime = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_maxTime, this.maxTime));
                }
              }
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            },
            ref: {
              get: function () {
                return this.$ref;
              },
              set: function (refP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_ref(refP, true, true);
              }
            },
            internal_ref: function (refP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$ref, refP)) {
                this.$ref = refP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ref, refP));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_maxTime) {
                this.internal_maxTime(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_ref) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_ref(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_ref(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_ref(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.generated_KMF_ID;
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_ref) {
                var objFound = this.ref;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_ref, _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType);
                this.internal_visit(visitor, this.ref, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_ref);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_ref);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.maxTime, _.org.kevoree.util.Constants.Att_maxTime, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveTypeRef;
            }
          }),
          IntegrationPatternImpl: Kotlin.createClass([_c.IntegrationPattern, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this._extraFonctionalProperties = new Kotlin.PrimitiveHashMap(0);
            this.removeAllExtraFonctionalPropertiesCurrentlyProcessing = false;
            this._portTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.IntegrationPatternImpl.prototype */ {
            delete: function () {
              var tmp$0, tmp$1;
              (tmp$0 = this._extraFonctionalProperties) != null ? tmp$0.clear() : null;
              (tmp$1 = this._portTypes) != null ? tmp$1.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            extraFonctionalProperties: {
              get: function () {
                return _.kotlin.toList(this._extraFonctionalProperties.values());
              },
              set: function (extraFonctionalPropertiesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (extraFonctionalPropertiesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_extraFonctionalProperties(extraFonctionalPropertiesP, true, true);
              }
            },
            internal_extraFonctionalProperties: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._extraFonctionalProperties.values(), extraFonctionalPropertiesP)) {
                this._extraFonctionalProperties.clear();
                {
                  var tmp$0 = extraFonctionalPropertiesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._extraFonctionalProperties.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, el), _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
                }
              }
            },
            doAddExtraFonctionalProperties: function (extraFonctionalPropertiesP) {
              var _key_ = (extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._extraFonctionalProperties.containsKey(_key_)) {
                this._extraFonctionalProperties.put(_key_, extraFonctionalPropertiesP);
                (extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP), _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
              }
            },
            addExtraFonctionalProperties: function (extraFonctionalPropertiesP) {
              this.internal_addExtraFonctionalProperties(extraFonctionalPropertiesP, true, true);
            },
            addAllExtraFonctionalProperties: function (extraFonctionalPropertiesP) {
              this.internal_addAllExtraFonctionalProperties(extraFonctionalPropertiesP, true, true);
            },
            internal_addExtraFonctionalProperties: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddExtraFonctionalProperties(extraFonctionalPropertiesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
              }
            },
            internal_addAllExtraFonctionalProperties: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = extraFonctionalPropertiesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddExtraFonctionalProperties(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = extraFonctionalPropertiesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddExtraFonctionalProperties(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
              }
            },
            removeExtraFonctionalProperties: function (extraFonctionalPropertiesP) {
              this.internal_removeExtraFonctionalProperties(extraFonctionalPropertiesP, true, true);
            },
            removeAllExtraFonctionalProperties: function () {
              this.internal_removeAllExtraFonctionalProperties(true, true);
            },
            internal_removeExtraFonctionalProperties: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._extraFonctionalProperties.size() !== 0 && this._extraFonctionalProperties.containsKey((extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).internalGetKey())) {
                this._extraFonctionalProperties.remove((extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).internalGetKey());
                ((extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()) != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllExtraFonctionalPropertiesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
                }
              }
            },
            internal_removeAllExtraFonctionalProperties: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllExtraFonctionalPropertiesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.extraFonctionalProperties) != null ? tmp$0 : Kotlin.throwNPE();
              this._extraFonctionalProperties.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, temp_els));
                this.removeAllExtraFonctionalPropertiesCurrentlyProcessing = false;
              }
            },
            portTypes: {
              get: function () {
                return _.kotlin.toList(this._portTypes.values());
              },
              set: function (portTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (portTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_portTypes(portTypesP, true, true);
              }
            },
            internal_portTypes: function (portTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._portTypes.values(), portTypesP)) {
                this._portTypes.clear();
                {
                  var tmp$0 = portTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._portTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
                }
              }
            },
            doAddPortTypes: function (portTypesP) {
              var _key_ = (portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._portTypes.containsKey(_key_)) {
                this._portTypes.put(_key_, portTypesP);
              }
            },
            addPortTypes: function (portTypesP) {
              this.internal_addPortTypes(portTypesP, true, true);
            },
            addAllPortTypes: function (portTypesP) {
              this.internal_addAllPortTypes(portTypesP, true, true);
            },
            internal_addPortTypes: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddPortTypes(portTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
              }
            },
            internal_addAllPortTypes: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = portTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddPortTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = portTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddPortTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
              }
            },
            removePortTypes: function (portTypesP) {
              this.internal_removePortTypes(portTypesP, true, true);
            },
            removeAllPortTypes: function () {
              this.internal_removeAllPortTypes(true, true);
            },
            internal_removePortTypes: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._portTypes.size() !== 0 && this._portTypes.containsKey((portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._portTypes.remove((portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
                }
              }
            },
            internal_removeAllPortTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.portTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._portTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, temp_els));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addExtraFonctionalProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllExtraFonctionalProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeExtraFonctionalProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllExtraFonctionalProperties();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._extraFonctionalProperties.size() !== 0 && this._extraFonctionalProperties.containsKey(value)) {
                    var obj = this._extraFonctionalProperties.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._extraFonctionalProperties.remove(value);
                    this._extraFonctionalProperties.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_portTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addPortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllPortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removePortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllPortTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._portTypes.size() !== 0 && this._portTypes.containsKey(value)) {
                    var obj_0 = this._portTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._portTypes.remove(value);
                    this._portTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findExtraFonctionalPropertiesByID: function (key) {
              return this._extraFonctionalProperties.get(key);
            },
            findPortTypesByID: function (key) {
              return this._portTypes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                return this.findExtraFonctionalPropertiesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_portTypes) {
                return this.findPortTypesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties, _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty);
                {
                  var tmp$0 = this._extraFonctionalProperties.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._extraFonctionalProperties.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_portTypes, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$1 = this._portTypes.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._portTypes.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_portTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_portTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_IntegrationPattern;
            }
          }),
          ChannelTypeImpl: Kotlin.createClass([_c.ChannelType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$factoryBean = null;
            this.$bean = null;
            this.$abstract = null;
            this.$startMethod = null;
            this.$stopMethod = null;
            this.$updateMethod = null;
            this.$lowerBindings = null;
            this.$upperBindings = null;
            this.$lowerFragments = null;
            this.$upperFragments = null;
            this._deployUnits = new Kotlin.PrimitiveHashMap(0);
            this.$dictionaryType = null;
            this._superTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.ChannelTypeImpl.prototype */ {
            delete: function () {
              var tmp$0, tmp$1;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            },
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            },
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            },
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            },
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            },
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            },
            lowerBindings: {
              get: function () {
                return this.$lowerBindings;
              },
              set: function (iP) {
                this.internal_lowerBindings(iP, true);
              }
            },
            internal_lowerBindings: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.lowerBindings) {
                var oldPath = this.path();
                this.$lowerBindings = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lowerBindings, this.lowerBindings));
                }
              }
            },
            upperBindings: {
              get: function () {
                return this.$upperBindings;
              },
              set: function (iP) {
                this.internal_upperBindings(iP, true);
              }
            },
            internal_upperBindings: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.upperBindings) {
                var oldPath = this.path();
                this.$upperBindings = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_upperBindings, this.upperBindings));
                }
              }
            },
            lowerFragments: {
              get: function () {
                return this.$lowerFragments;
              },
              set: function (iP) {
                this.internal_lowerFragments(iP, true);
              }
            },
            internal_lowerFragments: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.lowerFragments) {
                var oldPath = this.path();
                this.$lowerFragments = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lowerFragments, this.lowerFragments));
                }
              }
            },
            upperFragments: {
              get: function () {
                return this.$upperFragments;
              },
              set: function (iP) {
                this.internal_upperFragments(iP, true);
              }
            },
            internal_upperFragments: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.upperFragments) {
                var oldPath = this.path();
                this.$upperFragments = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_upperFragments, this.upperFragments));
                }
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw new Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lowerBindings) {
                this.internal_lowerBindings(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_upperBindings) {
                this.internal_upperBindings(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lowerFragments) {
                this.internal_lowerFragments(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_upperFragments) {
                this.internal_upperFragments(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get(key);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._deployUnits.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$1 = this._superTypes.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.upperFragments, _.org.kevoree.util.Constants.Att_upperFragments, this);
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.upperBindings, _.org.kevoree.util.Constants.Att_upperBindings, this);
              visitor.visit(this.lowerBindings, _.org.kevoree.util.Constants.Att_lowerBindings, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.lowerFragments, _.org.kevoree.util.Constants.Att_lowerFragments, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ChannelType;
            }
          }),
          ServicePortTypeImpl: Kotlin.createClass([_c.ServicePortType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$factoryBean = null;
            this.$bean = null;
            this.$abstract = null;
            this.$synchrone = null;
            this.$interface = null;
            this._deployUnits = new Kotlin.PrimitiveHashMap(0);
            this.$dictionaryType = null;
            this._superTypes = new Kotlin.PrimitiveHashMap(0);
            this._operations = new Kotlin.PrimitiveHashMap(0);
            this.removeAllOperationsCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ServicePortTypeImpl.prototype */ {
            delete: function () {
              var tmp$0, tmp$1, tmp$2;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._operations) != null ? tmp$2.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            },
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            },
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            },
            synchrone: {
              get: function () {
                return this.$synchrone;
              },
              set: function (iP) {
                this.internal_synchrone(iP, true);
              }
            },
            internal_synchrone: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.synchrone)) {
                var oldPath = this.path();
                this.$synchrone = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_synchrone, this.synchrone));
                }
              }
            },
            interface: {
              get: function () {
                return this.$interface;
              },
              set: function (iP) {
                this.internal_interface(iP, true);
              }
            },
            internal_interface: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.interface)) {
                var oldPath = this.path();
                this.$interface = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_interface, this.interface));
                }
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw new Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            },
            operations: {
              get: function () {
                return _.kotlin.toList(this._operations.values());
              },
              set: function (operationsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (operationsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_operations(operationsP, true, true);
              }
            },
            internal_operations: function (operationsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._operations.values(), operationsP)) {
                this._operations.clear();
                {
                  var tmp$0 = operationsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._operations.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_operations, el), _.org.kevoree.util.Constants.Ref_operations);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP));
                }
              }
            },
            doAddOperations: function (operationsP) {
              var _key_ = (operationsP != null ? operationsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._operations.containsKey(_key_)) {
                this._operations.put(_key_, operationsP);
                (operationsP != null ? operationsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_operations, operationsP), _.org.kevoree.util.Constants.Ref_operations);
              }
            },
            addOperations: function (operationsP) {
              this.internal_addOperations(operationsP, true, true);
            },
            addAllOperations: function (operationsP) {
              this.internal_addAllOperations(operationsP, true, true);
            },
            internal_addOperations: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddOperations(operationsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP));
              }
            },
            internal_addAllOperations: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = operationsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddOperations(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = operationsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddOperations(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP));
              }
            },
            removeOperations: function (operationsP) {
              this.internal_removeOperations(operationsP, true, true);
            },
            removeAllOperations: function () {
              this.internal_removeAllOperations(true, true);
            },
            internal_removeOperations: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._operations.size() !== 0 && this._operations.containsKey((operationsP != null ? operationsP : Kotlin.throwNPE()).internalGetKey())) {
                this._operations.remove((operationsP != null ? operationsP : Kotlin.throwNPE()).internalGetKey());
                ((operationsP != null ? operationsP : Kotlin.throwNPE()) != null ? operationsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllOperationsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP));
                }
              }
            },
            internal_removeAllOperations: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllOperationsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.operations) != null ? tmp$0 : Kotlin.throwNPE();
              this._operations.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, temp_els));
                this.removeAllOperationsCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_synchrone) {
                this.internal_synchrone(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_interface) {
                this.internal_interface(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_operations) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllOperations();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._operations.size() !== 0 && this._operations.containsKey(value)) {
                    var obj_1 = this._operations.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._operations.remove(value);
                    this._operations.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get(key);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get(key);
            },
            findOperationsByID: function (key) {
              return this._operations.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_operations) {
                return this.findOperationsByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_operations, _.org.kevoree.util.Constants.org_kevoree_Operation);
                {
                  var tmp$0 = this._operations.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._operations.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_operations);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_operations);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$1 = this._deployUnits.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$2 = this._superTypes.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.synchrone, _.org.kevoree.util.Constants.Att_synchrone, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.interface, _.org.kevoree.util.Constants.Att_interface, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ServicePortType;
            }
          }),
          NamedElementImpl: Kotlin.createClass([_c.NamedElement, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
          }, /** @lends _.org.kevoree.impl.NamedElementImpl.prototype */ {
            delete: function () {
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findByID: function (relationName, idP) {
              {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NamedElement;
            }
          }),
          GroupImpl: Kotlin.createClass([_c.Group, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$metaData = null;
            this.$started = true;
            this.$typeDefinition = null;
            this.$dictionary = null;
            this._subNodes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.GroupImpl.prototype */ {
            delete: function () {
              this.typeDefinition = null;
              this.dictionary = null;
              var tmp$0;
              (tmp$0 = this._subNodes) != null ? tmp$0.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            metaData: {
              get: function () {
                return this.$metaData;
              },
              set: function (iP) {
                this.internal_metaData(iP, true);
              }
            },
            internal_metaData: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.metaData)) {
                var oldPath = this.path();
                this.$metaData = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_metaData, this.metaData));
                }
              }
            },
            started: {
              get: function () {
                return this.$started;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                this.$started = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started));
                }
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition, typeDefinitionP)) {
                this.$typeDefinition = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP));
                }
              }
            },
            dictionary: {
              get: function () {
                return this.$dictionary;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary, dictionaryP)) {
                if (this.$dictionary != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionary) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                this.$dictionary = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP));
                }
              }
            },
            subNodes: {
              get: function () {
                return _.kotlin.toList(this._subNodes.values());
              },
              set: function (subNodesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (subNodesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_subNodes(subNodesP, true, true);
              }
            },
            internal_subNodes: function (subNodesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._subNodes.values(), subNodesP)) {
                this._subNodes.clear();
                {
                  var tmp$0 = subNodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._subNodes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP));
                }
              }
            },
            doAddSubNodes: function (subNodesP) {
              var _key_ = (subNodesP != null ? subNodesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._subNodes.containsKey(_key_)) {
                this._subNodes.put(_key_, subNodesP);
              }
            },
            addSubNodes: function (subNodesP) {
              this.internal_addSubNodes(subNodesP, true, true);
            },
            addAllSubNodes: function (subNodesP) {
              this.internal_addAllSubNodes(subNodesP, true, true);
            },
            internal_addSubNodes: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSubNodes(subNodesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP));
              }
            },
            internal_addAllSubNodes: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = subNodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSubNodes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = subNodesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSubNodes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP));
              }
            },
            removeSubNodes: function (subNodesP) {
              this.internal_removeSubNodes(subNodesP, true, true);
            },
            removeAllSubNodes: function () {
              this.internal_removeAllSubNodes(true, true);
            },
            internal_removeSubNodes: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._subNodes.size() !== 0 && this._subNodes.containsKey((subNodesP != null ? subNodesP : Kotlin.throwNPE()).internalGetKey())) {
                this._subNodes.remove((subNodesP != null ? subNodesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP));
                }
              }
            },
            internal_removeAllSubNodes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.subNodes) != null ? tmp$0 : Kotlin.throwNPE();
              this._subNodes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, temp_els));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_metaData) {
                this.internal_metaData(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_started) {
                this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_typeDefinition(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_typeDefinition(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionary(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionary(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_subNodes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSubNodes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._subNodes.size() !== 0 && this._subNodes.containsKey(value)) {
                    var obj = this._subNodes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._subNodes.remove(value);
                    this._subNodes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findSubNodesByID: function (key) {
              return this._subNodes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                var objFound = this.typeDefinition;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                var objFound_0 = this.dictionary;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_subNodes) {
                return this.findSubNodesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary);
                this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_subNodes, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                {
                  var tmp$0 = this._subNodes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._subNodes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_subNodes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_subNodes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
              visitor.visit(this.metaData, _.org.kevoree.util.Constants.Att_metaData, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Group;
            }
          }),
          NodeNetworkImpl: Kotlin.createClass([_c.NodeNetwork, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this._link = new Kotlin.PrimitiveHashMap(0);
            this.removeAllLinkCurrentlyProcessing = false;
            this.$initBy = null;
            this.$target = null;
          }, /** @lends _.org.kevoree.impl.NodeNetworkImpl.prototype */ {
            delete: function () {
              var tmp$0;
              (tmp$0 = this._link) != null ? tmp$0.clear() : null;
              this.initBy = null;
              this.target = null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            },
            link: {
              get: function () {
                return _.kotlin.toList(this._link.values());
              },
              set: function (linkP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (linkP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_link(linkP, true, true);
              }
            },
            internal_link: function (linkP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._link.values(), linkP)) {
                this._link.clear();
                {
                  var tmp$0 = linkP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._link.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_link, el), _.org.kevoree.util.Constants.Ref_link);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP));
                }
              }
            },
            doAddLink: function (linkP) {
              var _key_ = (linkP != null ? linkP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._link.containsKey(_key_)) {
                this._link.put(_key_, linkP);
                (linkP != null ? linkP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_link, linkP), _.org.kevoree.util.Constants.Ref_link);
              }
            },
            addLink: function (linkP) {
              this.internal_addLink(linkP, true, true);
            },
            addAllLink: function (linkP) {
              this.internal_addAllLink(linkP, true, true);
            },
            internal_addLink: function (linkP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddLink(linkP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP));
              }
            },
            internal_addAllLink: function (linkP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = linkP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddLink(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = linkP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddLink(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP));
              }
            },
            removeLink: function (linkP) {
              this.internal_removeLink(linkP, true, true);
            },
            removeAllLink: function () {
              this.internal_removeAllLink(true, true);
            },
            internal_removeLink: function (linkP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._link.size() !== 0 && this._link.containsKey((linkP != null ? linkP : Kotlin.throwNPE()).internalGetKey())) {
                this._link.remove((linkP != null ? linkP : Kotlin.throwNPE()).internalGetKey());
                ((linkP != null ? linkP : Kotlin.throwNPE()) != null ? linkP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllLinkCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, linkP));
                }
              }
            },
            internal_removeAllLink: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllLinkCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.link) != null ? tmp$0 : Kotlin.throwNPE();
              this._link.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_link, temp_els));
                this.removeAllLinkCurrentlyProcessing = false;
              }
            },
            initBy: {
              get: function () {
                return this.$initBy;
              },
              set: function (initByP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_initBy(initByP, true, true);
              }
            },
            internal_initBy: function (initByP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$initBy, initByP)) {
                this.$initBy = initByP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_initBy, initByP));
                }
              }
            },
            target: {
              get: function () {
                return this.$target;
              },
              set: function (targetP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_target(targetP, true, true);
              }
            },
            internal_target: function (targetP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$target, targetP)) {
                this.$target = targetP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_target, targetP));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_link) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addLink(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllLink(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeLink(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllLink();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._link.size() !== 0 && this._link.containsKey(value)) {
                    var obj = this._link.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._link.remove(value);
                    this._link.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_initBy) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_initBy(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_initBy(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_initBy(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_target) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_target(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_target(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_target(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.generated_KMF_ID;
            },
            findLinkByID: function (key) {
              return this._link.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_link) {
                return this.findLinkByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_initBy) {
                var objFound = this.initBy;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_target) {
                var objFound_0 = this.target;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_link, _.org.kevoree.util.Constants.org_kevoree_NodeLink);
                {
                  var tmp$0 = this._link.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._link.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_link);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_link);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_initBy, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.initBy, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_initBy);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_initBy);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_target, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.target, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_target);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_target);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NodeNetwork;
            }
          }),
          NetworkPropertyImpl: Kotlin.createClass([_c.NetworkProperty, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$value = null;
            this.$lastCheck = null;
          }, /** @lends _.org.kevoree.impl.NetworkPropertyImpl.prototype */ {
            delete: function () {
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            value: {
              get: function () {
                return this.$value;
              },
              set: function (iP) {
                this.internal_value(iP, true);
              }
            },
            internal_value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.value)) {
                var oldPath = this.path();
                this.$value = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_value, this.value));
                }
              }
            },
            lastCheck: {
              get: function () {
                return this.$lastCheck;
              },
              set: function (iP) {
                this.internal_lastCheck(iP, true);
              }
            },
            internal_lastCheck: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.lastCheck)) {
                var oldPath = this.path();
                this.$lastCheck = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lastCheck, this.lastCheck));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_value) {
                this.internal_value(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lastCheck) {
                this.internal_lastCheck(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findByID: function (relationName, idP) {
              {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.value, _.org.kevoree.util.Constants.Att_value, this);
              visitor.visit(this.lastCheck, _.org.kevoree.util.Constants.Att_lastCheck, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NetworkProperty;
            }
          }),
          AdaptationPrimitiveTypeImpl: Kotlin.createClass([_c.AdaptationPrimitiveType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
          }, /** @lends _.org.kevoree.impl.AdaptationPrimitiveTypeImpl.prototype */ {
            delete: function () {
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findByID: function (relationName, idP) {
              {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType;
            }
          }),
          NodeLinkImpl: Kotlin.createClass([_c.NodeLink, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$networkType = null;
            this.$estimatedRate = null;
            this.$lastCheck = null;
            this.$zoneID = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this._networkProperties = new Kotlin.PrimitiveHashMap(0);
            this.removeAllNetworkPropertiesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.NodeLinkImpl.prototype */ {
            delete: function () {
              var tmp$0;
              (tmp$0 = this._networkProperties) != null ? tmp$0.clear() : null;
            },
            networkType: {
              get: function () {
                return this.$networkType;
              },
              set: function (iP) {
                this.internal_networkType(iP, true);
              }
            },
            internal_networkType: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.networkType)) {
                var oldPath = this.path();
                this.$networkType = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_networkType, this.networkType));
                }
              }
            },
            estimatedRate: {
              get: function () {
                return this.$estimatedRate;
              },
              set: function (iP) {
                this.internal_estimatedRate(iP, true);
              }
            },
            internal_estimatedRate: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.estimatedRate) {
                var oldPath = this.path();
                this.$estimatedRate = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_estimatedRate, this.estimatedRate));
                }
              }
            },
            lastCheck: {
              get: function () {
                return this.$lastCheck;
              },
              set: function (iP) {
                this.internal_lastCheck(iP, true);
              }
            },
            internal_lastCheck: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.lastCheck)) {
                var oldPath = this.path();
                this.$lastCheck = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lastCheck, this.lastCheck));
                }
              }
            },
            zoneID: {
              get: function () {
                return this.$zoneID;
              },
              set: function (iP) {
                this.internal_zoneID(iP, true);
              }
            },
            internal_zoneID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.zoneID)) {
                var oldPath = this.path();
                this.$zoneID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_zoneID, this.zoneID));
                }
              }
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            },
            networkProperties: {
              get: function () {
                return _.kotlin.toList(this._networkProperties.values());
              },
              set: function (networkPropertiesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (networkPropertiesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_networkProperties(networkPropertiesP, true, true);
              }
            },
            internal_networkProperties: function (networkPropertiesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._networkProperties.values(), networkPropertiesP)) {
                this._networkProperties.clear();
                {
                  var tmp$0 = networkPropertiesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._networkProperties.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_networkProperties, el), _.org.kevoree.util.Constants.Ref_networkProperties);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP));
                }
              }
            },
            doAddNetworkProperties: function (networkPropertiesP) {
              var _key_ = (networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._networkProperties.containsKey(_key_)) {
                this._networkProperties.put(_key_, networkPropertiesP);
                (networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP), _.org.kevoree.util.Constants.Ref_networkProperties);
              }
            },
            addNetworkProperties: function (networkPropertiesP) {
              this.internal_addNetworkProperties(networkPropertiesP, true, true);
            },
            addAllNetworkProperties: function (networkPropertiesP) {
              this.internal_addAllNetworkProperties(networkPropertiesP, true, true);
            },
            internal_addNetworkProperties: function (networkPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNetworkProperties(networkPropertiesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP));
              }
            },
            internal_addAllNetworkProperties: function (networkPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = networkPropertiesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNetworkProperties(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = networkPropertiesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNetworkProperties(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP));
              }
            },
            removeNetworkProperties: function (networkPropertiesP) {
              this.internal_removeNetworkProperties(networkPropertiesP, true, true);
            },
            removeAllNetworkProperties: function () {
              this.internal_removeAllNetworkProperties(true, true);
            },
            internal_removeNetworkProperties: function (networkPropertiesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._networkProperties.size() !== 0 && this._networkProperties.containsKey((networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).internalGetKey())) {
                this._networkProperties.remove((networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()).internalGetKey());
                ((networkPropertiesP != null ? networkPropertiesP : Kotlin.throwNPE()) != null ? networkPropertiesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllNetworkPropertiesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, networkPropertiesP));
                }
              }
            },
            internal_removeAllNetworkProperties: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNetworkPropertiesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.networkProperties) != null ? tmp$0 : Kotlin.throwNPE();
              this._networkProperties.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkProperties, temp_els));
                this.removeAllNetworkPropertiesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_networkType) {
                this.internal_networkType(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_estimatedRate) {
                this.internal_estimatedRate(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_lastCheck) {
                this.internal_lastCheck(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_zoneID) {
                this.internal_zoneID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_networkProperties) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addNetworkProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllNetworkProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeNetworkProperties(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllNetworkProperties();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._networkProperties.size() !== 0 && this._networkProperties.containsKey(value)) {
                    var obj = this._networkProperties.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._networkProperties.remove(value);
                    this._networkProperties.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.generated_KMF_ID;
            },
            findNetworkPropertiesByID: function (key) {
              return this._networkProperties.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_networkProperties) {
                return this.findNetworkPropertiesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_networkProperties, _.org.kevoree.util.Constants.org_kevoree_NetworkProperty);
                {
                  var tmp$0 = this._networkProperties.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._networkProperties.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_networkProperties);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_networkProperties);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.estimatedRate, _.org.kevoree.util.Constants.Att_estimatedRate, this);
              visitor.visit(this.networkType, _.org.kevoree.util.Constants.Att_networkType, this);
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.lastCheck, _.org.kevoree.util.Constants.Att_lastCheck, this);
              visitor.visit(this.zoneID, _.org.kevoree.util.Constants.Att_zoneID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NodeLink;
            }
          }),
          DictionaryValueImpl: Kotlin.createClass([_c.DictionaryValue, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$value = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this.$attribute = null;
            this.$targetNode = null;
          }, /** @lends _.org.kevoree.impl.DictionaryValueImpl.prototype */ {
            delete: function () {
              this.attribute = null;
              this.targetNode = null;
            },
            value: {
              get: function () {
                return this.$value;
              },
              set: function (iP) {
                this.internal_value(iP, true);
              }
            },
            internal_value: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.value)) {
                var oldPath = this.path();
                this.$value = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_value, this.value));
                }
              }
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            },
            attribute: {
              get: function () {
                return this.$attribute;
              },
              set: function (attributeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_attribute(attributeP, true, true);
              }
            },
            internal_attribute: function (attributeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$attribute, attributeP)) {
                this.$attribute = attributeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_attribute, attributeP));
                }
              }
            },
            targetNode: {
              get: function () {
                return this.$targetNode;
              },
              set: function (targetNodeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_targetNode(targetNodeP, true, true);
              }
            },
            internal_targetNode: function (targetNodeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$targetNode, targetNodeP)) {
                this.$targetNode = targetNodeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_targetNode, targetNodeP));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_value) {
                this.internal_value(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_attribute) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_attribute(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_attribute(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_attribute(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_targetNode) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_targetNode(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_targetNode(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_targetNode(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.generated_KMF_ID;
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_attribute) {
                var objFound = this.attribute;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_targetNode) {
                var objFound_0 = this.targetNode;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_attribute, _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute);
                this.internal_visit(visitor, this.attribute, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_attribute);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_attribute);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_targetNode, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                this.internal_visit(visitor, this.targetNode, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_targetNode);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_targetNode);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.value, _.org.kevoree.util.Constants.Att_value, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryValue;
            }
          }),
          OperationImpl: Kotlin.createClass([_c.Operation, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this._parameters = new Kotlin.PrimitiveHashMap(0);
            this.removeAllParametersCurrentlyProcessing = false;
            this.$returnType = null;
          }, /** @lends _.org.kevoree.impl.OperationImpl.prototype */ {
            delete: function () {
              var tmp$0;
              (tmp$0 = this._parameters) != null ? tmp$0.clear() : null;
              this.returnType = null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            parameters: {
              get: function () {
                return _.kotlin.toList(this._parameters.values());
              },
              set: function (parametersP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (parametersP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_parameters(parametersP, true, true);
              }
            },
            internal_parameters: function (parametersP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._parameters.values(), parametersP)) {
                this._parameters.clear();
                {
                  var tmp$0 = parametersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._parameters.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_parameters, el), _.org.kevoree.util.Constants.Ref_parameters);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP));
                }
              }
            },
            doAddParameters: function (parametersP) {
              var _key_ = (parametersP != null ? parametersP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._parameters.containsKey(_key_)) {
                this._parameters.put(_key_, parametersP);
                (parametersP != null ? parametersP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_parameters, parametersP), _.org.kevoree.util.Constants.Ref_parameters);
              }
            },
            addParameters: function (parametersP) {
              this.internal_addParameters(parametersP, true, true);
            },
            addAllParameters: function (parametersP) {
              this.internal_addAllParameters(parametersP, true, true);
            },
            internal_addParameters: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddParameters(parametersP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP));
              }
            },
            internal_addAllParameters: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = parametersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddParameters(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = parametersP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddParameters(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP));
              }
            },
            removeParameters: function (parametersP) {
              this.internal_removeParameters(parametersP, true, true);
            },
            removeAllParameters: function () {
              this.internal_removeAllParameters(true, true);
            },
            internal_removeParameters: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._parameters.size() !== 0 && this._parameters.containsKey((parametersP != null ? parametersP : Kotlin.throwNPE()).internalGetKey())) {
                this._parameters.remove((parametersP != null ? parametersP : Kotlin.throwNPE()).internalGetKey());
                ((parametersP != null ? parametersP : Kotlin.throwNPE()) != null ? parametersP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllParametersCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP));
                }
              }
            },
            internal_removeAllParameters: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllParametersCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.parameters) != null ? tmp$0 : Kotlin.throwNPE();
              this._parameters.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, temp_els));
                this.removeAllParametersCurrentlyProcessing = false;
              }
            },
            returnType: {
              get: function () {
                return this.$returnType;
              },
              set: function (returnTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_returnType(returnTypeP, true, true);
              }
            },
            internal_returnType: function (returnTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$returnType, returnTypeP)) {
                this.$returnType = returnTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_returnType, returnTypeP));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_parameters) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllParameters();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._parameters.size() !== 0 && this._parameters.containsKey(value)) {
                    var obj = this._parameters.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._parameters.remove(value);
                    this._parameters.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_returnType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_returnType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_returnType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_returnType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findParametersByID: function (key) {
              return this._parameters.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_parameters) {
                return this.findParametersByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_returnType) {
                var objFound = this.returnType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_parameters, _.org.kevoree.util.Constants.org_kevoree_Parameter);
                {
                  var tmp$0 = this._parameters.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._parameters.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_parameters);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_parameters);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_returnType, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                this.internal_visit(visitor, this.returnType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_returnType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_returnType);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Operation;
            }
          }),
          DefaultKevoreeFactory: Kotlin.createClass(_c.KevoreeFactory, null, /** @lends _.org.kevoree.impl.DefaultKevoreeFactory.prototype */ {
            getVersion: function () {
              return '2.0.12-SNAPSHOT';
            },
            createComponentInstance: function () {
              return new _.org.kevoree.impl.ComponentInstanceImpl();
            },
            createComponentType: function () {
              return new _.org.kevoree.impl.ComponentTypeImpl();
            },
            createContainerNode: function () {
              return new _.org.kevoree.impl.ContainerNodeImpl();
            },
            createContainerRoot: function () {
              return new _.org.kevoree.impl.ContainerRootImpl();
            },
            createPort: function () {
              return new _.org.kevoree.impl.PortImpl();
            },
            createNamespace: function () {
              return new _.org.kevoree.impl.NamespaceImpl();
            },
            createDictionary: function () {
              return new _.org.kevoree.impl.DictionaryImpl();
            },
            createDictionaryType: function () {
              return new _.org.kevoree.impl.DictionaryTypeImpl();
            },
            createDictionaryAttribute: function () {
              return new _.org.kevoree.impl.DictionaryAttributeImpl();
            },
            createDictionaryValue: function () {
              return new _.org.kevoree.impl.DictionaryValueImpl();
            },
            createCompositeType: function () {
              return new _.org.kevoree.impl.CompositeTypeImpl();
            },
            createPortTypeRef: function () {
              return new _.org.kevoree.impl.PortTypeRefImpl();
            },
            createWire: function () {
              return new _.org.kevoree.impl.WireImpl();
            },
            createServicePortType: function () {
              return new _.org.kevoree.impl.ServicePortTypeImpl();
            },
            createOperation: function () {
              return new _.org.kevoree.impl.OperationImpl();
            },
            createParameter: function () {
              return new _.org.kevoree.impl.ParameterImpl();
            },
            createTypedElement: function () {
              return new _.org.kevoree.impl.TypedElementImpl();
            },
            createMessagePortType: function () {
              return new _.org.kevoree.impl.MessagePortTypeImpl();
            },
            createRepository: function () {
              return new _.org.kevoree.impl.RepositoryImpl();
            },
            createDeployUnit: function () {
              return new _.org.kevoree.impl.DeployUnitImpl();
            },
            createTypeLibrary: function () {
              return new _.org.kevoree.impl.TypeLibraryImpl();
            },
            createNamedElement: function () {
              return new _.org.kevoree.impl.NamedElementImpl();
            },
            createIntegrationPattern: function () {
              return new _.org.kevoree.impl.IntegrationPatternImpl();
            },
            createExtraFonctionalProperty: function () {
              return new _.org.kevoree.impl.ExtraFonctionalPropertyImpl();
            },
            createPortTypeMapping: function () {
              return new _.org.kevoree.impl.PortTypeMappingImpl();
            },
            createChannel: function () {
              return new _.org.kevoree.impl.ChannelImpl();
            },
            createMBinding: function () {
              return new _.org.kevoree.impl.MBindingImpl();
            },
            createNodeNetwork: function () {
              return new _.org.kevoree.impl.NodeNetworkImpl();
            },
            createNodeLink: function () {
              return new _.org.kevoree.impl.NodeLinkImpl();
            },
            createNetworkProperty: function () {
              return new _.org.kevoree.impl.NetworkPropertyImpl();
            },
            createChannelType: function () {
              return new _.org.kevoree.impl.ChannelTypeImpl();
            },
            createInstance: function () {
              return new _.org.kevoree.impl.InstanceImpl();
            },
            createGroup: function () {
              return new _.org.kevoree.impl.GroupImpl();
            },
            createGroupType: function () {
              return new _.org.kevoree.impl.GroupTypeImpl();
            },
            createNodeType: function () {
              return new _.org.kevoree.impl.NodeTypeImpl();
            },
            createAdaptationPrimitiveType: function () {
              return new _.org.kevoree.impl.AdaptationPrimitiveTypeImpl();
            },
            createAdaptationPrimitiveTypeRef: function () {
              return new _.org.kevoree.impl.AdaptationPrimitiveTypeRefImpl();
            },
            create: function (metaClassName) {
              if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ComponentInstance) {
                return this.createComponentInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ComponentInstance) {
                return this.createComponentInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ComponentType) {
                return this.createComponentType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ComponentType) {
                return this.createComponentType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ContainerNode) {
                return this.createContainerNode();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ContainerNode) {
                return this.createContainerNode();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ContainerRoot) {
                return this.createContainerRoot();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ContainerRoot) {
                return this.createContainerRoot();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Port) {
                return this.createPort();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Port) {
                return this.createPort();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Namespace) {
                return this.createNamespace();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Namespace) {
                return this.createNamespace();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Dictionary) {
                return this.createDictionary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Dictionary) {
                return this.createDictionary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryType) {
                return this.createDictionaryType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DictionaryType) {
                return this.createDictionaryType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute) {
                return this.createDictionaryAttribute();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DictionaryAttribute) {
                return this.createDictionaryAttribute();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryValue) {
                return this.createDictionaryValue();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DictionaryValue) {
                return this.createDictionaryValue();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_CompositeType) {
                return this.createCompositeType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_CompositeType) {
                return this.createCompositeType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_PortTypeRef) {
                return this.createPortTypeRef();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_PortTypeRef) {
                return this.createPortTypeRef();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Wire) {
                return this.createWire();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Wire) {
                return this.createWire();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ServicePortType) {
                return this.createServicePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ServicePortType) {
                return this.createServicePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Operation) {
                return this.createOperation();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Operation) {
                return this.createOperation();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Parameter) {
                return this.createParameter();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Parameter) {
                return this.createParameter();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_TypedElement) {
                return this.createTypedElement();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_TypedElement) {
                return this.createTypedElement();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_MessagePortType) {
                return this.createMessagePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_MessagePortType) {
                return this.createMessagePortType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Repository) {
                return this.createRepository();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Repository) {
                return this.createRepository();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DeployUnit) {
                return this.createDeployUnit();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_DeployUnit) {
                return this.createDeployUnit();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_TypeLibrary) {
                return this.createTypeLibrary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_TypeLibrary) {
                return this.createTypeLibrary();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NamedElement) {
                return this.createNamedElement();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NamedElement) {
                return this.createNamedElement();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_IntegrationPattern) {
                return this.createIntegrationPattern();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_IntegrationPattern) {
                return this.createIntegrationPattern();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty) {
                return this.createExtraFonctionalProperty();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ExtraFonctionalProperty) {
                return this.createExtraFonctionalProperty();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping) {
                return this.createPortTypeMapping();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_PortTypeMapping) {
                return this.createPortTypeMapping();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Channel) {
                return this.createChannel();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Channel) {
                return this.createChannel();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_MBinding) {
                return this.createMBinding();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_MBinding) {
                return this.createMBinding();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NodeNetwork) {
                return this.createNodeNetwork();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NodeNetwork) {
                return this.createNodeNetwork();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NodeLink) {
                return this.createNodeLink();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NodeLink) {
                return this.createNodeLink();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NetworkProperty) {
                return this.createNetworkProperty();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NetworkProperty) {
                return this.createNetworkProperty();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ChannelType) {
                return this.createChannelType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_ChannelType) {
                return this.createChannelType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Instance) {
                return this.createInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Instance) {
                return this.createInstance();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Group) {
                return this.createGroup();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_Group) {
                return this.createGroup();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_GroupType) {
                return this.createGroupType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_GroupType) {
                return this.createGroupType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NodeType) {
                return this.createNodeType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_NodeType) {
                return this.createNodeType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType) {
                return this.createAdaptationPrimitiveType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_AdaptationPrimitiveType) {
                return this.createAdaptationPrimitiveType();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveTypeRef) {
                return this.createAdaptationPrimitiveTypeRef();
              }
               else if (metaClassName === _.org.kevoree.util.Constants.CN_AdaptationPrimitiveTypeRef) {
                return this.createAdaptationPrimitiveTypeRef();
              }
               else {
                return null;
              }
            }
          }),
          ContainerRootImpl: Kotlin.createClass([_c.ContainerRoot, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this._nodes = new Kotlin.PrimitiveHashMap(0);
            this.removeAllNodesCurrentlyProcessing = false;
            this._typeDefinitions = new Kotlin.PrimitiveHashMap(0);
            this.removeAllTypeDefinitionsCurrentlyProcessing = false;
            this._repositories = new Kotlin.PrimitiveHashMap(0);
            this.removeAllRepositoriesCurrentlyProcessing = false;
            this._dataTypes = new Kotlin.PrimitiveHashMap(0);
            this.removeAllDataTypesCurrentlyProcessing = false;
            this._libraries = new Kotlin.PrimitiveHashMap(0);
            this.removeAllLibrariesCurrentlyProcessing = false;
            this._hubs = new Kotlin.PrimitiveHashMap(0);
            this.removeAllHubsCurrentlyProcessing = false;
            this._mBindings = new Kotlin.PrimitiveHashMap(0);
            this.removeAllMBindingsCurrentlyProcessing = false;
            this._deployUnits = new Kotlin.PrimitiveHashMap(0);
            this.removeAllDeployUnitsCurrentlyProcessing = false;
            this._nodeNetworks = new Kotlin.PrimitiveHashMap(0);
            this.removeAllNodeNetworksCurrentlyProcessing = false;
            this._groups = new Kotlin.PrimitiveHashMap(0);
            this.removeAllGroupsCurrentlyProcessing = false;
            this._adaptationPrimitiveTypes = new Kotlin.PrimitiveHashMap(0);
            this.removeAllAdaptationPrimitiveTypesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ContainerRootImpl.prototype */ {
            delete: function () {
              var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7, tmp$8, tmp$9, tmp$10;
              (tmp$0 = this._nodes) != null ? tmp$0.clear() : null;
              (tmp$1 = this._typeDefinitions) != null ? tmp$1.clear() : null;
              (tmp$2 = this._repositories) != null ? tmp$2.clear() : null;
              (tmp$3 = this._dataTypes) != null ? tmp$3.clear() : null;
              (tmp$4 = this._libraries) != null ? tmp$4.clear() : null;
              (tmp$5 = this._hubs) != null ? tmp$5.clear() : null;
              (tmp$6 = this._mBindings) != null ? tmp$6.clear() : null;
              (tmp$7 = this._deployUnits) != null ? tmp$7.clear() : null;
              (tmp$8 = this._nodeNetworks) != null ? tmp$8.clear() : null;
              (tmp$9 = this._groups) != null ? tmp$9.clear() : null;
              (tmp$10 = this._adaptationPrimitiveTypes) != null ? tmp$10.clear() : null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            },
            nodes: {
              get: function () {
                return _.kotlin.toList(this._nodes.values());
              },
              set: function (nodesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (nodesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_nodes(nodesP, true, true);
              }
            },
            internal_nodes: function (nodesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._nodes.values(), nodesP)) {
                this._nodes.clear();
                {
                  var tmp$0 = nodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._nodes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_nodes, el), _.org.kevoree.util.Constants.Ref_nodes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP));
                }
              }
            },
            doAddNodes: function (nodesP) {
              var _key_ = (nodesP != null ? nodesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._nodes.containsKey(_key_)) {
                this._nodes.put(_key_, nodesP);
                (nodesP != null ? nodesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_nodes, nodesP), _.org.kevoree.util.Constants.Ref_nodes);
              }
            },
            addNodes: function (nodesP) {
              this.internal_addNodes(nodesP, true, true);
            },
            addAllNodes: function (nodesP) {
              this.internal_addAllNodes(nodesP, true, true);
            },
            internal_addNodes: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNodes(nodesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP));
              }
            },
            internal_addAllNodes: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = nodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNodes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = nodesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNodes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP));
              }
            },
            removeNodes: function (nodesP) {
              this.internal_removeNodes(nodesP, true, true);
            },
            removeAllNodes: function () {
              this.internal_removeAllNodes(true, true);
            },
            internal_removeNodes: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._nodes.size() !== 0 && this._nodes.containsKey((nodesP != null ? nodesP : Kotlin.throwNPE()).internalGetKey())) {
                this._nodes.remove((nodesP != null ? nodesP : Kotlin.throwNPE()).internalGetKey());
                ((nodesP != null ? nodesP : Kotlin.throwNPE()) != null ? nodesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllNodesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP));
                }
              }
            },
            internal_removeAllNodes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNodesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.nodes) != null ? tmp$0 : Kotlin.throwNPE();
              this._nodes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, temp_els));
                this.removeAllNodesCurrentlyProcessing = false;
              }
            },
            typeDefinitions: {
              get: function () {
                return _.kotlin.toList(this._typeDefinitions.values());
              },
              set: function (typeDefinitionsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (typeDefinitionsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_typeDefinitions(typeDefinitionsP, true, true);
              }
            },
            internal_typeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._typeDefinitions.values(), typeDefinitionsP)) {
                this._typeDefinitions.clear();
                {
                  var tmp$0 = typeDefinitionsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._typeDefinitions.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_typeDefinitions, el), _.org.kevoree.util.Constants.Ref_typeDefinitions);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP));
                }
              }
            },
            doAddTypeDefinitions: function (typeDefinitionsP) {
              var _key_ = (typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._typeDefinitions.containsKey(_key_)) {
                this._typeDefinitions.put(_key_, typeDefinitionsP);
                (typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP), _.org.kevoree.util.Constants.Ref_typeDefinitions);
              }
            },
            addTypeDefinitions: function (typeDefinitionsP) {
              this.internal_addTypeDefinitions(typeDefinitionsP, true, true);
            },
            addAllTypeDefinitions: function (typeDefinitionsP) {
              this.internal_addAllTypeDefinitions(typeDefinitionsP, true, true);
            },
            internal_addTypeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddTypeDefinitions(typeDefinitionsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP));
              }
            },
            internal_addAllTypeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = typeDefinitionsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddTypeDefinitions(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = typeDefinitionsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddTypeDefinitions(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP));
              }
            },
            removeTypeDefinitions: function (typeDefinitionsP) {
              this.internal_removeTypeDefinitions(typeDefinitionsP, true, true);
            },
            removeAllTypeDefinitions: function () {
              this.internal_removeAllTypeDefinitions(true, true);
            },
            internal_removeTypeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._typeDefinitions.size() !== 0 && this._typeDefinitions.containsKey((typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).internalGetKey())) {
                this._typeDefinitions.remove((typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()).internalGetKey());
                ((typeDefinitionsP != null ? typeDefinitionsP : Kotlin.throwNPE()) != null ? typeDefinitionsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllTypeDefinitionsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP));
                }
              }
            },
            internal_removeAllTypeDefinitions: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllTypeDefinitionsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.typeDefinitions) != null ? tmp$0 : Kotlin.throwNPE();
              this._typeDefinitions.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, temp_els));
                this.removeAllTypeDefinitionsCurrentlyProcessing = false;
              }
            },
            repositories: {
              get: function () {
                return _.kotlin.toList(this._repositories.values());
              },
              set: function (repositoriesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (repositoriesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_repositories(repositoriesP, true, true);
              }
            },
            internal_repositories: function (repositoriesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._repositories.values(), repositoriesP)) {
                this._repositories.clear();
                {
                  var tmp$0 = repositoriesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._repositories.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_repositories, el), _.org.kevoree.util.Constants.Ref_repositories);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP));
                }
              }
            },
            doAddRepositories: function (repositoriesP) {
              var _key_ = (repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._repositories.containsKey(_key_)) {
                this._repositories.put(_key_, repositoriesP);
                (repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP), _.org.kevoree.util.Constants.Ref_repositories);
              }
            },
            addRepositories: function (repositoriesP) {
              this.internal_addRepositories(repositoriesP, true, true);
            },
            addAllRepositories: function (repositoriesP) {
              this.internal_addAllRepositories(repositoriesP, true, true);
            },
            internal_addRepositories: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRepositories(repositoriesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP));
              }
            },
            internal_addAllRepositories: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = repositoriesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRepositories(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = repositoriesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRepositories(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP));
              }
            },
            removeRepositories: function (repositoriesP) {
              this.internal_removeRepositories(repositoriesP, true, true);
            },
            removeAllRepositories: function () {
              this.internal_removeAllRepositories(true, true);
            },
            internal_removeRepositories: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._repositories.size() !== 0 && this._repositories.containsKey((repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).internalGetKey())) {
                this._repositories.remove((repositoriesP != null ? repositoriesP : Kotlin.throwNPE()).internalGetKey());
                ((repositoriesP != null ? repositoriesP : Kotlin.throwNPE()) != null ? repositoriesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRepositoriesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP));
                }
              }
            },
            internal_removeAllRepositories: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRepositoriesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.repositories) != null ? tmp$0 : Kotlin.throwNPE();
              this._repositories.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, temp_els));
                this.removeAllRepositoriesCurrentlyProcessing = false;
              }
            },
            dataTypes: {
              get: function () {
                return _.kotlin.toList(this._dataTypes.values());
              },
              set: function (dataTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (dataTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_dataTypes(dataTypesP, true, true);
              }
            },
            internal_dataTypes: function (dataTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._dataTypes.values(), dataTypesP)) {
                this._dataTypes.clear();
                {
                  var tmp$0 = dataTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._dataTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_dataTypes, el), _.org.kevoree.util.Constants.Ref_dataTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP));
                }
              }
            },
            doAddDataTypes: function (dataTypesP) {
              var _key_ = (dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._dataTypes.containsKey(_key_)) {
                this._dataTypes.put(_key_, dataTypesP);
                (dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP), _.org.kevoree.util.Constants.Ref_dataTypes);
              }
            },
            addDataTypes: function (dataTypesP) {
              this.internal_addDataTypes(dataTypesP, true, true);
            },
            addAllDataTypes: function (dataTypesP) {
              this.internal_addAllDataTypes(dataTypesP, true, true);
            },
            internal_addDataTypes: function (dataTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDataTypes(dataTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP));
              }
            },
            internal_addAllDataTypes: function (dataTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = dataTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDataTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = dataTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDataTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP));
              }
            },
            removeDataTypes: function (dataTypesP) {
              this.internal_removeDataTypes(dataTypesP, true, true);
            },
            removeAllDataTypes: function () {
              this.internal_removeAllDataTypes(true, true);
            },
            internal_removeDataTypes: function (dataTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._dataTypes.size() !== 0 && this._dataTypes.containsKey((dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._dataTypes.remove((dataTypesP != null ? dataTypesP : Kotlin.throwNPE()).internalGetKey());
                ((dataTypesP != null ? dataTypesP : Kotlin.throwNPE()) != null ? dataTypesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllDataTypesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, dataTypesP));
                }
              }
            },
            internal_removeAllDataTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllDataTypesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.dataTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._dataTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dataTypes, temp_els));
                this.removeAllDataTypesCurrentlyProcessing = false;
              }
            },
            libraries: {
              get: function () {
                return _.kotlin.toList(this._libraries.values());
              },
              set: function (librariesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (librariesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_libraries(librariesP, true, true);
              }
            },
            internal_libraries: function (librariesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._libraries.values(), librariesP)) {
                this._libraries.clear();
                {
                  var tmp$0 = librariesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._libraries.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_libraries, el), _.org.kevoree.util.Constants.Ref_libraries);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP));
                }
              }
            },
            doAddLibraries: function (librariesP) {
              var _key_ = (librariesP != null ? librariesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._libraries.containsKey(_key_)) {
                this._libraries.put(_key_, librariesP);
                (librariesP != null ? librariesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_libraries, librariesP), _.org.kevoree.util.Constants.Ref_libraries);
              }
            },
            addLibraries: function (librariesP) {
              this.internal_addLibraries(librariesP, true, true);
            },
            addAllLibraries: function (librariesP) {
              this.internal_addAllLibraries(librariesP, true, true);
            },
            internal_addLibraries: function (librariesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddLibraries(librariesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP));
              }
            },
            internal_addAllLibraries: function (librariesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = librariesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddLibraries(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = librariesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddLibraries(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP));
              }
            },
            removeLibraries: function (librariesP) {
              this.internal_removeLibraries(librariesP, true, true);
            },
            removeAllLibraries: function () {
              this.internal_removeAllLibraries(true, true);
            },
            internal_removeLibraries: function (librariesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._libraries.size() !== 0 && this._libraries.containsKey((librariesP != null ? librariesP : Kotlin.throwNPE()).internalGetKey())) {
                this._libraries.remove((librariesP != null ? librariesP : Kotlin.throwNPE()).internalGetKey());
                ((librariesP != null ? librariesP : Kotlin.throwNPE()) != null ? librariesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllLibrariesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, librariesP));
                }
              }
            },
            internal_removeAllLibraries: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllLibrariesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.libraries) != null ? tmp$0 : Kotlin.throwNPE();
              this._libraries.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_libraries, temp_els));
                this.removeAllLibrariesCurrentlyProcessing = false;
              }
            },
            hubs: {
              get: function () {
                return _.kotlin.toList(this._hubs.values());
              },
              set: function (hubsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (hubsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_hubs(hubsP, true, true);
              }
            },
            internal_hubs: function (hubsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._hubs.values(), hubsP)) {
                this._hubs.clear();
                {
                  var tmp$0 = hubsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._hubs.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_hubs, el), _.org.kevoree.util.Constants.Ref_hubs);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP));
                }
              }
            },
            doAddHubs: function (hubsP) {
              var _key_ = (hubsP != null ? hubsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._hubs.containsKey(_key_)) {
                this._hubs.put(_key_, hubsP);
                (hubsP != null ? hubsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_hubs, hubsP), _.org.kevoree.util.Constants.Ref_hubs);
              }
            },
            addHubs: function (hubsP) {
              this.internal_addHubs(hubsP, true, true);
            },
            addAllHubs: function (hubsP) {
              this.internal_addAllHubs(hubsP, true, true);
            },
            internal_addHubs: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddHubs(hubsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP));
              }
            },
            internal_addAllHubs: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = hubsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddHubs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = hubsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddHubs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP));
              }
            },
            removeHubs: function (hubsP) {
              this.internal_removeHubs(hubsP, true, true);
            },
            removeAllHubs: function () {
              this.internal_removeAllHubs(true, true);
            },
            internal_removeHubs: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._hubs.size() !== 0 && this._hubs.containsKey((hubsP != null ? hubsP : Kotlin.throwNPE()).internalGetKey())) {
                this._hubs.remove((hubsP != null ? hubsP : Kotlin.throwNPE()).internalGetKey());
                ((hubsP != null ? hubsP : Kotlin.throwNPE()) != null ? hubsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllHubsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP));
                }
              }
            },
            internal_removeAllHubs: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllHubsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.hubs) != null ? tmp$0 : Kotlin.throwNPE();
              this._hubs.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, temp_els));
                this.removeAllHubsCurrentlyProcessing = false;
              }
            },
            mBindings: {
              get: function () {
                return _.kotlin.toList(this._mBindings.values());
              },
              set: function (mBindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (mBindingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_mBindings(mBindingsP, true, true);
              }
            },
            internal_mBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._mBindings.values(), mBindingsP)) {
                this._mBindings.clear();
                {
                  var tmp$0 = mBindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._mBindings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_mBindings, el), _.org.kevoree.util.Constants.Ref_mBindings);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP));
                }
              }
            },
            doAddMBindings: function (mBindingsP) {
              var _key_ = (mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._mBindings.containsKey(_key_)) {
                this._mBindings.put(_key_, mBindingsP);
                (mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP), _.org.kevoree.util.Constants.Ref_mBindings);
              }
            },
            addMBindings: function (mBindingsP) {
              this.internal_addMBindings(mBindingsP, true, true);
            },
            addAllMBindings: function (mBindingsP) {
              this.internal_addAllMBindings(mBindingsP, true, true);
            },
            internal_addMBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMBindings(mBindingsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP));
              }
            },
            internal_addAllMBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = mBindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMBindings(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = mBindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP));
              }
            },
            removeMBindings: function (mBindingsP) {
              this.internal_removeMBindings(mBindingsP, true, true);
            },
            removeAllMBindings: function () {
              this.internal_removeAllMBindings(true, true);
            },
            internal_removeMBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._mBindings.size() !== 0 && this._mBindings.containsKey((mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._mBindings.remove((mBindingsP != null ? mBindingsP : Kotlin.throwNPE()).internalGetKey());
                ((mBindingsP != null ? mBindingsP : Kotlin.throwNPE()) != null ? mBindingsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllMBindingsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP));
                }
              }
            },
            internal_removeAllMBindings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMBindingsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.mBindings) != null ? tmp$0 : Kotlin.throwNPE();
              this._mBindings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, temp_els));
                this.removeAllMBindingsCurrentlyProcessing = false;
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_deployUnits, el), _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
                (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP), _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                ((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()) != null ? deployUnitsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllDeployUnitsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllDeployUnitsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
                this.removeAllDeployUnitsCurrentlyProcessing = false;
              }
            },
            nodeNetworks: {
              get: function () {
                return _.kotlin.toList(this._nodeNetworks.values());
              },
              set: function (nodeNetworksP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (nodeNetworksP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_nodeNetworks(nodeNetworksP, true, true);
              }
            },
            internal_nodeNetworks: function (nodeNetworksP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._nodeNetworks.values(), nodeNetworksP)) {
                this._nodeNetworks.clear();
                {
                  var tmp$0 = nodeNetworksP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._nodeNetworks.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_nodeNetworks, el), _.org.kevoree.util.Constants.Ref_nodeNetworks);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP));
                }
              }
            },
            doAddNodeNetworks: function (nodeNetworksP) {
              var _key_ = (nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._nodeNetworks.containsKey(_key_)) {
                this._nodeNetworks.put(_key_, nodeNetworksP);
                (nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP), _.org.kevoree.util.Constants.Ref_nodeNetworks);
              }
            },
            addNodeNetworks: function (nodeNetworksP) {
              this.internal_addNodeNetworks(nodeNetworksP, true, true);
            },
            addAllNodeNetworks: function (nodeNetworksP) {
              this.internal_addAllNodeNetworks(nodeNetworksP, true, true);
            },
            internal_addNodeNetworks: function (nodeNetworksP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNodeNetworks(nodeNetworksP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP));
              }
            },
            internal_addAllNodeNetworks: function (nodeNetworksP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = nodeNetworksP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNodeNetworks(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = nodeNetworksP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNodeNetworks(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP));
              }
            },
            removeNodeNetworks: function (nodeNetworksP) {
              this.internal_removeNodeNetworks(nodeNetworksP, true, true);
            },
            removeAllNodeNetworks: function () {
              this.internal_removeAllNodeNetworks(true, true);
            },
            internal_removeNodeNetworks: function (nodeNetworksP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._nodeNetworks.size() !== 0 && this._nodeNetworks.containsKey((nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).internalGetKey())) {
                this._nodeNetworks.remove((nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()).internalGetKey());
                ((nodeNetworksP != null ? nodeNetworksP : Kotlin.throwNPE()) != null ? nodeNetworksP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllNodeNetworksCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, nodeNetworksP));
                }
              }
            },
            internal_removeAllNodeNetworks: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNodeNetworksCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.nodeNetworks) != null ? tmp$0 : Kotlin.throwNPE();
              this._nodeNetworks.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodeNetworks, temp_els));
                this.removeAllNodeNetworksCurrentlyProcessing = false;
              }
            },
            groups: {
              get: function () {
                return _.kotlin.toList(this._groups.values());
              },
              set: function (groupsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (groupsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_groups(groupsP, true, true);
              }
            },
            internal_groups: function (groupsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._groups.values(), groupsP)) {
                this._groups.clear();
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._groups.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_groups, el), _.org.kevoree.util.Constants.Ref_groups);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP));
                }
              }
            },
            doAddGroups: function (groupsP) {
              var _key_ = (groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._groups.containsKey(_key_)) {
                this._groups.put(_key_, groupsP);
                (groupsP != null ? groupsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_groups, groupsP), _.org.kevoree.util.Constants.Ref_groups);
              }
            },
            addGroups: function (groupsP) {
              this.internal_addGroups(groupsP, true, true);
            },
            addAllGroups: function (groupsP) {
              this.internal_addAllGroups(groupsP, true, true);
            },
            internal_addGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGroups(groupsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP));
              }
            },
            internal_addAllGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGroups(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = groupsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGroups(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP));
              }
            },
            removeGroups: function (groupsP) {
              this.internal_removeGroups(groupsP, true, true);
            },
            removeAllGroups: function () {
              this.internal_removeAllGroups(true, true);
            },
            internal_removeGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._groups.size() !== 0 && this._groups.containsKey((groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey())) {
                this._groups.remove((groupsP != null ? groupsP : Kotlin.throwNPE()).internalGetKey());
                ((groupsP != null ? groupsP : Kotlin.throwNPE()) != null ? groupsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllGroupsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP));
                }
              }
            },
            internal_removeAllGroups: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllGroupsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.groups) != null ? tmp$0 : Kotlin.throwNPE();
              this._groups.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, temp_els));
                this.removeAllGroupsCurrentlyProcessing = false;
              }
            },
            adaptationPrimitiveTypes: {
              get: function () {
                return _.kotlin.toList(this._adaptationPrimitiveTypes.values());
              },
              set: function (adaptationPrimitiveTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (adaptationPrimitiveTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_adaptationPrimitiveTypes(adaptationPrimitiveTypesP, true, true);
              }
            },
            internal_adaptationPrimitiveTypes: function (adaptationPrimitiveTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._adaptationPrimitiveTypes.values(), adaptationPrimitiveTypesP)) {
                this._adaptationPrimitiveTypes.clear();
                {
                  var tmp$0 = adaptationPrimitiveTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._adaptationPrimitiveTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, el), _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP));
                }
              }
            },
            doAddAdaptationPrimitiveTypes: function (adaptationPrimitiveTypesP) {
              var _key_ = (adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._adaptationPrimitiveTypes.containsKey(_key_)) {
                this._adaptationPrimitiveTypes.put(_key_, adaptationPrimitiveTypesP);
                (adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP), _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes);
              }
            },
            addAdaptationPrimitiveTypes: function (adaptationPrimitiveTypesP) {
              this.internal_addAdaptationPrimitiveTypes(adaptationPrimitiveTypesP, true, true);
            },
            addAllAdaptationPrimitiveTypes: function (adaptationPrimitiveTypesP) {
              this.internal_addAllAdaptationPrimitiveTypes(adaptationPrimitiveTypesP, true, true);
            },
            internal_addAdaptationPrimitiveTypes: function (adaptationPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddAdaptationPrimitiveTypes(adaptationPrimitiveTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP));
              }
            },
            internal_addAllAdaptationPrimitiveTypes: function (adaptationPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = adaptationPrimitiveTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddAdaptationPrimitiveTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = adaptationPrimitiveTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddAdaptationPrimitiveTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP));
              }
            },
            removeAdaptationPrimitiveTypes: function (adaptationPrimitiveTypesP) {
              this.internal_removeAdaptationPrimitiveTypes(adaptationPrimitiveTypesP, true, true);
            },
            removeAllAdaptationPrimitiveTypes: function () {
              this.internal_removeAllAdaptationPrimitiveTypes(true, true);
            },
            internal_removeAdaptationPrimitiveTypes: function (adaptationPrimitiveTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._adaptationPrimitiveTypes.size() !== 0 && this._adaptationPrimitiveTypes.containsKey((adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._adaptationPrimitiveTypes.remove((adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).internalGetKey());
                ((adaptationPrimitiveTypesP != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()) != null ? adaptationPrimitiveTypesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllAdaptationPrimitiveTypesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, adaptationPrimitiveTypesP));
                }
              }
            },
            internal_removeAllAdaptationPrimitiveTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllAdaptationPrimitiveTypesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.adaptationPrimitiveTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._adaptationPrimitiveTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, temp_els));
                this.removeAllAdaptationPrimitiveTypesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_nodes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllNodes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._nodes.size() !== 0 && this._nodes.containsKey(value)) {
                    var obj = this._nodes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._nodes.remove(value);
                    this._nodes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinitions) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllTypeDefinitions();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._typeDefinitions.size() !== 0 && this._typeDefinitions.containsKey(value)) {
                    var obj_0 = this._typeDefinitions.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._typeDefinitions.remove(value);
                    this._typeDefinitions.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_repositories) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRepositories();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._repositories.size() !== 0 && this._repositories.containsKey(value)) {
                    var obj_1 = this._repositories.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._repositories.remove(value);
                    this._repositories.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dataTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDataTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDataTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDataTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDataTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._dataTypes.size() !== 0 && this._dataTypes.containsKey(value)) {
                    var obj_2 = this._dataTypes.get(value);
                    var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_2 == null) {
                      throw new Error('Key newed to null ' + obj_2);
                    }
                    this._dataTypes.remove(value);
                    this._dataTypes.put(objNewKey_2, obj_2);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_libraries) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addLibraries(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllLibraries(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeLibraries(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllLibraries();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._libraries.size() !== 0 && this._libraries.containsKey(value)) {
                    var obj_3 = this._libraries.get(value);
                    var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_3 == null) {
                      throw new Error('Key newed to null ' + obj_3);
                    }
                    this._libraries.remove(value);
                    this._libraries.put(objNewKey_3, obj_3);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_hubs) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllHubs();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._hubs.size() !== 0 && this._hubs.containsKey(value)) {
                    var obj_4 = this._hubs.get(value);
                    var objNewKey_4 = (obj_4 != null ? obj_4 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_4 == null) {
                      throw new Error('Key newed to null ' + obj_4);
                    }
                    this._hubs.remove(value);
                    this._hubs.put(objNewKey_4, obj_4);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_mBindings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllMBindings();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._mBindings.size() !== 0 && this._mBindings.containsKey(value)) {
                    var obj_5 = this._mBindings.get(value);
                    var objNewKey_5 = (obj_5 != null ? obj_5 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_5 == null) {
                      throw new Error('Key newed to null ' + obj_5);
                    }
                    this._mBindings.remove(value);
                    this._mBindings.put(objNewKey_5, obj_5);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj_6 = this._deployUnits.get(value);
                    var objNewKey_6 = (obj_6 != null ? obj_6 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_6 == null) {
                      throw new Error('Key newed to null ' + obj_6);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey_6, obj_6);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_nodeNetworks) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addNodeNetworks(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllNodeNetworks(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeNodeNetworks(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllNodeNetworks();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._nodeNetworks.size() !== 0 && this._nodeNetworks.containsKey(value)) {
                    var obj_7 = this._nodeNetworks.get(value);
                    var objNewKey_7 = (obj_7 != null ? obj_7 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_7 == null) {
                      throw new Error('Key newed to null ' + obj_7);
                    }
                    this._nodeNetworks.remove(value);
                    this._nodeNetworks.put(objNewKey_7, obj_7);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_groups) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllGroups();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._groups.size() !== 0 && this._groups.containsKey(value)) {
                    var obj_8 = this._groups.get(value);
                    var objNewKey_8 = (obj_8 != null ? obj_8 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_8 == null) {
                      throw new Error('Key newed to null ' + obj_8);
                    }
                    this._groups.remove(value);
                    this._groups.put(objNewKey_8, obj_8);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addAdaptationPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllAdaptationPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeAdaptationPrimitiveTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllAdaptationPrimitiveTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._adaptationPrimitiveTypes.size() !== 0 && this._adaptationPrimitiveTypes.containsKey(value)) {
                    var obj_9 = this._adaptationPrimitiveTypes.get(value);
                    var objNewKey_9 = (obj_9 != null ? obj_9 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_9 == null) {
                      throw new Error('Key newed to null ' + obj_9);
                    }
                    this._adaptationPrimitiveTypes.remove(value);
                    this._adaptationPrimitiveTypes.put(objNewKey_9, obj_9);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.generated_KMF_ID;
            },
            findNodesByID: function (key) {
              return this._nodes.get(key);
            },
            findTypeDefinitionsByID: function (key) {
              return this._typeDefinitions.get(key);
            },
            findRepositoriesByID: function (key) {
              return this._repositories.get(key);
            },
            findDataTypesByID: function (key) {
              return this._dataTypes.get(key);
            },
            findLibrariesByID: function (key) {
              return this._libraries.get(key);
            },
            findHubsByID: function (key) {
              return this._hubs.get(key);
            },
            findMBindingsByID: function (key) {
              return this._mBindings.get(key);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get(key);
            },
            findNodeNetworksByID: function (key) {
              return this._nodeNetworks.get(key);
            },
            findGroupsByID: function (key) {
              return this._groups.get(key);
            },
            findAdaptationPrimitiveTypesByID: function (key) {
              return this._adaptationPrimitiveTypes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_nodes) {
                return this.findNodesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinitions) {
                return this.findTypeDefinitionsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_repositories) {
                return this.findRepositoriesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dataTypes) {
                return this.findDataTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_libraries) {
                return this.findLibrariesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_hubs) {
                return this.findHubsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_mBindings) {
                return this.findMBindingsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_nodeNetworks) {
                return this.findNodeNetworksByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_groups) {
                return this.findGroupsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes) {
                return this.findAdaptationPrimitiveTypesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_nodes, _.org.kevoree.util.Constants.org_kevoree_ContainerNode);
                {
                  var tmp$0 = this._nodes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._nodes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_nodes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_nodes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinitions, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$1 = this._typeDefinitions.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._typeDefinitions.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinitions);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinitions);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_repositories, _.org.kevoree.util.Constants.org_kevoree_Repository);
                {
                  var tmp$2 = this._repositories.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._repositories.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_repositories);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_repositories);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dataTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement);
                {
                  var tmp$3 = this._dataTypes.keySet().iterator();
                  while (tmp$3.hasNext()) {
                    var KMFLoopEntryKey_2 = tmp$3.next();
                    this.internal_visit(visitor, this._dataTypes.get(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dataTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dataTypes);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_libraries, _.org.kevoree.util.Constants.org_kevoree_TypeLibrary);
                {
                  var tmp$4 = this._libraries.keySet().iterator();
                  while (tmp$4.hasNext()) {
                    var KMFLoopEntryKey_3 = tmp$4.next();
                    this.internal_visit(visitor, this._libraries.get(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_libraries);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_libraries);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hubs, _.org.kevoree.util.Constants.org_kevoree_Channel);
                {
                  var tmp$5 = this._hubs.keySet().iterator();
                  while (tmp$5.hasNext()) {
                    var KMFLoopEntryKey_4 = tmp$5.next();
                    this.internal_visit(visitor, this._hubs.get(KMFLoopEntryKey_4), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hubs);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hubs);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_mBindings, _.org.kevoree.util.Constants.org_kevoree_MBinding);
                {
                  var tmp$6 = this._mBindings.keySet().iterator();
                  while (tmp$6.hasNext()) {
                    var KMFLoopEntryKey_5 = tmp$6.next();
                    this.internal_visit(visitor, this._mBindings.get(KMFLoopEntryKey_5), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_mBindings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_mBindings);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$7 = this._deployUnits.keySet().iterator();
                  while (tmp$7.hasNext()) {
                    var KMFLoopEntryKey_6 = tmp$7.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_6), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_nodeNetworks, _.org.kevoree.util.Constants.org_kevoree_NodeNetwork);
                {
                  var tmp$8 = this._nodeNetworks.keySet().iterator();
                  while (tmp$8.hasNext()) {
                    var KMFLoopEntryKey_7 = tmp$8.next();
                    this.internal_visit(visitor, this._nodeNetworks.get(KMFLoopEntryKey_7), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_nodeNetworks);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_nodeNetworks);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_groups, _.org.kevoree.util.Constants.org_kevoree_Group);
                {
                  var tmp$9 = this._groups.keySet().iterator();
                  while (tmp$9.hasNext()) {
                    var KMFLoopEntryKey_8 = tmp$9.next();
                    this.internal_visit(visitor, this._groups.get(KMFLoopEntryKey_8), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_groups);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_groups);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes, _.org.kevoree.util.Constants.org_kevoree_AdaptationPrimitiveType);
                {
                  var tmp$10 = this._adaptationPrimitiveTypes.keySet().iterator();
                  while (tmp$10.hasNext()) {
                    var KMFLoopEntryKey_9 = tmp$10.next();
                    this.internal_visit(visitor, this._adaptationPrimitiveTypes.get(KMFLoopEntryKey_9), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_adaptationPrimitiveTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ContainerRoot;
            }
          }),
          PortImpl: Kotlin.createClass([_c.Port, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this._bindings = new Kotlin.PrimitiveHashMap(0);
            this.$portTypeRef = null;
          }, /** @lends _.org.kevoree.impl.PortImpl.prototype */ {
            delete: function () {
              var tmp$0;
              (tmp$0 = this._bindings) != null ? tmp$0.clear() : null;
              this.portTypeRef = null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            },
            bindings: {
              get: function () {
                return _.kotlin.toList(this._bindings.values());
              },
              set: function (bindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (bindingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_bindings(bindingsP, true, true);
              }
            },
            internal_bindings: function (bindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._bindings.values(), bindingsP)) {
                this.internal_removeAllBindings(true, false);
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._bindings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
                }
              }
            },
            doAddBindings: function (bindingsP) {
              var _key_ = (bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._bindings.containsKey(_key_)) {
                this._bindings.put(_key_, bindingsP);
              }
            },
            addBindings: function (bindingsP) {
              this.internal_addBindings(bindingsP, true, true);
            },
            addAllBindings: function (bindingsP) {
              this.internal_addAllBindings(bindingsP, true, true);
            },
            internal_addBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddBindings(bindingsP);
              if (setOpposite) {
                (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
              }
            },
            internal_addAllBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddBindings(el);
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = bindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
              }
            },
            removeBindings: function (bindingsP) {
              this.internal_removeBindings(bindingsP, true, true);
            },
            removeAllBindings: function () {
              this.internal_removeAllBindings(true, true);
            },
            internal_removeBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._bindings.size() !== 0 && this._bindings.containsKey((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._bindings.remove((bindingsP != null ? bindingsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP));
                }
                if (setOpposite) {
                  (bindingsP != null ? bindingsP : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, null, false, fireEvents);
                }
              }
            },
            internal_removeAllBindings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.bindings) != null ? tmp$0 : Kotlin.throwNPE();
              if (setOpposite) {
                {
                  var tmp$1 = (temp_els != null ? temp_els : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var el = tmp$1.next();
                    (el != null ? el : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.util.Constants.Ref_port, null, false, fireEvents);
                  }
                }
              }
              this._bindings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, temp_els));
              }
            },
            portTypeRef: {
              get: function () {
                return this.$portTypeRef;
              },
              set: function (portTypeRefP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_portTypeRef(portTypeRefP, true, true);
              }
            },
            internal_portTypeRef: function (portTypeRefP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$portTypeRef, portTypeRefP)) {
                this.$portTypeRef = portTypeRefP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypeRef, portTypeRefP));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_bindings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.internal_removeAllBindings(setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._bindings.size() !== 0 && this._bindings.containsKey(value)) {
                    var obj = this._bindings.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._bindings.remove(value);
                    this._bindings.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_portTypeRef) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_portTypeRef(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_portTypeRef(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_portTypeRef(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.generated_KMF_ID;
            },
            findBindingsByID: function (key) {
              return this._bindings.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_bindings) {
                return this.findBindingsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_portTypeRef) {
                var objFound = this.portTypeRef;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_bindings, _.org.kevoree.util.Constants.org_kevoree_MBinding);
                {
                  var tmp$0 = this._bindings.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._bindings.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_bindings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_bindings);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_portTypeRef, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                this.internal_visit(visitor, this.portTypeRef, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_portTypeRef);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_portTypeRef);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Port;
            }
          }),
          RepositoryImpl: Kotlin.createClass([_c.Repository, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$url = null;
            this._units = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.RepositoryImpl.prototype */ {
            delete: function () {
              var tmp$0;
              (tmp$0 = this._units) != null ? tmp$0.clear() : null;
            },
            url: {
              get: function () {
                return this.$url;
              },
              set: function (iP) {
                this.internal_url(iP, true);
              }
            },
            internal_url: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.url)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$url = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_url, this.url));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_url, this.path()));
                }
              }
            },
            units: {
              get: function () {
                return _.kotlin.toList(this._units.values());
              },
              set: function (unitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (unitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_units(unitsP, true, true);
              }
            },
            internal_units: function (unitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._units.values(), unitsP)) {
                this._units.clear();
                {
                  var tmp$0 = unitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._units.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP));
                }
              }
            },
            doAddUnits: function (unitsP) {
              var _key_ = (unitsP != null ? unitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._units.containsKey(_key_)) {
                this._units.put(_key_, unitsP);
              }
            },
            addUnits: function (unitsP) {
              this.internal_addUnits(unitsP, true, true);
            },
            addAllUnits: function (unitsP) {
              this.internal_addAllUnits(unitsP, true, true);
            },
            internal_addUnits: function (unitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddUnits(unitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP));
              }
            },
            internal_addAllUnits: function (unitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = unitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = unitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP));
              }
            },
            removeUnits: function (unitsP) {
              this.internal_removeUnits(unitsP, true, true);
            },
            removeAllUnits: function () {
              this.internal_removeAllUnits(true, true);
            },
            internal_removeUnits: function (unitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._units.size() !== 0 && this._units.containsKey((unitsP != null ? unitsP : Kotlin.throwNPE()).internalGetKey())) {
                this._units.remove((unitsP != null ? unitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, unitsP));
                }
              }
            },
            internal_removeAllUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.units) != null ? tmp$0 : Kotlin.throwNPE();
              this._units.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_units, temp_els));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_url) {
                this.internal_url(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_units) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._units.size() !== 0 && this._units.containsKey(value)) {
                    var obj = this._units.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._units.remove(value);
                    this._units.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.url;
            },
            findUnitsByID: function (key) {
              return this._units.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_units) {
                return this.findUnitsByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_units, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$0 = this._units.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._units.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_units);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_units);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.url, _.org.kevoree.util.Constants.Att_url, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Repository;
            }
          }),
          DictionaryImpl: Kotlin.createClass([_c.Dictionary, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this._values = new Kotlin.PrimitiveHashMap(0);
            this.removeAllValuesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.DictionaryImpl.prototype */ {
            delete: function () {
              var tmp$0;
              (tmp$0 = this._values) != null ? tmp$0.clear() : null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            },
            values: {
              get: function () {
                return _.kotlin.toList(this._values.values());
              },
              set: function (valuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (valuesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_values(valuesP, true, true);
              }
            },
            internal_values: function (valuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._values.values(), valuesP)) {
                this._values.clear();
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._values.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_values, el), _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP));
                }
              }
            },
            doAddValues: function (valuesP) {
              var _key_ = (valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._values.containsKey(_key_)) {
                this._values.put(_key_, valuesP);
                (valuesP != null ? valuesP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_values, valuesP), _.org.kevoree.util.Constants.Ref_values);
              }
            },
            addValues: function (valuesP) {
              this.internal_addValues(valuesP, true, true);
            },
            addAllValues: function (valuesP) {
              this.internal_addAllValues(valuesP, true, true);
            },
            internal_addValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddValues(valuesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP));
              }
            },
            internal_addAllValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = valuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP));
              }
            },
            removeValues: function (valuesP) {
              this.internal_removeValues(valuesP, true, true);
            },
            removeAllValues: function () {
              this.internal_removeAllValues(true, true);
            },
            internal_removeValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._values.size() !== 0 && this._values.containsKey((valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey())) {
                this._values.remove((valuesP != null ? valuesP : Kotlin.throwNPE()).internalGetKey());
                ((valuesP != null ? valuesP : Kotlin.throwNPE()) != null ? valuesP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP));
                }
              }
            },
            internal_removeAllValues: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllValuesCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.values) != null ? tmp$0 : Kotlin.throwNPE();
              this._values.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, temp_els));
                this.removeAllValuesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_values) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllValues();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._values.size() !== 0 && this._values.containsKey(value)) {
                    var obj = this._values.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._values.remove(value);
                    this._values.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.generated_KMF_ID;
            },
            findValuesByID: function (key) {
              return this._values.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_values) {
                return this.findValuesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_values, _.org.kevoree.util.Constants.org_kevoree_DictionaryValue);
                {
                  var tmp$0 = this._values.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._values.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_values);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Dictionary;
            }
          }),
          TypeLibraryImpl: Kotlin.createClass([_c.TypeLibrary, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this._subTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.TypeLibraryImpl.prototype */ {
            delete: function () {
              var tmp$0;
              (tmp$0 = this._subTypes) != null ? tmp$0.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            subTypes: {
              get: function () {
                return _.kotlin.toList(this._subTypes.values());
              },
              set: function (subTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (subTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_subTypes(subTypesP, true, true);
              }
            },
            internal_subTypes: function (subTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._subTypes.values(), subTypesP)) {
                this._subTypes.clear();
                {
                  var tmp$0 = subTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._subTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP));
                }
              }
            },
            doAddSubTypes: function (subTypesP) {
              var _key_ = (subTypesP != null ? subTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._subTypes.containsKey(_key_)) {
                this._subTypes.put(_key_, subTypesP);
              }
            },
            addSubTypes: function (subTypesP) {
              this.internal_addSubTypes(subTypesP, true, true);
            },
            addAllSubTypes: function (subTypesP) {
              this.internal_addAllSubTypes(subTypesP, true, true);
            },
            internal_addSubTypes: function (subTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSubTypes(subTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP));
              }
            },
            internal_addAllSubTypes: function (subTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = subTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSubTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = subTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSubTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP));
              }
            },
            removeSubTypes: function (subTypesP) {
              this.internal_removeSubTypes(subTypesP, true, true);
            },
            removeAllSubTypes: function () {
              this.internal_removeAllSubTypes(true, true);
            },
            internal_removeSubTypes: function (subTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._subTypes.size() !== 0 && this._subTypes.containsKey((subTypesP != null ? subTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._subTypes.remove((subTypesP != null ? subTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, subTypesP));
                }
              }
            },
            internal_removeAllSubTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.subTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._subTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_subTypes, temp_els));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_subTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSubTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSubTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSubTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSubTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._subTypes.size() !== 0 && this._subTypes.containsKey(value)) {
                    var obj = this._subTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._subTypes.remove(value);
                    this._subTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findSubTypesByID: function (key) {
              return this._subTypes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_subTypes) {
                return this.findSubTypesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_subTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$0 = this._subTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._subTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_subTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_subTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_TypeLibrary;
            }
          }),
          PortTypeMappingImpl: Kotlin.createClass([_c.PortTypeMapping, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$beanMethodName = null;
            this.$serviceMethodName = null;
            this.$paramTypes = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
          }, /** @lends _.org.kevoree.impl.PortTypeMappingImpl.prototype */ {
            delete: function () {
            },
            beanMethodName: {
              get: function () {
                return this.$beanMethodName;
              },
              set: function (iP) {
                this.internal_beanMethodName(iP, true);
              }
            },
            internal_beanMethodName: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.beanMethodName)) {
                var oldPath = this.path();
                this.$beanMethodName = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_beanMethodName, this.beanMethodName));
                }
              }
            },
            serviceMethodName: {
              get: function () {
                return this.$serviceMethodName;
              },
              set: function (iP) {
                this.internal_serviceMethodName(iP, true);
              }
            },
            internal_serviceMethodName: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.serviceMethodName)) {
                var oldPath = this.path();
                this.$serviceMethodName = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_serviceMethodName, this.serviceMethodName));
                }
              }
            },
            paramTypes: {
              get: function () {
                return this.$paramTypes;
              },
              set: function (iP) {
                this.internal_paramTypes(iP, true);
              }
            },
            internal_paramTypes: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.paramTypes)) {
                var oldPath = this.path();
                this.$paramTypes = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_paramTypes, this.paramTypes));
                }
              }
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_beanMethodName) {
                this.internal_beanMethodName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_serviceMethodName) {
                this.internal_serviceMethodName(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_paramTypes) {
                this.internal_paramTypes(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.generated_KMF_ID;
            },
            findByID: function (relationName, idP) {
              {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.paramTypes, _.org.kevoree.util.Constants.Att_paramTypes, this);
              visitor.visit(this.serviceMethodName, _.org.kevoree.util.Constants.Att_serviceMethodName, this);
              visitor.visit(this.beanMethodName, _.org.kevoree.util.Constants.Att_beanMethodName, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping;
            }
          }),
          WireImpl: Kotlin.createClass([_c.Wire, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this._ports = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.WireImpl.prototype */ {
            delete: function () {
              var tmp$0;
              (tmp$0 = this._ports) != null ? tmp$0.clear() : null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            },
            ports: {
              get: function () {
                return _.kotlin.toList(this._ports.values());
              },
              set: function (portsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (portsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_ports(portsP, true, true);
              }
            },
            internal_ports: function (portsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._ports.values(), portsP)) {
                this._ports.clear();
                {
                  var tmp$0 = portsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._ports.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, portsP));
                }
              }
            },
            doAddPorts: function (portsP) {
              var _key_ = (portsP != null ? portsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._ports.containsKey(_key_)) {
                this._ports.put(_key_, portsP);
              }
            },
            addPorts: function (portsP) {
              this.internal_addPorts(portsP, true, true);
            },
            addAllPorts: function (portsP) {
              this.internal_addAllPorts(portsP, true, true);
            },
            internal_addPorts: function (portsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddPorts(portsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, portsP));
              }
            },
            internal_addAllPorts: function (portsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = portsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddPorts(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = portsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddPorts(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, portsP));
              }
            },
            removePorts: function (portsP) {
              this.internal_removePorts(portsP, true, true);
            },
            removeAllPorts: function () {
              this.internal_removeAllPorts(true, true);
            },
            internal_removePorts: function (portsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._ports) === 2 && this._ports.containsKey((portsP != null ? portsP : Kotlin.throwNPE()).internalGetKey())) {
                throw new Kotlin.UnsupportedOperationException('The list of portsP must contain at least 2 element. Can not remove sizeof(portsP)=' + _.kotlin.get_size(this._ports));
              }
               else {
                this._ports.remove((portsP != null ? portsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, portsP));
                }
              }
            },
            internal_removeAllPorts: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.ports) != null ? tmp$0 : Kotlin.throwNPE();
              this._ports.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ports, temp_els));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_ports) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addPorts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllPorts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removePorts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllPorts();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._ports.size() !== 0 && this._ports.containsKey(value)) {
                    var obj = this._ports.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._ports.remove(value);
                    this._ports.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.generated_KMF_ID;
            },
            findPortsByID: function (key) {
              return this._ports.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_ports) {
                return this.findPortsByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_ports, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$0 = this._ports.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._ports.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_ports);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_ports);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Wire;
            }
          }),
          MBindingImpl: Kotlin.createClass([_c.MBinding, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this.$port = null;
            this.$hub = null;
          }, /** @lends _.org.kevoree.impl.MBindingImpl.prototype */ {
            delete: function () {
              this.port = null;
              this.hub = null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            },
            port: {
              get: function () {
                return this.$port;
              },
              set: function (portP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_port(portP, true, true);
              }
            },
            internal_port: function (portP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$port, portP)) {
                if (setOpposite) {
                  if (this.$port != null) {
                    var tmp$0;
                    ((tmp$0 = this.$port) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                  if (portP != null) {
                    portP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                }
                this.$port = portP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_port, portP));
                }
              }
            },
            hub: {
              get: function () {
                return this.$hub;
              },
              set: function (hubP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_hub(hubP, true, true);
              }
            },
            internal_hub: function (hubP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$hub, hubP)) {
                if (setOpposite) {
                  if (this.$hub != null) {
                    var tmp$0;
                    ((tmp$0 = this.$hub) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                  if (hubP != null) {
                    hubP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                }
                this.$hub = hubP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_hub, hubP));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_port) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_port(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_port(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_port(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_hub) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_hub(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_hub(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_hub(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.generated_KMF_ID;
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_port) {
                var objFound = this.port;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_hub) {
                var objFound_0 = this.hub;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_port, _.org.kevoree.util.Constants.org_kevoree_Port);
                this.internal_visit(visitor, this.port, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_port);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_port);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hub, _.org.kevoree.util.Constants.org_kevoree_Channel);
                this.internal_visit(visitor, this.hub, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hub);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hub);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_MBinding;
            }
          }),
          ComponentTypeImpl: Kotlin.createClass([_c.ComponentType, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$factoryBean = null;
            this.$bean = null;
            this.$abstract = null;
            this.$startMethod = null;
            this.$stopMethod = null;
            this.$updateMethod = null;
            this._deployUnits = new Kotlin.PrimitiveHashMap(0);
            this.$dictionaryType = null;
            this._superTypes = new Kotlin.PrimitiveHashMap(0);
            this._required = new Kotlin.PrimitiveHashMap(0);
            this.removeAllRequiredCurrentlyProcessing = false;
            this._integrationPatterns = new Kotlin.PrimitiveHashMap(0);
            this.removeAllIntegrationPatternsCurrentlyProcessing = false;
            this.$extraFonctionalProperties = null;
            this._provided = new Kotlin.PrimitiveHashMap(0);
            this.removeAllProvidedCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ComponentTypeImpl.prototype */ {
            delete: function () {
              var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4;
              (tmp$0 = this._deployUnits) != null ? tmp$0.clear() : null;
              this.dictionaryType = null;
              (tmp$1 = this._superTypes) != null ? tmp$1.clear() : null;
              (tmp$2 = this._required) != null ? tmp$2.clear() : null;
              (tmp$3 = this._integrationPatterns) != null ? tmp$3.clear() : null;
              this.extraFonctionalProperties = null;
              (tmp$4 = this._provided) != null ? tmp$4.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            factoryBean: {
              get: function () {
                return this.$factoryBean;
              },
              set: function (iP) {
                this.internal_factoryBean(iP, true);
              }
            },
            internal_factoryBean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.factoryBean)) {
                var oldPath = this.path();
                this.$factoryBean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_factoryBean, this.factoryBean));
                }
              }
            },
            bean: {
              get: function () {
                return this.$bean;
              },
              set: function (iP) {
                this.internal_bean(iP, true);
              }
            },
            internal_bean: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.bean)) {
                var oldPath = this.path();
                this.$bean = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_bean, this.bean));
                }
              }
            },
            abstract: {
              get: function () {
                return this.$abstract;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                this.$abstract = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract));
                }
              }
            },
            startMethod: {
              get: function () {
                return this.$startMethod;
              },
              set: function (iP) {
                this.internal_startMethod(iP, true);
              }
            },
            internal_startMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.startMethod)) {
                var oldPath = this.path();
                this.$startMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_startMethod, this.startMethod));
                }
              }
            },
            stopMethod: {
              get: function () {
                return this.$stopMethod;
              },
              set: function (iP) {
                this.internal_stopMethod(iP, true);
              }
            },
            internal_stopMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.stopMethod)) {
                var oldPath = this.path();
                this.$stopMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_stopMethod, this.stopMethod));
                }
              }
            },
            updateMethod: {
              get: function () {
                return this.$updateMethod;
              },
              set: function (iP) {
                this.internal_updateMethod(iP, true);
              }
            },
            internal_updateMethod: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.updateMethod)) {
                var oldPath = this.path();
                this.$updateMethod = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_updateMethod, this.updateMethod));
                }
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = (deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey(_key_)) {
                this._deployUnits.put(_key_, deployUnitsP);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (_.kotlin.get_size(this._deployUnits) === 1 && this._deployUnits.containsKey((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey())) {
                throw new Kotlin.UnsupportedOperationException('The list of deployUnitsP must contain at least 1 element. Can not remove sizeof(deployUnitsP)=' + _.kotlin.get_size(this._deployUnits));
              }
               else {
                this._deployUnits.remove((deployUnitsP != null ? deployUnitsP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.deployUnits) != null ? tmp$0 : Kotlin.throwNPE();
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els));
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType, dictionaryTypeP)) {
                if (this.$dictionaryType != null) {
                  var tmp$0;
                  (((tmp$0 = this.$dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                this.$dictionaryType = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP));
                }
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = (superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey(_key_)) {
                this._superTypes.put(_key_, superTypesP);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._superTypes.remove((superTypesP != null ? superTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.superTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els));
              }
            },
            required: {
              get: function () {
                return _.kotlin.toList(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            },
            doAddRequired: function (requiredP) {
              var _key_ = (requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey(_key_)) {
                this._required.put(_key_, requiredP);
                (requiredP != null ? requiredP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
              }
            },
            addRequired: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
            },
            addAllRequired: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
            },
            internal_addRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            },
            internal_addAllRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
              }
            },
            removeRequired: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
            },
            removeAllRequired: function () {
              this.internal_removeAllRequired(true, true);
            },
            internal_removeRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey())) {
                this._required.remove((requiredP != null ? requiredP : Kotlin.throwNPE()).internalGetKey());
                ((requiredP != null ? requiredP : Kotlin.throwNPE()) != null ? requiredP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP));
                }
              }
            },
            internal_removeAllRequired: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.required) != null ? tmp$0 : Kotlin.throwNPE();
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            },
            integrationPatterns: {
              get: function () {
                return _.kotlin.toList(this._integrationPatterns.values());
              },
              set: function (integrationPatternsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (integrationPatternsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_integrationPatterns(integrationPatternsP, true, true);
              }
            },
            internal_integrationPatterns: function (integrationPatternsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._integrationPatterns.values(), integrationPatternsP)) {
                this._integrationPatterns.clear();
                {
                  var tmp$0 = integrationPatternsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._integrationPatterns.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_integrationPatterns, el), _.org.kevoree.util.Constants.Ref_integrationPatterns);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
                }
              }
            },
            doAddIntegrationPatterns: function (integrationPatternsP) {
              var _key_ = (integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._integrationPatterns.containsKey(_key_)) {
                this._integrationPatterns.put(_key_, integrationPatternsP);
                (integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP), _.org.kevoree.util.Constants.Ref_integrationPatterns);
              }
            },
            addIntegrationPatterns: function (integrationPatternsP) {
              this.internal_addIntegrationPatterns(integrationPatternsP, true, true);
            },
            addAllIntegrationPatterns: function (integrationPatternsP) {
              this.internal_addAllIntegrationPatterns(integrationPatternsP, true, true);
            },
            internal_addIntegrationPatterns: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddIntegrationPatterns(integrationPatternsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
              }
            },
            internal_addAllIntegrationPatterns: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = integrationPatternsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddIntegrationPatterns(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = integrationPatternsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddIntegrationPatterns(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
              }
            },
            removeIntegrationPatterns: function (integrationPatternsP) {
              this.internal_removeIntegrationPatterns(integrationPatternsP, true, true);
            },
            removeAllIntegrationPatterns: function () {
              this.internal_removeAllIntegrationPatterns(true, true);
            },
            internal_removeIntegrationPatterns: function (integrationPatternsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._integrationPatterns.size() !== 0 && this._integrationPatterns.containsKey((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey())) {
                this._integrationPatterns.remove((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()).internalGetKey());
                ((integrationPatternsP != null ? integrationPatternsP : Kotlin.throwNPE()) != null ? integrationPatternsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllIntegrationPatternsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, integrationPatternsP));
                }
              }
            },
            internal_removeAllIntegrationPatterns: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllIntegrationPatternsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.integrationPatterns) != null ? tmp$0 : Kotlin.throwNPE();
              this._integrationPatterns.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_integrationPatterns, temp_els));
                this.removeAllIntegrationPatternsCurrentlyProcessing = false;
              }
            },
            extraFonctionalProperties: {
              get: function () {
                return this.$extraFonctionalProperties;
              },
              set: function (extraFonctionalPropertiesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_extraFonctionalProperties(extraFonctionalPropertiesP, true, true);
              }
            },
            internal_extraFonctionalProperties: function (extraFonctionalPropertiesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$extraFonctionalProperties, extraFonctionalPropertiesP)) {
                if (this.$extraFonctionalProperties != null) {
                  var tmp$0;
                  (((tmp$0 = this.$extraFonctionalProperties) != null ? tmp$0 : Kotlin.throwNPE()) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (extraFonctionalPropertiesP != null) {
                  (extraFonctionalPropertiesP != null ? extraFonctionalPropertiesP : Kotlin.throwNPE()).setEContainer(this, null, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                }
                this.$extraFonctionalProperties = extraFonctionalPropertiesP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties, extraFonctionalPropertiesP));
                }
              }
            },
            provided: {
              get: function () {
                return _.kotlin.toList(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            },
            doAddProvided: function (providedP) {
              var _key_ = (providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey(_key_)) {
                this._provided.put(_key_, providedP);
                (providedP != null ? providedP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
              }
            },
            addProvided: function (providedP) {
              this.internal_addProvided(providedP, true, true);
            },
            addAllProvided: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
            },
            internal_addProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            },
            internal_addAllProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
              }
            },
            removeProvided: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
            },
            removeAllProvided: function () {
              this.internal_removeAllProvided(true, true);
            },
            internal_removeProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey())) {
                this._provided.remove((providedP != null ? providedP : Kotlin.throwNPE()).internalGetKey());
                ((providedP != null ? providedP : Kotlin.throwNPE()) != null ? providedP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP));
                }
              }
            },
            internal_removeAllProvided: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.provided) != null ? tmp$0 : Kotlin.throwNPE();
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_factoryBean) {
                this.internal_factoryBean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_bean) {
                this.internal_bean(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_startMethod) {
                this.internal_startMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_stopMethod) {
                this.internal_stopMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_updateMethod) {
                this.internal_updateMethod(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllDeployUnits();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey(value)) {
                    var obj = this._deployUnits.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._deployUnits.remove(value);
                    this._deployUnits.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_dictionaryType(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_dictionaryType(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllSuperTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._superTypes.size() !== 0 && this._superTypes.containsKey(value)) {
                    var obj_0 = this._superTypes.get(value);
                    var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_0 == null) {
                      throw new Error('Key newed to null ' + obj_0);
                    }
                    this._superTypes.remove(value);
                    this._superTypes.put(objNewKey_0, obj_0);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllRequired();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._required.size() !== 0 && this._required.containsKey(value)) {
                    var obj_1 = this._required.get(value);
                    var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_1 == null) {
                      throw new Error('Key newed to null ' + obj_1);
                    }
                    this._required.remove(value);
                    this._required.put(objNewKey_1, obj_1);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_integrationPatterns) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeIntegrationPatterns(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllIntegrationPatterns();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._integrationPatterns.size() !== 0 && this._integrationPatterns.containsKey(value)) {
                    var obj_2 = this._integrationPatterns.get(value);
                    var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_2 == null) {
                      throw new Error('Key newed to null ' + obj_2);
                    }
                    this._integrationPatterns.remove(value);
                    this._integrationPatterns.put(objNewKey_2, obj_2);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_extraFonctionalProperties(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_extraFonctionalProperties(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_extraFonctionalProperties(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllProvided();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._provided.size() !== 0 && this._provided.containsKey(value)) {
                    var obj_3 = this._provided.get(value);
                    var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey_3 == null) {
                      throw new Error('Key newed to null ' + obj_3);
                    }
                    this._provided.remove(value);
                    this._provided.put(objNewKey_3, obj_3);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get(key);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get(key);
            },
            findRequiredByID: function (key) {
              return this._required.get(key);
            },
            findIntegrationPatternsByID: function (key) {
              return this._integrationPatterns.get(key);
            },
            findProvidedByID: function (key) {
              return this._provided.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                return this.findDeployUnitsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                var objFound = this.dictionaryType;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                return this.findSuperTypesByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                return this.findRequiredByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_integrationPatterns) {
                return this.findIntegrationPatternsByID(idP);
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_extraFonctionalProperties) {
                var objFound_0 = this.extraFonctionalProperties;
                if (objFound_0 != null && Kotlin.equals((objFound_0 != null ? objFound_0 : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound_0;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                return this.findProvidedByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType);
                this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$0 = this._required.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._required.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_integrationPatterns, _.org.kevoree.util.Constants.org_kevoree_IntegrationPattern);
                {
                  var tmp$1 = this._integrationPatterns.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var KMFLoopEntryKey_0 = tmp$1.next();
                    this.internal_visit(visitor, this._integrationPatterns.get(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_integrationPatterns);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_integrationPatterns);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties, _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty);
                this.internal_visit(visitor, this.extraFonctionalProperties, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_extraFonctionalProperties);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$2 = this._provided.keySet().iterator();
                  while (tmp$2.hasNext()) {
                    var KMFLoopEntryKey_1 = tmp$2.next();
                    this.internal_visit(visitor, this._provided.get(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit);
                {
                  var tmp$3 = this._deployUnits.keySet().iterator();
                  while (tmp$3.hasNext()) {
                    var KMFLoopEntryKey_2 = tmp$3.next();
                    this.internal_visit(visitor, this._deployUnits.get(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition);
                {
                  var tmp$4 = this._superTypes.keySet().iterator();
                  while (tmp$4.hasNext()) {
                    var KMFLoopEntryKey_3 = tmp$4.next();
                    this.internal_visit(visitor, this._superTypes.get(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.stopMethod, _.org.kevoree.util.Constants.Att_stopMethod, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.bean, _.org.kevoree.util.Constants.Att_bean, this);
              visitor.visit(this.updateMethod, _.org.kevoree.util.Constants.Att_updateMethod, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.factoryBean, _.org.kevoree.util.Constants.Att_factoryBean, this);
              visitor.visit(this.startMethod, _.org.kevoree.util.Constants.Att_startMethod, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ComponentType;
            }
          }),
          ExtraFonctionalPropertyImpl: Kotlin.createClass([_c.ExtraFonctionalProperty, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$generated_KMF_ID = '' + Math.random() + (new Date()).getTime();
            this._portTypes = new Kotlin.PrimitiveHashMap(0);
          }, /** @lends _.org.kevoree.impl.ExtraFonctionalPropertyImpl.prototype */ {
            delete: function () {
              var tmp$0;
              (tmp$0 = this._portTypes) != null ? tmp$0.clear() : null;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$generated_KMF_ID = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path()));
                }
              }
            },
            portTypes: {
              get: function () {
                return _.kotlin.toList(this._portTypes.values());
              },
              set: function (portTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (portTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_portTypes(portTypesP, true, true);
              }
            },
            internal_portTypes: function (portTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._portTypes.values(), portTypesP)) {
                this._portTypes.clear();
                {
                  var tmp$0 = portTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._portTypes.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
                }
              }
            },
            doAddPortTypes: function (portTypesP) {
              var _key_ = (portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._portTypes.containsKey(_key_)) {
                this._portTypes.put(_key_, portTypesP);
              }
            },
            addPortTypes: function (portTypesP) {
              this.internal_addPortTypes(portTypesP, true, true);
            },
            addAllPortTypes: function (portTypesP) {
              this.internal_addAllPortTypes(portTypesP, true, true);
            },
            internal_addPortTypes: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddPortTypes(portTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
              }
            },
            internal_addAllPortTypes: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = portTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddPortTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = portTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddPortTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
              }
            },
            removePortTypes: function (portTypesP) {
              this.internal_removePortTypes(portTypesP, true, true);
            },
            removeAllPortTypes: function () {
              this.internal_removeAllPortTypes(true, true);
            },
            internal_removePortTypes: function (portTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._portTypes.size() !== 0 && this._portTypes.containsKey((portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey())) {
                this._portTypes.remove((portTypesP != null ? portTypesP : Kotlin.throwNPE()).internalGetKey());
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, portTypesP));
                }
              }
            },
            internal_removeAllPortTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.portTypes) != null ? tmp$0 : Kotlin.throwNPE();
              this._portTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypes, temp_els));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                this.internal_generated_KMF_ID(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_portTypes) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addPortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllPortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removePortTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllPortTypes();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._portTypes.size() !== 0 && this._portTypes.containsKey(value)) {
                    var obj = this._portTypes.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._portTypes.remove(value);
                    this._portTypes.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.generated_KMF_ID;
            },
            findPortTypesByID: function (key) {
              return this._portTypes.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_portTypes) {
                return this.findPortTypesByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_portTypes, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef);
                {
                  var tmp$0 = this._portTypes.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._portTypes.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_portTypes);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_portTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ExtraFonctionalProperty;
            }
          }),
          PortTypeRefImpl: Kotlin.createClass([_c.PortTypeRef, _c.KMFContainerImpl], function () {
            this.internal_eContainer = null;
            this.internal_containmentRefName = null;
            this.internal_unsetCmd = null;
            this.internal_readOnlyElem = false;
            this.internal_recursive_readOnlyElem = false;
            this.internal_modelElementListeners = null;
            this.internal_modelTreeListeners = null;
            this.path_cache = null;
            this.$name = null;
            this.$optional = null;
            this.$noDependency = null;
            this.$ref = null;
            this._mappings = new Kotlin.PrimitiveHashMap(0);
            this.removeAllMappingsCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.PortTypeRefImpl.prototype */ {
            delete: function () {
              this.ref = null;
              var tmp$0;
              (tmp$0 = this._mappings) != null ? tmp$0.clear() : null;
            },
            name: {
              get: function () {
                return this.$name;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                this.$name = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Att_name, this.path()));
                }
              }
            },
            optional: {
              get: function () {
                return this.$optional;
              },
              set: function (iP) {
                this.internal_optional(iP, true);
              }
            },
            internal_optional: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.optional)) {
                var oldPath = this.path();
                this.$optional = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_optional, this.optional));
                }
              }
            },
            noDependency: {
              get: function () {
                return this.$noDependency;
              },
              set: function (iP) {
                this.internal_noDependency(iP, true);
              }
            },
            internal_noDependency: function (iP, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.noDependency)) {
                var oldPath = this.path();
                this.$noDependency = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(oldPath, _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE, _.org.kevoree.util.Constants.Att_noDependency, this.noDependency));
                }
              }
            },
            ref: {
              get: function () {
                return this.$ref;
              },
              set: function (refP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_ref(refP, true, true);
              }
            },
            internal_ref: function (refP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$ref, refP)) {
                this.$ref = refP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.REFERENCE, _.org.kevoree.util.Constants.Ref_ref, refP));
                }
              }
            },
            mappings: {
              get: function () {
                return _.kotlin.toList(this._mappings.values());
              },
              set: function (mappingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (mappingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_mappings(mappingsP, true, true);
              }
            },
            internal_mappings: function (mappingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._mappings.values(), mappingsP)) {
                this._mappings.clear();
                {
                  var tmp$0 = mappingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = (el != null ? el : Kotlin.throwNPE()).internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._mappings.put(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    (el != null ? el : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_mappings, el), _.org.kevoree.util.Constants.Ref_mappings);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP));
                }
              }
            },
            doAddMappings: function (mappingsP) {
              var _key_ = (mappingsP != null ? mappingsP : Kotlin.throwNPE()).internalGetKey();
              if (Kotlin.equals(_key_, '') || _key_ == null) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._mappings.containsKey(_key_)) {
                this._mappings.put(_key_, mappingsP);
                (mappingsP != null ? mappingsP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.util.Constants.Ref_mappings, mappingsP), _.org.kevoree.util.Constants.Ref_mappings);
              }
            },
            addMappings: function (mappingsP) {
              this.internal_addMappings(mappingsP, true, true);
            },
            addAllMappings: function (mappingsP) {
              this.internal_addAllMappings(mappingsP, true, true);
            },
            internal_addMappings: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMappings(mappingsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP));
              }
            },
            internal_addAllMappings: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = mappingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMappings(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = mappingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMappings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP));
              }
            },
            removeMappings: function (mappingsP) {
              this.internal_removeMappings(mappingsP, true, true);
            },
            removeAllMappings: function () {
              this.internal_removeAllMappings(true, true);
            },
            internal_removeMappings: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._mappings.size() !== 0 && this._mappings.containsKey((mappingsP != null ? mappingsP : Kotlin.throwNPE()).internalGetKey())) {
                this._mappings.remove((mappingsP != null ? mappingsP : Kotlin.throwNPE()).internalGetKey());
                ((mappingsP != null ? mappingsP : Kotlin.throwNPE()) != null ? mappingsP : Kotlin.throwNPE()).setEContainer(null, null, null);
                if (!this.removeAllMappingsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP));
                }
              }
            },
            internal_removeAllMappings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMappingsCurrentlyProcessing = true;
              }
              var tmp$0;
              var temp_els = (tmp$0 = this.mappings) != null ? tmp$0 : Kotlin.throwNPE();
              this._mappings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(this.path(), _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, temp_els));
                this.removeAllMappingsCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              if (refName === _.org.kevoree.util.Constants.Att_name) {
                this.internal_name(value, fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_optional) {
                this.internal_optional(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Att_noDependency) {
                this.internal_noDependency(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_ref) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.SET) {
                  this.internal_ref(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_ref(null, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_ref(value, setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else if (refName === _.org.kevoree.util.Constants.Ref_mappings) {
                if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                  this.internal_addMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                  this.internal_addAllMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                  this.internal_removeMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL) {
                  this.removeAllMappings();
                }
                 else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  if (this._mappings.size() !== 0 && this._mappings.containsKey(value)) {
                    var obj = this._mappings.get(value);
                    var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                    if (objNewKey == null) {
                      throw new Error('Key newed to null ' + obj);
                    }
                    this._mappings.remove(value);
                    this._mappings.put(objNewKey, obj);
                  }
                }
                 else {
                  throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                }
              }
               else {
                throw new Error('Can reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
              }
            },
            internalGetKey: function () {
              return this.name;
            },
            findMappingsByID: function (key) {
              return this._mappings.get(key);
            },
            findByID: function (relationName, idP) {
              if (relationName === _.org.kevoree.util.Constants.Ref_ref) {
                var objFound = this.ref;
                if (objFound != null && Kotlin.equals((objFound != null ? objFound : Kotlin.throwNPE()).internalGetKey(), idP)) {
                  return objFound;
                }
                 else {
                  return null;
                }
              }
               else if (relationName === _.org.kevoree.util.Constants.Ref_mappings) {
                return this.findMappingsByID(idP);
              }
               else {
                return null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_mappings, _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping);
                {
                  var tmp$0 = this._mappings.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var KMFLoopEntryKey = tmp$0.next();
                    this.internal_visit(visitor, this._mappings.get(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_mappings);
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_mappings);
              }
              if (nonContainedReference) {
                visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_ref, _.org.kevoree.util.Constants.org_kevoree_PortType);
                this.internal_visit(visitor, this.ref, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_ref);
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_ref);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.noDependency, _.org.kevoree.util.Constants.Att_noDependency, this);
              visitor.visit(this.optional, _.org.kevoree.util.Constants.Att_optional, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_PortTypeRef;
            }
          })
        }),
        modeling: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling */ {
          api: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api */ {
            ModelLoader: _c.ModelLoader,
            ModelSerializer: _c.ModelSerializer,
            xmi: Kotlin.definePackage(function () {
              this.Token = Kotlin.createObject(null, function () {
                this.XML_HEADER = 0;
                this.END_DOCUMENT = 1;
                this.START_TAG = 2;
                this.END_TAG = 3;
                this.COMMENT = 4;
                this.SINGLETON_TAG = 5;
              });
            }, /** @lends _.org.kevoree.modeling.api.xmi */ {
              XMIModelLoader: _c.XMIModelLoader,
              LoadingContext: Kotlin.createClass(null, function () {
                this.xmiReader = null;
                this.loadedRoots = new Kotlin.ArrayList(0);
                this.map = new Kotlin.PrimitiveHashMap(0);
                this.elementsCount = new Kotlin.PrimitiveHashMap(0);
                this.resolvers = new Kotlin.ArrayList(0);
                this.stats = new Kotlin.PrimitiveHashMap(0);
                this.oppositesAlreadySet = new Kotlin.PrimitiveHashMap(0);
              }, /** @lends _.org.kevoree.modeling.api.xmi.LoadingContext.prototype */ {
                isOppositeAlreadySet: function (localRef, oppositeRef) {
                  var res = this.oppositesAlreadySet.get(oppositeRef + '_' + localRef) != null || this.oppositesAlreadySet.get(localRef + '_' + oppositeRef) != null;
                  return res;
                },
                storeOppositeRelation: function (localRef, oppositeRef) {
                  this.oppositesAlreadySet.put(localRef + '_' + oppositeRef, true);
                }
              }),
              XMIResolveCommand: Kotlin.createClass(null, function (context, target, mutatorType, refName, ref) {
                this.context = context;
                this.target = target;
                this.mutatorType = mutatorType;
                this.refName = refName;
                this.ref = ref;
              }, /** @lends _.org.kevoree.modeling.api.xmi.XMIResolveCommand.prototype */ {
                run: function () {
                  var referencedElement = this.context.map.get(this.ref);
                  if (referencedElement != null) {
                    this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                    return;
                  }
                  if (Kotlin.equals(this.ref, '/0/') || Kotlin.equals(this.ref, '/')) {
                    referencedElement = this.context.map.get('/0');
                    if (referencedElement != null) {
                      this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                      return;
                    }
                  }
                  throw new Error('KMF Load error : reference ' + this.ref + ' not found in map when trying to  ' + this.mutatorType + ' ' + this.refName + '  on ' + Kotlin.toString(this.target));
                }
              }),
              ReferencesVisitor: Kotlin.createClass(_c.ModelVisitor, function $fun(ostream, addressTable, elementsCount) {
                this.ostream = ostream;
                this.addressTable = addressTable;
                this.elementsCount = elementsCount;
                $fun.baseInitializer.call(this);
                this.value = null;
              }, /** @lends _.org.kevoree.modeling.api.xmi.ReferencesVisitor.prototype */ {
                beginVisitElem: function (elem) {
                },
                endVisitElem: function (elem) {
                },
                beginVisitRef: function (refName, refType) {
                },
                endVisitRef: function (refName) {
                  if (this.value != null) {
                    this.ostream.print(' ' + refName + '="' + Kotlin.toString(this.value) + '"');
                    this.value = null;
                  }
                },
                visit: function (elem, refNameInParent, parent) {
                  var adjustedAddress = this.addressTable.get(elem);
                  if (this.value == null) {
                    this.value = adjustedAddress;
                  }
                   else {
                    this.value = _.jet.plus(this.value, ' ' + adjustedAddress);
                  }
                }
              }),
              AttributesVisitor: Kotlin.createClass(_c.ModelAttributeVisitor, function (ostream) {
                this.ostream = ostream;
              }, /** @lends _.org.kevoree.modeling.api.xmi.AttributesVisitor.prototype */ {
                visit: function (value, name, parent) {
                  if (value != null) {
                    this.ostream.print(' ' + name + '="');
                    if (Kotlin.isType(value, Date)) {
                      this.escapeXml(this.ostream, '' + value.getTime());
                    }
                     else {
                      this.escapeXml(this.ostream, Kotlin.toString(value));
                    }
                    this.ostream.print('"');
                  }
                },
                escapeXml: function (ostream, chain) {
                  if (chain == null) {
                    return;
                  }
                  var i = 0;
                  var max = chain.length;
                  while (i < max) {
                    var c = chain.charAt(i);
                    if (c === '"') {
                      ostream.print('&quot;');
                    }
                     else if (c === '&') {
                      ostream.print('&amp;');
                    }
                     else if (c === "'") {
                      ostream.print('&apos;');
                    }
                     else if (c === '<') {
                      ostream.print('&lt;');
                    }
                     else if (c === '>') {
                      ostream.print('&gt;');
                    }
                     else {
                      ostream.print_0(c);
                    }
                    i = i + 1;
                  }
                }
              }),
              ModelSerializationVisitor: Kotlin.createClass(_c.ModelVisitor, function $fun(ostream, addressTable, elementsCount) {
                this.ostream = ostream;
                this.addressTable = addressTable;
                this.elementsCount = elementsCount;
                $fun.baseInitializer.call(this);
                this.attributeVisitor = new _.org.kevoree.modeling.api.xmi.AttributesVisitor(this.ostream);
                this.referenceVisitor = new _.org.kevoree.modeling.api.xmi.ReferencesVisitor(this.ostream, this.addressTable, this.elementsCount);
              }, /** @lends _.org.kevoree.modeling.api.xmi.ModelSerializationVisitor.prototype */ {
                beginVisitElem: function (elem) {
                },
                endVisitElem: function (elem) {
                },
                beginVisitRef: function (refName, refType) {
                },
                endVisitRef: function (refName) {
                },
                visit: function (elem, refNameInParent, parent) {
                  this.ostream.print_0('<');
                  this.ostream.print(refNameInParent);
                  this.ostream.print(' xsi:type="' + this.formatMetaClassName(elem.metaClassName()) + '"');
                  elem.visitAttributes(this.attributeVisitor);
                  elem.visit(this.referenceVisitor, false, false, true);
                  this.ostream.println_1('>');
                  elem.visit(this, false, true, false);
                  this.ostream.print('<\/');
                  this.ostream.print(refNameInParent);
                  this.ostream.print_0('>');
                  this.ostream.println();
                },
                formatMetaClassName: function (metaClassName) {
                  var lastPoint = _.js.lastIndexOf(metaClassName, '.');
                  var pack = metaClassName.substring(0, lastPoint);
                  var cls = metaClassName.substring(lastPoint + 1);
                  return pack + ':' + cls;
                }
              }),
              ModelAddressVisitor: Kotlin.createClass(_c.ModelVisitor, function $fun(addressTable, elementsCount, packageList) {
                this.addressTable = addressTable;
                this.elementsCount = elementsCount;
                this.packageList = packageList;
                $fun.baseInitializer.call(this);
              }, /** @lends _.org.kevoree.modeling.api.xmi.ModelAddressVisitor.prototype */ {
                beginVisitElem: function (elem) {
                },
                endVisitElem: function (elem) {
                },
                beginVisitRef: function (refName, refType) {
                },
                endVisitRef: function (refName) {
                },
                visit: function (elem, refNameInParent, parent) {
                  var tmp$0, tmp$1;
                  var parentXmiAddress = (tmp$0 = this.addressTable.get(parent)) != null ? tmp$0 : Kotlin.throwNPE();
                  var i = (tmp$1 = this.elementsCount.get(parentXmiAddress + '/@' + refNameInParent)) != null ? tmp$1 : 0;
                  this.addressTable.put(elem, parentXmiAddress + '/@' + refNameInParent + '.' + i);
                  this.elementsCount.put(parentXmiAddress + '/@' + refNameInParent, i + 1);
                  var pack = elem.metaClassName().substring(0, _.js.lastIndexOf(elem.metaClassName(), '.'));
                  if (!this.packageList.contains(pack))
                    this.packageList.add(pack);
                }
              }),
              XMIModelSerializer: _c.XMIModelSerializer,
              XmlParser: Kotlin.createClass(null, function (inputStream) {
                this.inputStream = inputStream;
                this.bytes = this.inputStream.readBytes();
                this.index = -1;
                this.currentChar = null;
                this.xmlVersion = null;
                this.xmlCharset = null;
                this.tagName = '';
                this.tagPrefix = null;
                this.attributesNames = new Kotlin.ArrayList(0);
                this.attributesPrefixes = new Kotlin.ArrayList(0);
                this.attributesValues = new Kotlin.ArrayList(0);
                this.attributeName = new _.java.lang.StringBuilder();
                this.attributePrefix = null;
                this.attributeValue = new _.java.lang.StringBuilder();
                this.readSingleton = false;
              }, /** @lends _.org.kevoree.modeling.api.xmi.XmlParser.prototype */ {
                hasNext: function () {
                  return this.bytes.length - this.index > 2;
                },
                getLocalName: function () {
                  return this.tagName;
                },
                getAttributeCount: function () {
                  return this.attributesNames.size();
                },
                getAttributeLocalName: function (i) {
                  return this.attributesNames.get(i);
                },
                getAttributePrefix: function (i) {
                  return this.attributesPrefixes.get(i);
                },
                getAttributeValue: function (i) {
                  return this.attributesValues.get(i);
                },
                readChar: function () {
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[this.index = this.index + 1, this.index]);
                },
                next: function () {
                  if (this.readSingleton) {
                    this.readSingleton = false;
                    return _.org.kevoree.modeling.api.xmi.Token.END_TAG;
                  }
                  if (!this.hasNext()) {
                    return _.org.kevoree.modeling.api.xmi.Token.END_DOCUMENT;
                  }
                  this.attributesNames.clear();
                  this.attributesPrefixes.clear();
                  this.attributesValues.clear();
                  this.read_lessThan();
                  this.currentChar = this.readChar();
                  if (this.currentChar === '?') {
                    this.currentChar = this.readChar();
                    this.read_xmlHeader();
                    return _.org.kevoree.modeling.api.xmi.Token.XML_HEADER;
                  }
                   else if (this.currentChar === '!') {
                    do {
                      this.currentChar = this.readChar();
                    }
                     while (this.currentChar !== '>');
                    return _.org.kevoree.modeling.api.xmi.Token.COMMENT;
                  }
                   else if (this.currentChar === '/') {
                    this.currentChar = this.readChar();
                    this.read_closingTag();
                    return _.org.kevoree.modeling.api.xmi.Token.END_TAG;
                  }
                   else {
                    this.read_openTag();
                    if (this.currentChar === '/') {
                      this.read_upperThan();
                      this.readSingleton = true;
                    }
                    return _.org.kevoree.modeling.api.xmi.Token.START_TAG;
                  }
                },
                read_lessThan: function () {
                  do {
                    this.currentChar = this.readChar();
                  }
                   while (this.currentChar !== '<');
                },
                read_upperThan: function () {
                  while (this.currentChar !== '>') {
                    this.currentChar = this.readChar();
                  }
                },
                read_xmlHeader: function () {
                  this.read_tagName();
                  this.read_attributes();
                  this.read_upperThan();
                },
                read_closingTag: function () {
                  this.read_tagName();
                  this.read_upperThan();
                },
                read_openTag: function () {
                  this.read_tagName();
                  if (this.currentChar !== '>') {
                    this.read_attributes();
                  }
                },
                read_tagName: function () {
                  this.tagName = '' + this.currentChar;
                  this.tagPrefix = null;
                  this.currentChar = this.readChar();
                  while (this.currentChar !== ' ' && this.currentChar !== '>') {
                    if (this.currentChar === ':') {
                      this.tagPrefix = this.tagName;
                      this.tagName = '';
                    }
                     else {
                      this.tagName = this.tagName + this.currentChar;
                    }
                    this.currentChar = this.readChar();
                  }
                },
                read_attributes: function () {
                  var end_of_tag = false;
                  while (this.currentChar === ' ') {
                    this.currentChar = this.readChar();
                  }
                  while (!end_of_tag) {
                    while (this.currentChar !== '=') {
                      if (this.currentChar === ':') {
                        this.attributePrefix = this.attributeName.toString();
                        this.attributeName.delete(0, this.attributeName.length());
                      }
                       else {
                        var tmp$0;
                        this.attributeName.append_0((tmp$0 = this.currentChar) != null ? tmp$0 : Kotlin.throwNPE());
                      }
                      this.currentChar = this.readChar();
                    }
                    do {
                      this.currentChar = this.readChar();
                    }
                     while (this.currentChar !== '"');
                    this.currentChar = this.readChar();
                    while (this.currentChar !== '"') {
                      var tmp$1;
                      this.attributeValue.append_0((tmp$1 = this.currentChar) != null ? tmp$1 : Kotlin.throwNPE());
                      this.currentChar = this.readChar();
                    }
                    this.attributesNames.add(this.attributeName.toString());
                    this.attributesPrefixes.add(this.attributePrefix);
                    this.attributesValues.add(this.attributeValue.toString());
                    this.attributeName.delete(0, this.attributeName.length());
                    this.attributePrefix = null;
                    this.attributeValue.delete(0, this.attributeValue.length());
                    do {
                      this.currentChar = this.readChar();
                      if (this.currentChar === '?' || this.currentChar === '/' || this.currentChar === '-' || this.currentChar === '>') {
                        end_of_tag = true;
                      }
                    }
                     while (!end_of_tag && this.currentChar === ' ');
                  }
                }
              })
            }),
            json: Kotlin.definePackage(function () {
              this.Type = Kotlin.createObject(null, function () {
                this.VALUE = 0;
                this.LEFT_BRACE = 1;
                this.RIGHT_BRACE = 2;
                this.LEFT_BRACKET = 3;
                this.RIGHT_BRACKET = 4;
                this.COMMA = 5;
                this.COLON = 6;
                this.EOF = 42;
              });
            }, /** @lends _.org.kevoree.modeling.api.json */ {
              Token: Kotlin.createClass(null, function (tokenType, value) {
                this.tokenType = tokenType;
                this.value = value;
              }, /** @lends _.org.kevoree.modeling.api.json.Token.prototype */ {
                toString: function () {
                  var tmp$0;
                  if (this.value != null) {
                    tmp$0 = ' (' + this.value + ')';
                  }
                   else {
                    tmp$0 = '';
                  }
                  var v = tmp$0;
                  var result = Kotlin.toString(this.tokenType) + v;
                  return result;
                }
              }),
              Lexer: Kotlin.createClass(null, function (inputStream) {
                this.inputStream = inputStream;
                this.bytes = this.inputStream.readBytes();
                this.EOF = new _.org.kevoree.modeling.api.json.Token(_.org.kevoree.modeling.api.json.Type.EOF, null);
                this.index = 0;
                this.BOOLEAN_LETTERS = null;
                this.DIGIT = null;
              }, /** @lends _.org.kevoree.modeling.api.json.Lexer.prototype */ {
                isSpace: function (c) {
                  return c === ' ' || c === '\r' || c === '\n' || c === '\t';
                },
                nextChar: function () {
                  var tmp$0, tmp$1;
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[tmp$0 = this.index, tmp$1 = tmp$0, this.index = tmp$0 + 1, tmp$1]);
                },
                peekChar: function () {
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[this.index]);
                },
                isDone: function () {
                  return this.index >= this.bytes.length;
                },
                isBooleanLetter: function (c) {
                  if (this.BOOLEAN_LETTERS == null) {
                    this.BOOLEAN_LETTERS = new Kotlin.PrimitiveHashSet();
                    var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7;
                    ((tmp$0 = this.BOOLEAN_LETTERS) != null ? tmp$0 : Kotlin.throwNPE()).add('f');
                    ((tmp$1 = this.BOOLEAN_LETTERS) != null ? tmp$1 : Kotlin.throwNPE()).add('a');
                    ((tmp$2 = this.BOOLEAN_LETTERS) != null ? tmp$2 : Kotlin.throwNPE()).add('l');
                    ((tmp$3 = this.BOOLEAN_LETTERS) != null ? tmp$3 : Kotlin.throwNPE()).add('s');
                    ((tmp$4 = this.BOOLEAN_LETTERS) != null ? tmp$4 : Kotlin.throwNPE()).add('e');
                    ((tmp$5 = this.BOOLEAN_LETTERS) != null ? tmp$5 : Kotlin.throwNPE()).add('t');
                    ((tmp$6 = this.BOOLEAN_LETTERS) != null ? tmp$6 : Kotlin.throwNPE()).add('r');
                    ((tmp$7 = this.BOOLEAN_LETTERS) != null ? tmp$7 : Kotlin.throwNPE()).add('u');
                  }
                  var tmp$8;
                  return ((tmp$8 = this.BOOLEAN_LETTERS) != null ? tmp$8 : Kotlin.throwNPE()).contains(c);
                },
                isDigit: function (c) {
                  if (this.DIGIT == null) {
                    this.DIGIT = new Kotlin.PrimitiveHashSet();
                    var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7, tmp$8, tmp$9;
                    ((tmp$0 = this.DIGIT) != null ? tmp$0 : Kotlin.throwNPE()).add('0');
                    ((tmp$1 = this.DIGIT) != null ? tmp$1 : Kotlin.throwNPE()).add('1');
                    ((tmp$2 = this.DIGIT) != null ? tmp$2 : Kotlin.throwNPE()).add('2');
                    ((tmp$3 = this.DIGIT) != null ? tmp$3 : Kotlin.throwNPE()).add('3');
                    ((tmp$4 = this.DIGIT) != null ? tmp$4 : Kotlin.throwNPE()).add('4');
                    ((tmp$5 = this.DIGIT) != null ? tmp$5 : Kotlin.throwNPE()).add('5');
                    ((tmp$6 = this.DIGIT) != null ? tmp$6 : Kotlin.throwNPE()).add('6');
                    ((tmp$7 = this.DIGIT) != null ? tmp$7 : Kotlin.throwNPE()).add('7');
                    ((tmp$8 = this.DIGIT) != null ? tmp$8 : Kotlin.throwNPE()).add('8');
                    ((tmp$9 = this.DIGIT) != null ? tmp$9 : Kotlin.throwNPE()).add('9');
                  }
                  var tmp$10;
                  return ((tmp$10 = this.DIGIT) != null ? tmp$10 : Kotlin.throwNPE()).contains(c);
                },
                isValueLetter: function (c) {
                  return c === '-' || c === '+' || c === '.' || this.isDigit(c) || this.isBooleanLetter(c);
                },
                nextToken: function () {
                  if (this.isDone()) {
                    return this.EOF;
                  }
                  var tokenType = _.org.kevoree.modeling.api.json.Type.EOF;
                  var c = this.nextChar();
                  var currentValue = new _.java.lang.StringBuilder();
                  var jsonValue = null;
                  while (!this.isDone() && this.isSpace(c)) {
                    c = this.nextChar();
                  }
                  if ('"' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.VALUE;
                    if (!this.isDone()) {
                      c = this.nextChar();
                      while (this.index < this.bytes.length && c !== '"') {
                        currentValue.append_0(c);
                        if (c === '\\' && this.index < this.bytes.length) {
                          c = this.nextChar();
                          currentValue.append_0(c);
                        }
                        c = this.nextChar();
                      }
                      jsonValue = currentValue.toString();
                    }
                     else {
                      throw new Kotlin.RuntimeException('Unterminated string');
                    }
                  }
                   else if ('{' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.LEFT_BRACE;
                  }
                   else if ('}' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE;
                  }
                   else if ('[' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET;
                  }
                   else if (']' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET;
                  }
                   else if (':' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.COLON;
                  }
                   else if (',' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.COMMA;
                  }
                   else if (!this.isDone()) {
                    while (this.isValueLetter(c)) {
                      currentValue.append_0(c);
                      if (!this.isValueLetter(this.peekChar())) {
                        break;
                      }
                       else {
                        c = this.nextChar();
                      }
                    }
                    var v = currentValue.toString();
                    if (Kotlin.equals('true', v.toLowerCase())) {
                      jsonValue = true;
                    }
                     else if (Kotlin.equals('false', v.toLowerCase())) {
                      jsonValue = false;
                    }
                     else {
                      jsonValue = v.toLowerCase();
                    }
                    tokenType = _.org.kevoree.modeling.api.json.Type.VALUE;
                  }
                   else {
                    tokenType = _.org.kevoree.modeling.api.json.Type.EOF;
                  }
                  return new _.org.kevoree.modeling.api.json.Token(tokenType, jsonValue);
                }
              }),
              JSONModelLoader: _c.JSONModelLoader,
              ResolveCommand: Kotlin.createClass(null, function (roots, ref, currentRootElem, refName) {
                this.roots = roots;
                this.ref = ref;
                this.currentRootElem = currentRootElem;
                this.refName = refName;
              }, /** @lends _.org.kevoree.modeling.api.json.ResolveCommand.prototype */ {
                run: function () {
                  var referencedElement = null;
                  var i = 0;
                  while (referencedElement == null && i < this.roots.size()) {
                    referencedElement = this.roots.get(i++).findByPath(this.ref);
                  }
                  if (referencedElement != null) {
                    this.currentRootElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, this.refName, referencedElement, false, false);
                  }
                   else {
                    throw new Error('Unresolved ' + this.ref);
                  }
                }
              }),
              ModelReferenceVisitor: Kotlin.createClass(_c.ModelVisitor, function $fun(out) {
                this.out = out;
                $fun.baseInitializer.call(this);
                this.isFirst = true;
              }, /** @lends _.org.kevoree.modeling.api.json.ModelReferenceVisitor.prototype */ {
                beginVisitRef: function (refName, refType) {
                  this.out.print(',"' + refName + '":[');
                  this.isFirst = true;
                },
                endVisitRef: function (refName) {
                  this.out.print(']');
                },
                visit: function (elem, refNameInParent, parent) {
                  if (!this.isFirst) {
                    this.out.print(',');
                  }
                   else {
                    this.isFirst = false;
                  }
                  this.out.print('"' + elem.path() + '"');
                }
              }),
              JSONModelSerializer: _c.JSONModelSerializer
            }),
            events: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api.events */ {
              ModelEvent: Kotlin.createClass(null, function (internal_sourcePath, internal_etype, internal_elementAttributeType, internal_elementAttributeName, internal_value) {
                this.internal_sourcePath = internal_sourcePath;
                this.internal_etype = internal_etype;
                this.internal_elementAttributeType = internal_elementAttributeType;
                this.internal_elementAttributeName = internal_elementAttributeName;
                this.internal_value = internal_value;
              }, /** @lends _.org.kevoree.modeling.api.events.ModelEvent.prototype */ {
                getSourcePath: function () {
                  return this.internal_sourcePath;
                },
                getType: function () {
                  return this.internal_etype;
                },
                getElementAttributeType: function () {
                  return this.internal_elementAttributeType;
                },
                getElementAttributeName: function () {
                  return this.internal_elementAttributeName;
                },
                getValue: function () {
                  return this.internal_value;
                },
                toString: function () {
                  return 'ModelEvent[src:' + this.getSourcePath() + ', type:' + this.getType() + ', elementAttributeType:' + this.getElementAttributeType() + ', elementAttributeName:' + this.getElementAttributeName() + ', value:' + this.getValue() + ']';
                }
              })
            }),
            trace: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api.trace */ {
              ModelAddTrace: Kotlin.createClass(_c.ModelTrace, function (srcPath, refName, previousPath, typeName) {
                this.srcPath = srcPath;
                this.refName = refName;
                this.previousPath = previousPath;
                this.typeName = typeName;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelAddTrace.prototype */ {
                toString: function () {
                  var buffer = new _.java.lang.StringBuilder();
                  buffer.append('{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.ADD + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '"');
                  if (this.previousPath != null) {
                    buffer.append(', "previouspath" : "' + this.previousPath + '"');
                  }
                  if (this.typeName != null) {
                    buffer.append(', "typename" : "' + this.typeName + '"');
                  }
                  buffer.append('}');
                  return buffer.toString();
                }
              }),
              ModelAddAllTrace: Kotlin.createClass(_c.ModelTrace, function (srcPath, refName, previousPath, typeName) {
                this.srcPath = srcPath;
                this.refName = refName;
                this.previousPath = previousPath;
                this.typeName = typeName;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelAddAllTrace.prototype */ {
                mkString: function (ss) {
                  if (ss == null) {
                    return null;
                  }
                  var buffer = new _.java.lang.StringBuilder();
                  var isFirst = true;
                  {
                    var tmp$0 = ss.iterator();
                    while (tmp$0.hasNext()) {
                      var s = tmp$0.next();
                      if (!isFirst) {
                        buffer.append(',');
                      }
                      buffer.append(s);
                      isFirst = false;
                    }
                  }
                  return buffer.toString();
                },
                toString: function () {
                  var buffer = new _.java.lang.StringBuilder();
                  buffer.append('{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.ADD_ALL + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '"');
                  if (this.previousPath != null) {
                    buffer.append(', "previouspath" : "' + this.mkString(this.previousPath) + '"');
                  }
                  if (this.typeName != null) {
                    buffer.append(', "typename" : "' + this.mkString(this.typeName) + '"');
                  }
                  buffer.append('}');
                  return buffer.toString();
                }
              }),
              ModelRemoveTrace: Kotlin.createClass(_c.ModelTrace, function (srcPath, refName, objPath) {
                this.srcPath = srcPath;
                this.refName = refName;
                this.objPath = objPath;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelRemoveTrace.prototype */ {
                toString: function () {
                  return '{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.REMOVE + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '", "objpath" : "' + this.objPath + '" }';
                }
              }),
              ModelRemoveAllTrace: Kotlin.createClass(_c.ModelTrace, function (srcPath, refName) {
                this.srcPath = srcPath;
                this.refName = refName;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace.prototype */ {
                toString: function () {
                  return '{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '" }';
                }
              }),
              ModelSetTrace: Kotlin.createClass(_c.ModelTrace, function (srcPath, refName, objPath, content, typeName) {
                this.srcPath = srcPath;
                this.refName = refName;
                this.objPath = objPath;
                this.content = content;
                this.typeName = typeName;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelSetTrace.prototype */ {
                toString: function () {
                  var buffer = new _.java.lang.StringBuilder();
                  buffer.append('{ "traceType" : ' + _.org.kevoree.modeling.api.util.ActionType.SET + ' , "src" : "' + this.srcPath + '", "refname" : "' + this.refName + '"');
                  if (this.objPath != null) {
                    buffer.append(', "objpath" : "' + this.objPath + '"');
                  }
                  if (this.content != null) {
                    buffer.append(', "content" : "' + this.content + '"');
                  }
                  if (this.typeName != null) {
                    buffer.append(', "typename" : "' + this.typeName + '"');
                  }
                  buffer.append('}');
                  return buffer.toString();
                }
              }),
              DefaultTraceConverter: Kotlin.createClass(_c.TraceConverter, function () {
                this.metaClassNameEquivalence_1 = new Kotlin.PrimitiveHashMap(0);
                this.metaClassNameEquivalence_2 = new Kotlin.PrimitiveHashMap(0);
                this.attNameEquivalence_1 = new Kotlin.PrimitiveHashMap(0);
                this.attNameEquivalence_2 = new Kotlin.PrimitiveHashMap(0);
              }, /** @lends _.org.kevoree.modeling.api.trace.DefaultTraceConverter.prototype */ {
                addMetaClassEquivalence: function (name1, name2) {
                  this.metaClassNameEquivalence_1.put(name1, name2);
                  this.metaClassNameEquivalence_2.put(name2, name2);
                },
                addAttEquivalence: function (name1, name2) {
                  var fqnArray_1 = Kotlin.splitString(name1, '#');
                  var fqnArray_2 = Kotlin.splitString(name1, '#');
                  this.attNameEquivalence_1.put(name1, name2);
                  this.attNameEquivalence_2.put(name2, name2);
                },
                convert: function (trace) {
                  if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddTrace)) {
                    var addTrace = trace != null ? trace : Kotlin.throwNPE();
                    var newTrace = new _.org.kevoree.modeling.api.trace.ModelAddTrace(addTrace.srcPath, addTrace.refName, addTrace.previousPath, this.tryConvertClassName(addTrace.typeName));
                    return newTrace;
                  }
                   else if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelSetTrace)) {
                    var setTrace = trace != null ? trace : Kotlin.throwNPE();
                    var newTrace_0 = new _.org.kevoree.modeling.api.trace.ModelSetTrace(setTrace.srcPath, setTrace.refName, setTrace.objPath, setTrace.content, this.tryConvertClassName(setTrace.typeName));
                    return newTrace_0;
                  }
                   else {
                    return trace;
                  }
                },
                tryConvertPath: function (previousPath) {
                  if (previousPath == null) {
                    return null;
                  }
                  return previousPath;
                },
                tryConvertClassName: function (previousClassName) {
                  if (previousClassName == null) {
                    return null;
                  }
                  if (this.metaClassNameEquivalence_1.containsKey(previousClassName)) {
                    var tmp$0;
                    return (tmp$0 = this.metaClassNameEquivalence_1.get(previousClassName)) != null ? tmp$0 : Kotlin.throwNPE();
                  }
                  if (this.metaClassNameEquivalence_2.containsKey(previousClassName)) {
                    var tmp$1;
                    return (tmp$1 = this.metaClassNameEquivalence_2.get(previousClassName)) != null ? tmp$1 : Kotlin.throwNPE();
                  }
                  return previousClassName;
                },
                tryConvertAttName: function (previousAttName) {
                  if (previousAttName == null) {
                    return null;
                  }
                  var FQNattName = previousAttName;
                  if (this.attNameEquivalence_1.containsKey(FQNattName)) {
                    var tmp$0;
                    return (tmp$0 = this.attNameEquivalence_1.get(FQNattName)) != null ? tmp$0 : Kotlin.throwNPE();
                  }
                  if (this.attNameEquivalence_2.containsKey(FQNattName)) {
                    var tmp$1;
                    return (tmp$1 = this.attNameEquivalence_2.get(FQNattName)) != null ? tmp$1 : Kotlin.throwNPE();
                  }
                  return previousAttName;
                }
              }),
              ModelTraceApplicator: Kotlin.createClass(null, function (targetModel, factory) {
                this.targetModel = targetModel;
                this.factory = factory;
                this.pendingObj = null;
                this.pendingParent = null;
                this.pendingParentRefName = null;
                this.pendingObjPath = null;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelTraceApplicator.prototype */ {
                tryClosePending: function (srcPath) {
                  if (this.pendingObj != null && !Kotlin.equals(this.pendingObjPath, srcPath)) {
                    var tmp$0, tmp$1;
                    ((tmp$0 = this.pendingParent) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, (tmp$1 = this.pendingParentRefName) != null ? tmp$1 : Kotlin.throwNPE(), this.pendingObj, true, true);
                    this.pendingObj = null;
                    this.pendingObjPath = null;
                    this.pendingParentRefName = null;
                    this.pendingParent = null;
                  }
                },
                createOrAdd: function (previousPath, target, refName, potentialTypeName) {
                  var tmp$0;
                  if (previousPath != null) {
                    tmp$0 = this.targetModel.findByPath(previousPath);
                  }
                   else {
                    tmp$0 = null;
                  }
                  var targetElem = tmp$0;
                  if (targetElem != null) {
                    target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.ADD, refName, targetElem, true, true);
                  }
                   else {
                    this.pendingObj = this.factory.create(potentialTypeName != null ? potentialTypeName : Kotlin.throwNPE());
                    this.pendingObjPath = previousPath;
                    this.pendingParentRefName = refName;
                    this.pendingParent = target;
                  }
                },
                applyTraceOnModel: function (traceSeq) {
                  {
                    var tmp$0 = traceSeq.traces.iterator();
                    while (tmp$0.hasNext()) {
                      var trace = tmp$0.next();
                      var target = this.targetModel;
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddTrace)) {
                        var castedTrace = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(null);
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          var tmp$1;
                          target = (tmp$1 = this.targetModel.findByPath(castedTrace.srcPath)) != null ? tmp$1 : Kotlin.throwNPE();
                        }
                        this.createOrAdd(castedTrace.previousPath, target, castedTrace.refName, castedTrace.typeName);
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddAllTrace)) {
                        var castedTrace_0 = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(null);
                        var i = 0;
                        var tmp$2;
                        {
                          var tmp$3 = ((tmp$2 = castedTrace_0.previousPath) != null ? tmp$2 : Kotlin.throwNPE()).iterator();
                          while (tmp$3.hasNext()) {
                            var path = tmp$3.next();
                            var tmp$4;
                            this.createOrAdd(path, target, castedTrace_0.refName, ((tmp$4 = castedTrace_0.typeName) != null ? tmp$4 : Kotlin.throwNPE()).get(i));
                            i++;
                          }
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelRemoveTrace)) {
                        var castedTrace_1 = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(trace.srcPath);
                        var tempTarget = this.targetModel;
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          tempTarget = this.targetModel.findByPath(castedTrace_1.srcPath);
                        }
                        if (tempTarget != null) {
                          (tempTarget != null ? tempTarget : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE, castedTrace_1.refName, this.targetModel.findByPath(castedTrace_1.objPath), true, true);
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace)) {
                        var castedTrace_2 = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(trace.srcPath);
                        var tempTarget_0 = this.targetModel;
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          tempTarget_0 = this.targetModel.findByPath(castedTrace_2.srcPath);
                        }
                        if (tempTarget_0 != null) {
                          (tempTarget_0 != null ? tempTarget_0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.REMOVE_ALL, castedTrace_2.refName, null, true, true);
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelSetTrace)) {
                        var castedTrace_3 = trace != null ? trace : Kotlin.throwNPE();
                        this.tryClosePending(trace.srcPath);
                        if (!Kotlin.equals(trace.srcPath, '') && !Kotlin.equals(castedTrace_3.srcPath, this.pendingObjPath)) {
                          var tempObject = this.targetModel.findByPath(castedTrace_3.srcPath);
                          if (tempObject == null) {
                            throw new Error('Set Trace source not found for path : ' + castedTrace_3.srcPath + '/ pending ' + this.pendingObjPath + '\n' + trace.toString());
                          }
                          target = tempObject != null ? tempObject : Kotlin.throwNPE();
                        }
                         else {
                          if (Kotlin.equals(castedTrace_3.srcPath, this.pendingObjPath) && this.pendingObj != null) {
                            var tmp$5;
                            target = (tmp$5 = this.pendingObj) != null ? tmp$5 : Kotlin.throwNPE();
                          }
                        }
                        if (castedTrace_3.content != null) {
                          target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, castedTrace_3.refName, castedTrace_3.content, true, true);
                        }
                         else {
                          var tmp$7;
                          if (castedTrace_3.objPath != null) {
                            var tmp$6;
                            tmp$7 = this.targetModel.findByPath((tmp$6 = castedTrace_3.objPath) != null ? tmp$6 : Kotlin.throwNPE());
                          }
                           else {
                            tmp$7 = null;
                          }
                          var targetContentPath = tmp$7;
                          if (targetContentPath != null) {
                            target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, castedTrace_3.refName, targetContentPath, true, true);
                          }
                           else {
                            if (castedTrace_3.typeName != null && !Kotlin.equals(castedTrace_3.typeName, '')) {
                              this.createOrAdd(castedTrace_3.objPath, target, castedTrace_3.refName, castedTrace_3.typeName);
                            }
                             else {
                              target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.SET, castedTrace_3.refName, targetContentPath, true, true);
                            }
                          }
                        }
                      }
                    }
                  }
                  this.tryClosePending(null);
                }
              }),
              Event2Trace: Kotlin.createClass(null, function (compare) {
                this.compare = compare;
              }, /** @lends _.org.kevoree.modeling.api.trace.Event2Trace.prototype */ {
                convert: function (event) {
                  var result = new Kotlin.ArrayList(0);
                  var tmp$0 = event.getType();
                  if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                    var tmp$1, tmp$2, tmp$3, tmp$4;
                    result.add(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$1 = event.getSourcePath()) != null ? tmp$1 : Kotlin.throwNPE(), (tmp$2 = event.getElementAttributeName()) != null ? tmp$2 : Kotlin.throwNPE(), (tmp$4 = ((tmp$3 = event.getValue()) != null ? tmp$3 : Kotlin.throwNPE()).path()) != null ? tmp$4 : Kotlin.throwNPE()));
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.REMOVE) {
                    var tmp$5, tmp$6;
                    result.add(new _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace((tmp$5 = event.getSourcePath()) != null ? tmp$5 : Kotlin.throwNPE(), (tmp$6 = event.getElementAttributeName()) != null ? tmp$6 : Kotlin.throwNPE()));
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.ADD) {
                    var tmp$7, tmp$8, tmp$9;
                    var casted = (tmp$7 = event.getValue()) != null ? tmp$7 : Kotlin.throwNPE();
                    var traces = this.compare.inter(casted, casted);
                    result.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$8 = event.getSourcePath()) != null ? tmp$8 : Kotlin.throwNPE(), (tmp$9 = event.getElementAttributeName()) != null ? tmp$9 : Kotlin.throwNPE(), casted.path(), casted.metaClassName()));
                    result.addAll(traces.traces);
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.ADD_ALL) {
                    var tmp$10;
                    var casted_0 = (tmp$10 = event.getValue()) != null ? tmp$10 : Kotlin.throwNPE();
                    {
                      var tmp$11 = (casted_0 != null ? casted_0 : Kotlin.throwNPE()).iterator();
                      while (tmp$11.hasNext()) {
                        var elem = tmp$11.next();
                        var elemCasted = elem != null ? elem : Kotlin.throwNPE();
                        var traces_0 = this.compare.inter(elemCasted, elemCasted);
                        var tmp$12, tmp$13;
                        result.add(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$12 = event.getSourcePath()) != null ? tmp$12 : Kotlin.throwNPE(), (tmp$13 = event.getElementAttributeName()) != null ? tmp$13 : Kotlin.throwNPE(), elemCasted.path(), elemCasted.metaClassName()));
                        result.addAll(traces_0.traces);
                      }
                    }
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.SET) {
                    if (event.getElementAttributeType() === _.org.kevoree.modeling.api.util.ElementAttributeType.ATTRIBUTE) {
                      var tmp$14, tmp$15;
                      result.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$14 = event.getSourcePath()) != null ? tmp$14 : Kotlin.throwNPE(), (tmp$15 = event.getElementAttributeName()) != null ? tmp$15 : Kotlin.throwNPE(), null, Kotlin.toString(event.getValue()), null));
                    }
                     else {
                      var tmp$16, tmp$17, tmp$18;
                      result.add(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$16 = event.getSourcePath()) != null ? tmp$16 : Kotlin.throwNPE(), (tmp$17 = event.getElementAttributeName()) != null ? tmp$17 : Kotlin.throwNPE(), ((tmp$18 = event.getValue()) != null ? tmp$18 : Kotlin.throwNPE()).path(), null, null));
                    }
                  }
                   else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.RENEW_INDEX) {
                  }
                   else {
                    throw new Error("Can't convert event : " + event);
                  }
                  return this.compare.createSequence().populate(result);
                }
              }),
              TraceSequence: _c.TraceSequence
            }),
            util: Kotlin.definePackage(function () {
              this.ElementAttributeType = Kotlin.createObject(null, function () {
                this.ATTRIBUTE = 0;
                this.REFERENCE = 1;
                this.CONTAINMENT = 2;
              });
              this.ActionType = Kotlin.createObject(null, function () {
                this.SET = 0;
                this.ADD = 1;
                this.REMOVE = 2;
                this.ADD_ALL = 3;
                this.REMOVE_ALL = 4;
                this.RENEW_INDEX = 5;
              });
              this.ByteConverter = Kotlin.createObject(null, null, {
                toChar: function (b) {
                  return b != null ? b : Kotlin.throwNPE();
                },
                fromChar: function (b) {
                  return b != null ? b : Kotlin.throwNPE();
                },
                byteArrayInputStreamFromString: function (str) {
                  var bytes = Kotlin.numberArrayOfSize(str.length);
                  var i = 0;
                  while (i < str.length) {
                    var tmp$0;
                    bytes[i] = (tmp$0 = str.charAt(i)) != null ? tmp$0 : Kotlin.throwNPE();
                    i = i + 1;
                  }
                  return new _.java.io.ByteArrayInputStream(bytes);
                }
              });
            }, /** @lends _.org.kevoree.modeling.api.util */ {
              ModelVisitor: _c.ModelVisitor,
              ModelAttributeVisitor: _c.ModelAttributeVisitor
            })
          })
        }),
        log: Kotlin.definePackage(function () {
          this.Log = Kotlin.createObject(null, function () {
            this.LEVEL_NONE = 6;
            this.LEVEL_ERROR = 5;
            this.LEVEL_WARN = 4;
            this.LEVEL_INFO = 3;
            this.LEVEL_DEBUG = 2;
            this.LEVEL_TRACE = 1;
            this.$level = this.LEVEL_INFO;
            this._ERROR = this.level <= this.LEVEL_ERROR;
            this._WARN = this.level <= this.LEVEL_WARN;
            this._INFO = this.level <= this.LEVEL_INFO;
            this._DEBUG = this.level <= this.LEVEL_DEBUG;
            this._TRACE = this.level <= this.LEVEL_TRACE;
            this.logger = new _.org.kevoree.log.Logger();
            this.beginParam = '{';
            this.endParam = '}';
          }, {
            level: {
              get: function () {
                return this.$level;
              },
              set: function (newLevel) {
                this.$level = newLevel;
                this._ERROR = newLevel <= this.LEVEL_ERROR;
                this._WARN = newLevel <= this.LEVEL_WARN;
                this._INFO = newLevel <= this.LEVEL_INFO;
                this._DEBUG = newLevel <= this.LEVEL_DEBUG;
                this._TRACE = newLevel <= this.LEVEL_TRACE;
              }
            },
            NONE: function () {
              this.level = this.LEVEL_NONE;
            },
            ERROR: function () {
              this.level = this.LEVEL_ERROR;
            },
            WARN: function () {
              this.level = this.LEVEL_WARN;
            },
            INFO: function () {
              this.level = this.LEVEL_INFO;
            },
            DEBUG: function () {
              this.level = this.LEVEL_DEBUG;
            },
            TRACE: function () {
              this.level = this.LEVEL_TRACE;
            },
            processMessage: function (message, p1, p2, p3, p4, p5) {
              if (p1 == null) {
                return message;
              }
              var buffer = new _.java.lang.StringBuilder();
              var previousCharfound = false;
              var param = 0;
              var i = 0;
              while (i < message.length) {
                var currentChar = message.charAt(i);
                if (previousCharfound) {
                  if (currentChar === this.endParam) {
                    param++;
                    if (param === 1) {
                      buffer = new _.java.lang.StringBuilder();
                      buffer.append(message.substring(0, i - 1));
                      buffer.append(Kotlin.toString(p1 != null ? p1 : Kotlin.throwNPE()));
                    }
                     else if (param === 2) {
                      buffer.append(Kotlin.toString(p2 != null ? p2 : Kotlin.throwNPE()));
                    }
                     else if (param === 3) {
                      buffer.append(Kotlin.toString(p3 != null ? p3 : Kotlin.throwNPE()));
                    }
                     else if (param === 4) {
                      buffer.append(Kotlin.toString(p4 != null ? p4 : Kotlin.throwNPE()));
                    }
                     else if (param === 5) {
                      buffer.append(Kotlin.toString(p5 != null ? p5 : Kotlin.throwNPE()));
                    }
                     else {
                    }
                    previousCharfound = false;
                  }
                   else {
                    if (buffer != null) {
                      message.charAt(i - 1);
                      buffer.append_0(currentChar);
                    }
                    previousCharfound = false;
                  }
                }
                 else {
                  if (currentChar === this.beginParam) {
                    previousCharfound = true;
                  }
                   else {
                    if (buffer != null) {
                      buffer.append_0(currentChar);
                    }
                  }
                }
                i = i + 1;
              }
              if (buffer != null) {
                return buffer.toString();
              }
               else {
                return message;
              }
            },
            error: function (message, ex, p1, p2, p3, p4, p5) {
              if (this._ERROR) {
                this.internal_error(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            error_0: function (message, p1, p2, p3, p4, p5) {
              if (this._ERROR) {
                this.internal_error(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_error: function (message, ex) {
              this.logger.log(this.LEVEL_ERROR, message, ex);
            },
            warn: function (message, ex, p1, p2, p3, p4, p5) {
              if (this._WARN) {
                this.internal_warn(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            warn_0: function (message, p1, p2, p3, p4, p5) {
              if (this._WARN) {
                this.internal_warn(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_warn: function (message, ex) {
              this.logger.log(this.LEVEL_WARN, message, ex);
            },
            info: function (message, ex, p1, p2, p3, p4, p5) {
              if (this._INFO) {
                this.internal_info(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            info_0: function (message, p1, p2, p3, p4, p5) {
              if (this._INFO) {
                this.internal_info(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_info: function (message, ex) {
              this.logger.log(this.LEVEL_INFO, message, ex);
            },
            debug: function (message, ex, p1, p2, p3, p4, p5) {
              if (this._DEBUG) {
                this.internal_debug(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            debug_0: function (message, p1, p2, p3, p4, p5) {
              if (this._DEBUG) {
                this.internal_debug(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_debug: function (message, ex) {
              this.logger.log(this.LEVEL_DEBUG, message, ex);
            },
            trace: function (message, ex, p1, p2, p3, p4, p5) {
              if (this._TRACE) {
                this.internal_trace(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            trace_0: function (message, p1, p2, p3, p4, p5) {
              if (this._TRACE) {
                this.internal_trace(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_trace: function (message, ex) {
              this.logger.log(this.LEVEL_TRACE, message, ex);
            }
          });
        }, /** @lends _.org.kevoree.log */ {
          Logger: Kotlin.createClass(null, function () {
            this.firstLogTime = (new Date()).getTime();
            this.error_msg = ' ERROR: ';
            this.warn_msg = ' WARN: ';
            this.info_msg = ' INFO: ';
            this.debug_msg = ' DEBUG: ';
            this.trace_msg = ' TRACE: ';
            this.category = null;
          }, /** @lends _.org.kevoree.log.Logger.prototype */ {
            setCategory: function (category) {
              this.category = category;
            },
            log: function (level, message, ex) {
              var builder = new _.java.lang.StringBuilder();
              var time = (new Date()).getTime() - this.firstLogTime;
              var minutes = time / (1000 * 60) | 0;
              var seconds = (time / 1000 | 0) % 60;
              if (minutes <= 9)
                builder.append_0('0');
              builder.append(Kotlin.toString(minutes));
              builder.append_0(':');
              if (seconds <= 9)
                builder.append_0('0');
              builder.append(Kotlin.toString(seconds));
              if (level === _.org.kevoree.log.Log.LEVEL_ERROR) {
                builder.append(this.error_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_WARN) {
                builder.append(this.warn_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_INFO) {
                builder.append(this.info_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_DEBUG) {
                builder.append(this.debug_msg);
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_TRACE) {
                builder.append(this.trace_msg);
              }
               else {
              }
              if (this.category != null) {
                builder.append_0('[');
                var tmp$0;
                builder.append(((tmp$0 = this.category) != null ? tmp$0 : Kotlin.throwNPE()).toString());
                builder.append('] ');
              }
              builder.append(message);
              if (ex != null) {
                builder.append(Kotlin.toString(ex.getMessage()));
              }
              if (level === _.org.kevoree.log.Log.LEVEL_ERROR) {
                console.error(builder.toString());
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_WARN) {
                console.warn(builder.toString());
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_INFO) {
                console.info(builder.toString());
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_DEBUG) {
                console.log(builder.toString());
              }
               else if (level === _.org.kevoree.log.Log.LEVEL_TRACE) {
                console.log(builder.toString());
              }
               else {
              }
            }
          })
        }),
        container: Kotlin.definePackage(function () {
          this.cleanCacheVisitor = Kotlin.createObject(_c.ModelVisitor, function $fun() {
            $fun.baseInitializer.call(this);
          }, {
            visit: function (elem, refNameInParent, parent) {
              (elem != null ? elem : Kotlin.throwNPE()).path_cache = null;
            }
          });
        }, /** @lends _.org.kevoree.container */ {
          RemoveFromContainerCommand: Kotlin.createClass(null, function (target, mutatorType, refName, element) {
            this.target = target;
            this.mutatorType = mutatorType;
            this.refName = refName;
            this.element = element;
          }, /** @lends _.org.kevoree.container.RemoveFromContainerCommand.prototype */ {
            run: function () {
              this.target.reflexiveMutator(this.mutatorType, this.refName, this.element, true, true);
            }
          })
        }),
        serializer: Kotlin.definePackage(null, /** @lends _.org.kevoree.serializer */ {
          XMIModelSerializer: Kotlin.createClass(_c.XMIModelSerializer, function $fun() {
            $fun.baseInitializer.call(this);
          }),
          JSONModelSerializer: Kotlin.createClass(_c.JSONModelSerializer, function $fun() {
            $fun.baseInitializer.call(this);
          })
        }),
        cloner: Kotlin.definePackage(null, /** @lends _.org.kevoree.cloner */ {
          DefaultModelCloner: Kotlin.createClass(_c.ModelCloner, function () {
            this.mainFactory = new _.org.kevoree.factory.MainFactory();
          }, /** @lends _.org.kevoree.cloner.DefaultModelCloner.prototype */ {
            createContext: function () {
              return new Kotlin.ComplexHashMap(0);
            }
          })
        }),
        compare: Kotlin.definePackage(null, /** @lends _.org.kevoree.compare */ {
          DefaultModelCompare: Kotlin.createClass(_c.ModelCompare, null, /** @lends _.org.kevoree.compare.DefaultModelCompare.prototype */ {
            createSequence: function () {
              return new _.org.kevoree.trace.DefaultTraceSequence();
            }
          })
        }),
        factory: Kotlin.definePackage(function () {
          this.Package = Kotlin.createObject(null, function () {
            this.ORG_KEVOREE = 0;
          }, {
            getPackageForName: function (metaClassName) {
              if (metaClassName.startsWith('org.kevoree')) {
                return 0;
              }
              return -1;
            }
          });
        }, /** @lends _.org.kevoree.factory */ {
          MainFactory: Kotlin.createClass(_c.KMFFactory, function () {
            this.factories = Kotlin.arrayFromFun(1, function (i) {
              return null;
            });
            this.factories[_.org.kevoree.factory.Package.ORG_KEVOREE] = new _.org.kevoree.impl.DefaultKevoreeFactory();
          }, /** @lends _.org.kevoree.factory.MainFactory.prototype */ {
            getFactoryForPackage: function (pack) {
              return this.factories[pack];
            },
            getKevoreeFactory: function () {
              var tmp$0;
              return (tmp$0 = this.factories[_.org.kevoree.factory.Package.ORG_KEVOREE]) != null ? tmp$0 : Kotlin.throwNPE();
            },
            setKevoreeFactory: function (fct) {
              this.factories[_.org.kevoree.factory.Package.ORG_KEVOREE] = fct;
            },
            create: function (metaClassName) {
              var pack = _.org.kevoree.factory.Package.getPackageForName(metaClassName);
              if (pack !== -1) {
                var tmp$0;
                return (tmp$0 = this.getFactoryForPackage(pack)) != null ? tmp$0.create(metaClassName) : null;
              }
               else {
                var tmp$1, tmp$2, tmp$3, tmp$4;
                {
                  tmp$1 = Kotlin.arrayIndices(this.factories), tmp$2 = tmp$1.start, tmp$3 = tmp$1.end, tmp$4 = tmp$1.increment;
                  for (var i = tmp$2; i <= tmp$3; i += tmp$4) {
                    var tmp$5;
                    var obj = ((tmp$5 = this.factories[i]) != null ? tmp$5 : Kotlin.throwNPE()).create(metaClassName);
                    if (obj != null) {
                      return obj;
                    }
                  }
                }
                return null;
              }
            }
          })
        }),
        trace: Kotlin.definePackage(null, /** @lends _.org.kevoree.trace */ {
          DefaultTraceSequence: Kotlin.createClass(_c.TraceSequence, function () {
            this.traces = new Kotlin.ArrayList(0);
            this.factory = new _.org.kevoree.factory.MainFactory();
          })
        }),
        util: Kotlin.definePackage(function () {
          this.Constants = Kotlin.createObject(null, function () {
            this.UNKNOWN_MUTATION_TYPE_EXCEPTION = 'Unknown mutation type: ';
            this.READ_ONLY_EXCEPTION = 'This model is ReadOnly. Elements are not modifiable.';
            this.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION = 'The list in parameter of the setter cannot be null. Use removeAll to empty a collection.';
            this.ELEMENT_HAS_NO_KEY_IN_COLLECTION = 'Cannot set the collection, because at least one element of it has no key!';
            this.EMPTY_KEY = 'Key empty : please set the attribute key before adding the object.';
            this.KMFQL_CONTAINED = 'contained';
            this.STRING_DEFAULTVAL = '';
            this.INT_DEFAULTVAL = 0;
            this.BOOLEAN_DEFAULTVAL = false;
            this.CHAR_DEFAULTVAL = 'a';
            this.SHORT_DEFAULTVAL = 0;
            this.LONG_DEFAULTVAL = 0.0;
            this.DOUBLE_DEFAULTVAL = 0.0;
            this.FLOAT_DEFAULTVAL = 0.0;
            this.BYTE_DEFAULTVAL = 0;
            this.org_kevoree_Instance = 'org.kevoree.Instance';
            this.Ref_superTypes = 'superTypes';
            this.Ref_ports = 'ports';
            this.Att_started = 'started';
            this.org_kevoree_NodeNetwork = 'org.kevoree.NodeNetwork';
            this.org_kevoree_TypedElement = 'org.kevoree.TypedElement';
            this.Ref_hub = 'hub';
            this.Ref_defaultValues = 'defaultValues';
            this.Ref_dataTypes = 'dataTypes';
            this.Att_factoryBean = 'factoryBean';
            this.Ref_port = 'port';
            this.Ref_returnType = 'returnType';
            this.CN_AdaptationPrimitiveType = 'AdaptationPrimitiveType';
            this.CN_Dictionary = 'Dictionary';
            this.Ref_portTypeRef = 'portTypeRef';
            this.CN_ContainerRoot = 'ContainerRoot';
            this.CN_Operation = 'Operation';
            this.CN_PortType = 'PortType';
            this.Att_networkType = 'networkType';
            this.Ref_values = 'values';
            this.Ref_initBy = 'initBy';
            this.Ref_link = 'link';
            this.org_kevoree_ContainerRoot = 'org.kevoree.ContainerRoot';
            this.CN_Group = 'Group';
            this.Ref_hosts = 'hosts';
            this.Att_interface = 'interface';
            this.org_kevoree_MBinding = 'org.kevoree.MBinding';
            this.Ref_subTypes = 'subTypes';
            this.Ref_groups = 'groups';
            this.org_kevoree_Group = 'org.kevoree.Group';
            this.Att_type = 'type';
            this.CN_TypedElement = 'TypedElement';
            this.Ref_dictionary = 'dictionary';
            this.Att_updateMethod = 'updateMethod';
            this.Ref_integrationPatterns = 'integrationPatterns';
            this.org_kevoree_DeployUnit = 'org.kevoree.DeployUnit';
            this.Att_unitName = 'unitName';
            this.Ref_hubs = 'hubs';
            this.Ref_parent = 'parent';
            this.Ref_mappings = 'mappings';
            this.Ref_attributes = 'attributes';
            this.Att_hashcode = 'hashcode';
            this.Att_lowerFragments = 'lowerFragments';
            this.Ref_targetNodeType = 'targetNodeType';
            this.Att_datatype = 'datatype';
            this.Ref_type = 'type';
            this.org_kevoree_LifeCycleTypeDefinition = 'org.kevoree.LifeCycleTypeDefinition';
            this.Att_abstract = 'abstract';
            this.org_kevoree_AdaptationPrimitiveType = 'org.kevoree.AdaptationPrimitiveType';
            this.Att_version = 'version';
            this.CN_Namespace = 'Namespace';
            this.org_kevoree_ContainerNode = 'org.kevoree.ContainerNode';
            this.Ref_components = 'components';
            this.org_kevoree_AdaptationPrimitiveTypeRef = 'org.kevoree.AdaptationPrimitiveTypeRef';
            this.Att_stopMethod = 'stopMethod';
            this.CN_ExtraFonctionalProperty = 'ExtraFonctionalProperty';
            this.Ref_childs = 'childs';
            this.CN_ChannelType = 'ChannelType';
            this.CN_GroupType = 'GroupType';
            this.Ref_typeDefinitions = 'typeDefinitions';
            this.Ref_genericTypes = 'genericTypes';
            this.CN_CompositeType = 'CompositeType';
            this.Ref_requiredLibs = 'requiredLibs';
            this.CN_PortTypeRef = 'PortTypeRef';
            this.Att_maxTime = 'maxTime';
            this.org_kevoree_DictionaryValue = 'org.kevoree.DictionaryValue';
            this.Ref_units = 'units';
            this.CN_DeployUnit = 'DeployUnit';
            this.org_kevoree_NodeLink = 'org.kevoree.NodeLink';
            this.org_kevoree_Parameter = 'org.kevoree.Parameter';
            this.org_kevoree_Repository = 'org.kevoree.Repository';
            this.CN_NamedElement = 'NamedElement';
            this.Att_serviceMethodName = 'serviceMethodName';
            this.CN_Instance = 'Instance';
            this.Ref_networkProperties = 'networkProperties';
            this.CN_AdaptationPrimitiveTypeRef = 'AdaptationPrimitiveTypeRef';
            this.Att_name = 'name';
            this.CN_Repository = 'Repository';
            this.CN_ComponentType = 'ComponentType';
            this.Att_order = 'order';
            this.Att_startMethod = 'startMethod';
            this.Att_lowerBindings = 'lowerBindings';
            this.org_kevoree_CompositeType = 'org.kevoree.CompositeType';
            this.org_kevoree_GroupType = 'org.kevoree.GroupType';
            this.org_kevoree_Operation = 'org.kevoree.Operation';
            this.CN_Port = 'Port';
            this.Att_optional = 'optional';
            this.Ref_targetNode = 'targetNode';
            this.Ref_attribute = 'attribute';
            this.Att_metaData = 'metaData';
            this.Att_beanMethodName = 'beanMethodName';
            this.org_kevoree_TypeDefinition = 'org.kevoree.TypeDefinition';
            this.Ref_target = 'target';
            this.org_kevoree_TypeLibrary = 'org.kevoree.TypeLibrary';
            this.Att_paramTypes = 'paramTypes';
            this.CN_MBinding = 'MBinding';
            this.Att_noDependency = 'noDependency';
            this.CN_NodeLink = 'NodeLink';
            this.CN_PortTypeMapping = 'PortTypeMapping';
            this.Ref_provided = 'provided';
            this.org_kevoree_PortTypeMapping = 'org.kevoree.PortTypeMapping';
            this.Ref_dictionaryType = 'dictionaryType';
            this.CN_ComponentInstance = 'ComponentInstance';
            this.Att_zoneID = 'zoneID';
            this.Att_upperBindings = 'upperBindings';
            this.Ref_host = 'host';
            this.CN_TypeLibrary = 'TypeLibrary';
            this.Ref_adaptationPrimitiveTypes = 'adaptationPrimitiveTypes';
            this.Att_url = 'url';
            this.Ref_namespace = 'namespace';
            this.org_kevoree_NodeType = 'org.kevoree.NodeType';
            this.Ref_managedPrimitiveTypes = 'managedPrimitiveTypes';
            this.CN_LifeCycleTypeDefinition = 'LifeCycleTypeDefinition';
            this.CN_ServicePortType = 'ServicePortType';
            this.CN_NodeNetwork = 'NodeNetwork';
            this.Att_state = 'state';
            this.Att_fragmentDependant = 'fragmentDependant';
            this.org_kevoree_ServicePortType = 'org.kevoree.ServicePortType';
            this.org_kevoree_PortType = 'org.kevoree.PortType';
            this.CN_MessagePortType = 'MessagePortType';
            this.Ref_operations = 'operations';
            this.CN_DictionaryAttribute = 'DictionaryAttribute';
            this.Att_generated_KMF_ID = 'generated_KMF_ID';
            this.org_kevoree_NamedElement = 'org.kevoree.NamedElement';
            this.CN_TypeDefinition = 'TypeDefinition';
            this.org_kevoree_ComponentType = 'org.kevoree.ComponentType';
            this.Ref_mBindings = 'mBindings';
            this.Ref_subNodes = 'subNodes';
            this.Ref_nodes = 'nodes';
            this.org_kevoree_ChannelType = 'org.kevoree.ChannelType';
            this.Ref_nodeNetworks = 'nodeNetworks';
            this.Ref_parameters = 'parameters';
            this.Ref_portTypes = 'portTypes';
            this.Att_estimatedRate = 'estimatedRate';
            this.Att_value = 'value';
            this.org_kevoree_NetworkProperty = 'org.kevoree.NetworkProperty';
            this.org_kevoree_Port = 'org.kevoree.Port';
            this.Ref_managedPrimitiveTypeRefs = 'managedPrimitiveTypeRefs';
            this.org_kevoree_ComponentInstance = 'org.kevoree.ComponentInstance';
            this.org_kevoree_IntegrationPattern = 'org.kevoree.IntegrationPattern';
            this.org_kevoree_DictionaryAttribute = 'org.kevoree.DictionaryAttribute';
            this.Ref_wires = 'wires';
            this.org_kevoree_Namespace = 'org.kevoree.Namespace';
            this.Ref_typeDefinition = 'typeDefinition';
            this.org_kevoree_Channel = 'org.kevoree.Channel';
            this.Ref_deployUnits = 'deployUnits';
            this.org_kevoree_Wire = 'org.kevoree.Wire';
            this.org_kevoree_Dictionary = 'org.kevoree.Dictionary';
            this.Att_synchrone = 'synchrone';
            this.CN_Wire = 'Wire';
            this.Ref_repositories = 'repositories';
            this.Ref_required = 'required';
            this.org_kevoree_ExtraFonctionalProperty = 'org.kevoree.ExtraFonctionalProperty';
            this.Att_lastCheck = 'lastCheck';
            this.Ref_libraries = 'libraries';
            this.Att_upperFragments = 'upperFragments';
            this.CN_IntegrationPattern = 'IntegrationPattern';
            this.CN_ContainerNode = 'ContainerNode';
            this.Att_groupName = 'groupName';
            this.CN_Parameter = 'Parameter';
            this.CN_DictionaryValue = 'DictionaryValue';
            this.org_kevoree_PortTypeRef = 'org.kevoree.PortTypeRef';
            this.Ref_filters = 'filters';
            this.CN_NetworkProperty = 'NetworkProperty';
            this.org_kevoree_DictionaryType = 'org.kevoree.DictionaryType';
            this.CN_NodeType = 'NodeType';
            this.Att_bean = 'bean';
            this.CN_Channel = 'Channel';
            this.Ref_bindings = 'bindings';
            this.Ref_ref = 'ref';
            this.CN_DictionaryType = 'DictionaryType';
            this.Ref_extraFonctionalProperties = 'extraFonctionalProperties';
            this.org_kevoree_MessagePortType = 'org.kevoree.MessagePortType';
          });
        }, /** @lends _.org.kevoree.util */ {
        })
      }),
      w3c: Kotlin.definePackage(null, /** @lends _.org.w3c */ {
        dom: Kotlin.definePackage(null, /** @lends _.org.w3c.dom */ {
          events: Kotlin.definePackage(null, /** @lends _.org.w3c.dom.events */ {
            EventListener: _c.EventListener
          })
        })
      })
    }),
    js: Kotlin.definePackage(null, /** @lends _.js */ {
      toChar: function ($receiver) {
        return $receiver != null ? $receiver : Kotlin.throwNPE();
      },
      lastIndexOf_0: function ($receiver, ch, fromIndex) {
        return $receiver.lastIndexOf(Kotlin.toString(ch), fromIndex);
      },
      lastIndexOf: function ($receiver, ch) {
        return $receiver.lastIndexOf(Kotlin.toString(ch));
      },
      indexOf: function ($receiver, ch) {
        return $receiver.indexOf(Kotlin.toString(ch));
      },
      indexOf_0: function ($receiver, ch, fromIndex) {
        return $receiver.indexOf(Kotlin.toString(ch), fromIndex);
      },
      matches: function ($receiver, regex) {
        var result = $receiver.match(regex);
        return result != null && result.length > 0;
      },
      capitalize: function ($receiver) {
        return _.kotlin.isNotEmpty($receiver) ? $receiver.substring(0, 1).toUpperCase() + $receiver.substring(1) : $receiver;
      },
      decapitalize: function ($receiver) {
        return _.kotlin.isNotEmpty($receiver) ? $receiver.substring(0, 1).toLowerCase() + $receiver.substring(1) : $receiver;
      }
    }),
    java: Kotlin.definePackage(null, /** @lends _.java */ {
      lang: Kotlin.definePackage(null, /** @lends _.java.lang */ {
        StringBuilder: Kotlin.createClass(null, function () {
          this.content = '';
        }, /** @lends _.java.lang.StringBuilder.prototype */ {
          append: function (sub) {
            this.content = this.content + sub;
          },
          append_0: function (sub) {
            this.content = this.content + sub;
          },
          delete: function (startIndex, endIndex) {
            this.content = '';
          },
          length: function () {
            return this.content.length;
          },
          toString: function () {
            return this.content;
          }
        })
      }),
      io: Kotlin.definePackage(null, /** @lends _.java.io */ {
        OutputStream: _c.OutputStream,
        BufferedOutputStream: Kotlin.createClass(_c.OutputStream, function (oo) {
          this.oo = oo;
        }, /** @lends _.java.io.BufferedOutputStream.prototype */ {
          write: function (s) {
            var tmp$0;
            ((tmp$0 = this.oo) != null ? tmp$0 : Kotlin.throwNPE()).result = s;
          }
        }),
        ByteArrayInputStream: Kotlin.createClass(_c.InputStream, function (inputBytes) {
          this.inputBytes = inputBytes;
        }, /** @lends _.java.io.ByteArrayInputStream.prototype */ {
          readBytes: function () {
            return this.inputBytes;
          }
        }),
        ByteArrayOutputStream: Kotlin.createClass(_c.OutputStream, function () {
          this.result = '';
        }, /** @lends _.java.io.ByteArrayOutputStream.prototype */ {
          flush: function () {
          },
          close: function () {
          },
          toString: function () {
            return this.result;
          }
        }),
        PrintStream: Kotlin.createClass(null, function (oo, autoflush) {
          this.oo = oo;
          this.result = '';
        }, /** @lends _.java.io.PrintStream.prototype */ {
          println: function () {
            this.result = this.result + '\n';
          },
          print: function (s) {
            this.result = this.result + s;
          },
          println_0: function (s) {
            this.print(s);
            this.println();
          },
          print_0: function (s) {
            this.result = this.result + s;
          },
          print_1: function (s) {
            this.result = this.result + s;
          },
          print_2: function (s) {
            this.result = this.result + s;
          },
          print_3: function (s) {
            if (s) {
              this.result = this.result + 'true';
            }
             else {
              this.result = this.result + 'false';
            }
          },
          println_1: function (s) {
            this.print_0(s);
            this.println();
          },
          flush: function () {
            var tmp$0;
            ((tmp$0 = this.oo) != null ? tmp$0 : Kotlin.throwNPE()).write(this.result);
          },
          close: function () {
          }
        })
      })
    })
  });
  Kotlin.defineModule('org.kevoree.model.js', _);
}());

module.exports = Kotlin.modules['org.kevoree.model.js'];

},{"kevoree-kotlin":"GtU2J/"}],18:[function(require,module,exports){
/*
	Class - JavaScript inheritance

	Construction:
		Setup and construction should happen in the construct() method.
		The construct() method is automatically chained, so all construct() methods defined by superclass methods will be called first.

	Initialization:
		Initialziation that needs to happen after all construct() methods have been called should be done in the init() method.
		The init() method is not automatically chained, so you must call _super() if you intend to call the superclass' init method.
		init() is not passed any arguments

	Destruction:
		Teardown and destruction should happen in the destruct() method. The destruct() method is also chained.

	Mixins:
		An array of mixins can be provided with the mixins[] property. An object or the prototype of a class should be provided, not a constructor.
		Mixins can be added at any time by calling this.mixin(properties)

	Usage:
		var MyClass = Class(properties);
		var MyClass = new Class(properties);
		var MyClass = Class.extend(properties);

	Credits:
		Inspired by Simple JavaScript Inheritance by John Resig http://ejohn.org/

	Usage differences:
		construct() is used to setup instances and is automatically chained so superclass construct() methods run automatically
		destruct() is used  to tear down instances. destruct() is also chained
		init(), if defined, is called after construction is complete and is not chained
		toString() can be defined as a string or a function
		mixin() is provided to mix properties into an instance
		properties.mixins as an array results in each of the provided objects being mixed in (last object wins)
		_super is passed as an argument (not as this._super) and can be used asynchronously
*/
(function(global) {
	// Used for default initialization methods
	var noop = function() {};

	// Given a function, the superTest RE will match if _super is the first argument to a function
	// The function will be serialized, then the serialized string will be searched for _super
	// If the environment isn't capable of function serialization, make it so superTest.test always returns true
	var superTest = /xyz/.test(function(){return 'xyz';}) ? /\(\s*_super\b/ : { test: function() { return true; } };

	// Remove the _super function from the passed arguments array
	var removeSuper = function(args, _super) {
		// For performance, first check if at least one argument was passed
		if (args && args.length && args[0] === _super)
			args = Array.prototype.slice.call(args, 1);
		return args;
	};

	// Bind an overriding method such that it gets the overridden method as its first argument
	var superify = function(name, func, superPrototype, isStatic) {
		var _super;

		// We redefine _super.apply so _super is stripped from the passed arguments array
		// This allows implementors to call _super.apply(this, arguments) without manually stripping off _super
		if (isStatic) {
			// Static binding: If the passed superPrototype is modified, the bound function will still call the ORIGINAL method
			// This comes into play when functions are mixed into an object that already has a function by that name (i.e. two mixins are used)
			var superFunc = superPrototype[name];
			_super = function _superStatic() {
				return superFunc.apply(this, arguments);
			};

			_super.apply = function _applier(context, args) {
				return Function.prototype.apply.call(superFunc, context, removeSuper(args, _super));
			};
		}
		else {
			// Dynamic binding: If the passed superPrototype is modified, the bound function will call the NEW method
			// This comes into play when functions are mixed into a class at declaration time
			_super = function _superDynamic() {
				return superPrototype[name].apply(this, arguments);
			};

			_super.apply = function _applier(context, args) {
				return Function.prototype.apply.call(superPrototype[name], context, removeSuper(args, _super));
			};
		}

		// Name the function for better stack traces
		return function _passSuper() {
			// Add the super function to the start of the arguments array
			var args = Array.prototype.slice.call(arguments);
			args.unshift(_super);

			// Call the function with the modified arguments
			return func.apply(this, args);
		};
	};

	// Mix the provided properties into the current context with the ability to call overridden methods with _super()
	var mixin = function(properties, superPrototype) {
		// Use this instance
		superPrototype = superPrototype || this.constructor && this.constructor.prototype;
		
		// Copy the properties onto the new prototype
		for (var name in properties) {
			// Never mix construct or destruct
			if (name === 'construct' || name === 'destruct')
				continue;

			// Check if the function uses _super
			// It should be a function, the super prototype should have a function by the same name
			// And finally, the function should take _super as its first argument
			var usesSuper = superPrototype && typeof properties[name] === 'function' && typeof superPrototype[name] === 'function' && superTest.test(properties[name]);

			if (usesSuper) {
				// Wrap the function such that _super will be passed accordingly
				if (this.hasOwnProperty(name))
					this[name] = superify(name, properties[name], this, true);
				else
					this[name] = superify(name, properties[name], superPrototype, false);
			}
			else {
				// Directly assign the property
				this[name] = properties[name];
			}
		}
	};

	// The base Class implementation acts as extend alias, with the exception that it can take properties.extend as the Class to extend
	var Class = function(properties) {
		// If a class-like object is passed as properties.extend, just call extend on it
		if (properties && properties.extend)
			return properties.extend.extend(properties);

		// Otherwise, just create a new class with the passed properties
		return Class.extend(properties);
	};
	
	// Add the mixin method to all classes created with Class
	Class.prototype.mixin = mixin;
	
	// Creates a new Class that inherits from this class
	// Give the function a name so it can refer to itself without arguments.callee
	Class.extend = function extend(properties) {
		var superPrototype = this.prototype;
		
		// Create an object with the prototype of the superclass
		var prototype = Object.create(superPrototype);
		
		if (properties) {
			// Mix the new properties into the class prototype
			// This does not copy construct and destruct
			mixin.call(prototype, properties, superPrototype);
			
			// Mix in all the mixins
			// This also does not copy construct and destruct
			if (Array.isArray(properties.mixins)) {
				for (var i = 0, ni = properties.mixins.length; i < ni; i++) {
					// Mixins should be _super enabled, with the methods defined in the prototype as the superclass methods
					mixin.call(prototype, properties.mixins[i], prototype);
				}
			}
			
			// Chain the construct() method (supermost executes first) if necessary
			if (properties.construct && superPrototype.construct) {
				prototype.construct = function() {
					superPrototype.construct.apply(this, arguments);
					properties.construct.apply(this, arguments);
				};
			}
			else if (properties.construct)
				prototype.construct = properties.construct;
			
			// Chain the destruct() method in reverse order (supermost executes last) if necessary
			if (properties.destruct && superPrototype.destruct) {
				prototype.destruct = function() {
					properties.destruct.apply(this, arguments);
					superPrototype.destruct.apply(this, arguments);
				};
			}
			else if (properties.destruct)
				prototype.destruct = properties.destruct;
			
			// Allow definition of toString as a string (turn it into a function)
			if (typeof properties.toString === 'string') {
				var className = properties.toString;
				prototype.toString = function() { return className; };
			}
		}

		// Define construct and init as noops if undefined
		// This serves to avoid conditionals inside of the constructor
		if (typeof prototype.construct !== 'function')
			prototype.construct = noop;
		if (typeof prototype.init !== 'function')
			prototype.init = noop;

		// The constructor handles creating an instance of the class, applying mixins, and calling construct() and init() methods
		function Class() {
			// Optimization: Requiring the new keyword and avoiding usage of Object.create() increases performance by 5x
			if (this instanceof Class === false) {
				throw new Error('Cannot create instance without new operator');
			}
			
			// Optimization: Avoiding conditionals in constructor increases performance of instantiation by 2x
			this.construct.apply(this, arguments);
			this.init();
		}

		// Assign prototype.constructor to the constructor itself
		// This allows instances to refer to this.constructor.prototype
		// This also allows creation of new instances using instance.constructor()
		prototype.constructor = Class;

		// Store the superPrototype
		// It will be accessible on an instance as follows:
		//	instance.superPrototype
		//	instance.constructor.prototype.superPrototype
		prototype.superPrototype = superPrototype;

		// Store the extended class' prototype as the prototype of the constructor
		Class.prototype = prototype;

		// Add extend() as a static method on the constructor
		Class.extend = extend;

		return Class;
	};
	
	if (typeof module !== 'undefined' && module.exports) {
		// Node.js Support
		module.exports = Class;
	}
	else if (typeof global.define === 'function') {
		(function(define) {
			// AMD Support
			define(function() { return Class; });
		}(global.define));
	}
	else {
		// Browser support
		global.Class = Class;
	}
}(this));

},{}],19:[function(require,module,exports){


//
// The shims in this file are not fully implemented shims for the ES5
// features, but do work for the particular usecases there is in
// the other modules.
//

var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

// Array.isArray is supported in IE9
function isArray(xs) {
  return toString.call(xs) === '[object Array]';
}
exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

// Array.prototype.indexOf is supported in IE9
exports.indexOf = function indexOf(xs, x) {
  if (xs.indexOf) return xs.indexOf(x);
  for (var i = 0; i < xs.length; i++) {
    if (x === xs[i]) return i;
  }
  return -1;
};

// Array.prototype.filter is supported in IE9
exports.filter = function filter(xs, fn) {
  if (xs.filter) return xs.filter(fn);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (fn(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
};

// Array.prototype.forEach is supported in IE9
exports.forEach = function forEach(xs, fn, self) {
  if (xs.forEach) return xs.forEach(fn, self);
  for (var i = 0; i < xs.length; i++) {
    fn.call(self, xs[i], i, xs);
  }
};

// Array.prototype.map is supported in IE9
exports.map = function map(xs, fn) {
  if (xs.map) return xs.map(fn);
  var out = new Array(xs.length);
  for (var i = 0; i < xs.length; i++) {
    out[i] = fn(xs[i], i, xs);
  }
  return out;
};

// Array.prototype.reduce is supported in IE9
exports.reduce = function reduce(array, callback, opt_initialValue) {
  if (array.reduce) return array.reduce(callback, opt_initialValue);
  var value, isValueSet = false;

  if (2 < arguments.length) {
    value = opt_initialValue;
    isValueSet = true;
  }
  for (var i = 0, l = array.length; l > i; ++i) {
    if (array.hasOwnProperty(i)) {
      if (isValueSet) {
        value = callback(value, array[i], i, array);
      }
      else {
        value = array[i];
        isValueSet = true;
      }
    }
  }

  return value;
};

// String.prototype.substr - negative index don't work in IE8
if ('ab'.substr(-1) !== 'b') {
  exports.substr = function (str, start, length) {
    // did we get a negative start, calculate how much it is from the beginning of the string
    if (start < 0) start = str.length + start;

    // call the original function
    return str.substr(start, length);
  };
} else {
  exports.substr = function (str, start, length) {
    return str.substr(start, length);
  };
}

// String.prototype.trim is supported in IE9
exports.trim = function (str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
};

// Function.prototype.bind is supported in IE9
exports.bind = function () {
  var args = Array.prototype.slice.call(arguments);
  var fn = args.shift();
  if (fn.bind) return fn.bind.apply(fn, args);
  var self = args.shift();
  return function () {
    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
  };
};

// Object.create is supported in IE9
function create(prototype, properties) {
  var object;
  if (prototype === null) {
    object = { '__proto__' : null };
  }
  else {
    if (typeof prototype !== 'object') {
      throw new TypeError(
        'typeof prototype[' + (typeof prototype) + '] != \'object\''
      );
    }
    var Type = function () {};
    Type.prototype = prototype;
    object = new Type();
    object.__proto__ = prototype;
  }
  if (typeof properties !== 'undefined' && Object.defineProperties) {
    Object.defineProperties(object, properties);
  }
  return object;
}
exports.create = typeof Object.create === 'function' ? Object.create : create;

// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
// they do show a description and number property on Error objects
function notObject(object) {
  return ((typeof object != "object" && typeof object != "function") || object === null);
}

function keysShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.keys called on a non-object");
  }

  var result = [];
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// getOwnPropertyNames is almost the same as Object.keys one key feature
//  is that it returns hidden properties, since that can't be implemented,
//  this feature gets reduced so it just shows the length property on arrays
function propertyShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
  }

  var result = keysShim(object);
  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
    result.push('length');
  }
  return result;
}

var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
  Object.getOwnPropertyNames : propertyShim;

if (new Error().hasOwnProperty('description')) {
  var ERROR_PROPERTY_FILTER = function (obj, array) {
    if (toString.call(obj) === '[object Error]') {
      array = exports.filter(array, function (name) {
        return name !== 'description' && name !== 'number' && name !== 'message';
      });
    }
    return array;
  };

  exports.keys = function (object) {
    return ERROR_PROPERTY_FILTER(object, keys(object));
  };
  exports.getOwnPropertyNames = function (object) {
    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
  };
} else {
  exports.keys = keys;
  exports.getOwnPropertyNames = getOwnPropertyNames;
}

// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
function valueObject(value, key) {
  return { value: value[key] };
}

if (typeof Object.getOwnPropertyDescriptor === 'function') {
  try {
    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  } catch (e) {
    // IE8 dom element issue - use a try catch and default to valueObject
    exports.getOwnPropertyDescriptor = function (value, key) {
      try {
        return Object.getOwnPropertyDescriptor(value, key);
      } catch (e) {
        return valueObject(value, key);
      }
    };
  }
} else {
  exports.getOwnPropertyDescriptor = valueObject;
}

},{}],20:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util');

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!util.isNumber(n) || n < 0)
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (util.isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        throw TypeError('Uncaught, unspecified "error" event.');
      }
      return false;
    }
  }

  handler = this._events[type];

  if (util.isUndefined(handler))
    return false;

  if (util.isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (util.isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              util.isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (util.isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (util.isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!util.isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      console.trace();
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  function g() {
    this.removeListener(type, g);
    listener.apply(this, arguments);
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (util.isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (util.isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (util.isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (util.isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (util.isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};
},{"util":21}],21:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var shims = require('_shims');

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  shims.forEach(array, function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = shims.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = shims.getOwnPropertyNames(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }

  shims.forEach(keys, function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (shims.indexOf(ctx.seen, desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = shims.reduce(output, function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return shims.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return arg instanceof Buffer;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = shims.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = shims.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

},{"__browserify_Buffer":22,"_shims":19}],22:[function(require,module,exports){
require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],"q9TxCC":[function(require,module,exports){
var assert;
exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function Buffer(subject, encoding, offset) {
  if(!assert) assert= require('assert');
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding == "base64" && typeof subject == "string") {
    subject = stringtrim(subject);
    while (subject.length % 4 != 0) {
      subject = subject + "="; 
    }
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    // slicing works, with limitations (no parent tracking/update)
    // check https://github.com/toots/buffer-browserify/issues/19
    for (var i = 0; i < this.length; i++) {
        this[i] = subject.get(i+offset);
    }
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          this[i] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};

// slice(start, end)
function clamp(index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
}

Buffer.prototype.slice = function(start, end) {
  var len = this.length;
  start = clamp(start, len, 0);
  end = clamp(end, len, len);
  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

},{"./buffer_ieee754":1,"assert":6,"base64-js":4}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],4:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],5:[function(require,module,exports){


//
// The shims in this file are not fully implemented shims for the ES5
// features, but do work for the particular usecases there is in
// the other modules.
//

var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

// Array.isArray is supported in IE9
function isArray(xs) {
  return toString.call(xs) === '[object Array]';
}
exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

// Array.prototype.indexOf is supported in IE9
exports.indexOf = function indexOf(xs, x) {
  if (xs.indexOf) return xs.indexOf(x);
  for (var i = 0; i < xs.length; i++) {
    if (x === xs[i]) return i;
  }
  return -1;
};

// Array.prototype.filter is supported in IE9
exports.filter = function filter(xs, fn) {
  if (xs.filter) return xs.filter(fn);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (fn(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
};

// Array.prototype.forEach is supported in IE9
exports.forEach = function forEach(xs, fn, self) {
  if (xs.forEach) return xs.forEach(fn, self);
  for (var i = 0; i < xs.length; i++) {
    fn.call(self, xs[i], i, xs);
  }
};

// Array.prototype.map is supported in IE9
exports.map = function map(xs, fn) {
  if (xs.map) return xs.map(fn);
  var out = new Array(xs.length);
  for (var i = 0; i < xs.length; i++) {
    out[i] = fn(xs[i], i, xs);
  }
  return out;
};

// Array.prototype.reduce is supported in IE9
exports.reduce = function reduce(array, callback, opt_initialValue) {
  if (array.reduce) return array.reduce(callback, opt_initialValue);
  var value, isValueSet = false;

  if (2 < arguments.length) {
    value = opt_initialValue;
    isValueSet = true;
  }
  for (var i = 0, l = array.length; l > i; ++i) {
    if (array.hasOwnProperty(i)) {
      if (isValueSet) {
        value = callback(value, array[i], i, array);
      }
      else {
        value = array[i];
        isValueSet = true;
      }
    }
  }

  return value;
};

// String.prototype.substr - negative index don't work in IE8
if ('ab'.substr(-1) !== 'b') {
  exports.substr = function (str, start, length) {
    // did we get a negative start, calculate how much it is from the beginning of the string
    if (start < 0) start = str.length + start;

    // call the original function
    return str.substr(start, length);
  };
} else {
  exports.substr = function (str, start, length) {
    return str.substr(start, length);
  };
}

// String.prototype.trim is supported in IE9
exports.trim = function (str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
};

// Function.prototype.bind is supported in IE9
exports.bind = function () {
  var args = Array.prototype.slice.call(arguments);
  var fn = args.shift();
  if (fn.bind) return fn.bind.apply(fn, args);
  var self = args.shift();
  return function () {
    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
  };
};

// Object.create is supported in IE9
function create(prototype, properties) {
  var object;
  if (prototype === null) {
    object = { '__proto__' : null };
  }
  else {
    if (typeof prototype !== 'object') {
      throw new TypeError(
        'typeof prototype[' + (typeof prototype) + '] != \'object\''
      );
    }
    var Type = function () {};
    Type.prototype = prototype;
    object = new Type();
    object.__proto__ = prototype;
  }
  if (typeof properties !== 'undefined' && Object.defineProperties) {
    Object.defineProperties(object, properties);
  }
  return object;
}
exports.create = typeof Object.create === 'function' ? Object.create : create;

// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
// they do show a description and number property on Error objects
function notObject(object) {
  return ((typeof object != "object" && typeof object != "function") || object === null);
}

function keysShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.keys called on a non-object");
  }

  var result = [];
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// getOwnPropertyNames is almost the same as Object.keys one key feature
//  is that it returns hidden properties, since that can't be implemented,
//  this feature gets reduced so it just shows the length property on arrays
function propertyShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
  }

  var result = keysShim(object);
  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
    result.push('length');
  }
  return result;
}

var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
  Object.getOwnPropertyNames : propertyShim;

if (new Error().hasOwnProperty('description')) {
  var ERROR_PROPERTY_FILTER = function (obj, array) {
    if (toString.call(obj) === '[object Error]') {
      array = exports.filter(array, function (name) {
        return name !== 'description' && name !== 'number' && name !== 'message';
      });
    }
    return array;
  };

  exports.keys = function (object) {
    return ERROR_PROPERTY_FILTER(object, keys(object));
  };
  exports.getOwnPropertyNames = function (object) {
    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
  };
} else {
  exports.keys = keys;
  exports.getOwnPropertyNames = getOwnPropertyNames;
}

// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
function valueObject(value, key) {
  return { value: value[key] };
}

if (typeof Object.getOwnPropertyDescriptor === 'function') {
  try {
    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  } catch (e) {
    // IE8 dom element issue - use a try catch and default to valueObject
    exports.getOwnPropertyDescriptor = function (value, key) {
      try {
        return Object.getOwnPropertyDescriptor(value, key);
      } catch (e) {
        return valueObject(value, key);
      }
    };
  }
} else {
  exports.getOwnPropertyDescriptor = valueObject;
}

},{}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// UTILITY
var util = require('util');
var shims = require('_shims');
var pSlice = Array.prototype.slice;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  this.message = options.message || getMessage(this);
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = shims.keys(a),
        kb = shims.keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};
},{"_shims":5,"util":7}],7:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var shims = require('_shims');

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  shims.forEach(array, function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = shims.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = shims.getOwnPropertyNames(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }

  shims.forEach(keys, function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (shims.indexOf(ctx.seen, desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = shims.reduce(output, function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return shims.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return arg instanceof Buffer;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = shims.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = shims.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

},{"_shims":5}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],23:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])
;